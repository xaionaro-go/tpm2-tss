// License: CC-0

// WARNING: This file has automatically been generated on Sat, 17 Apr 2021 19:11:08 IST.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package go_tpm2_tss

/*
#cgo pkg-config: tss2-tcti-mssim tss2-tcti-device tss2-mu tss2-tctildr tss2-rc tss2-sys tss2-esys
#cgo CFLAGS: -I ../c/include
#include "tss2/tss2_common.h"
#include "tss2/tss2_esys.h"
#include "tss2/tss2_mu.h"
#include "tss2/tss2_rc.h"
#include "tss2/tss2_sys.h"
#include "tss2/tss2_tcti_device.h"
#include "tss2/tss2_tcti.h"
#include "tss2/tss2_tctildr.h"
#include "tss2/tss2_tcti_mssim.h"
#include "tss2/tss2_tcti_tbs.h"
#include "tss2/tss2_tpm2_types.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// Ref returns a reference to C object as it is.
func (x *Tss2AbiVersion) Ref() *C.TSS2_ABI_VERSION {
	if x == nil {
		return nil
	}
	return (*C.TSS2_ABI_VERSION)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tss2AbiVersion) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTss2AbiVersionRef converts the C object reference into a raw struct reference without wrapping.
func NewTss2AbiVersionRef(ref unsafe.Pointer) *Tss2AbiVersion {
	return (*Tss2AbiVersion)(ref)
}

// NewTss2AbiVersion allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTss2AbiVersion() *Tss2AbiVersion {
	return (*Tss2AbiVersion)(allocTss2AbiVersionMemory(1))
}

// allocTss2AbiVersionMemory allocates memory for type C.TSS2_ABI_VERSION in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTss2AbiVersionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTss2AbiVersionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTss2AbiVersionValue = unsafe.Sizeof([1]C.TSS2_ABI_VERSION{})

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tss2AbiVersion) PassRef() *C.TSS2_ABI_VERSION {
	if x == nil {
		x = (*Tss2AbiVersion)(allocTss2AbiVersionMemory(1))
	}
	return (*C.TSS2_ABI_VERSION)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *EsysContext) Ref() *C.ESYS_CONTEXT {
	if x == nil {
		return nil
	}
	return (*C.ESYS_CONTEXT)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *EsysContext) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewEsysContextRef converts the C object reference into a raw struct reference without wrapping.
func NewEsysContextRef(ref unsafe.Pointer) *EsysContext {
	return (*EsysContext)(ref)
}

// NewEsysContext allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewEsysContext() *EsysContext {
	return (*EsysContext)(allocEsysContextMemory(1))
}

// allocEsysContextMemory allocates memory for type C.ESYS_CONTEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocEsysContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfEsysContextValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfEsysContextValue = unsafe.Sizeof([1]C.ESYS_CONTEXT{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *EsysContext) PassRef() *C.ESYS_CONTEXT {
	if x == nil {
		x = (*EsysContext)(allocEsysContextMemory(1))
	}
	return (*C.ESYS_CONTEXT)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tss2TctiContext) Ref() *C.TSS2_TCTI_CONTEXT {
	if x == nil {
		return nil
	}
	return (*C.TSS2_TCTI_CONTEXT)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tss2TctiContext) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTss2TctiContextRef converts the C object reference into a raw struct reference without wrapping.
func NewTss2TctiContextRef(ref unsafe.Pointer) *Tss2TctiContext {
	return (*Tss2TctiContext)(ref)
}

// NewTss2TctiContext allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTss2TctiContext() *Tss2TctiContext {
	return (*Tss2TctiContext)(allocTss2TctiContextMemory(1))
}

// allocTss2TctiContextMemory allocates memory for type C.TSS2_TCTI_CONTEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTss2TctiContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTss2TctiContextValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTss2TctiContextValue = unsafe.Sizeof([1]C.TSS2_TCTI_CONTEXT{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tss2TctiContext) PassRef() *C.TSS2_TCTI_CONTEXT {
	if x == nil {
		x = (*Tss2TctiContext)(allocTss2TctiContextMemory(1))
	}
	return (*C.TSS2_TCTI_CONTEXT)(unsafe.Pointer(x))
}

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

func (x Tss2TctiTransmitFcn) PassRef() (ref *C.TSS2_TCTI_TRANSMIT_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiTransmitFcn3FB81C0DFunc == nil {
		tss2TctiTransmitFcn3FB81C0DFunc = x
	}
	return (*C.TSS2_TCTI_TRANSMIT_FCN)(C.TSS2_TCTI_TRANSMIT_FCN_3fb81c0d), nil
}

func (x Tss2TctiTransmitFcn) PassValue() (ref C.TSS2_TCTI_TRANSMIT_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiTransmitFcn3FB81C0DFunc == nil {
		tss2TctiTransmitFcn3FB81C0DFunc = x
	}
	return (C.TSS2_TCTI_TRANSMIT_FCN)(C.TSS2_TCTI_TRANSMIT_FCN_3fb81c0d), nil
}

func NewTss2TctiTransmitFcnRef(ref unsafe.Pointer) *Tss2TctiTransmitFcn {
	return (*Tss2TctiTransmitFcn)(ref)
}

//export tss2TctiTransmitFcn3FB81C0D
func tss2TctiTransmitFcn3FB81C0D(ctcticontext *C.TSS2_TCTI_CONTEXT, csize C.size_t, ccommand *C.uint8_t) C.TSS2_RC {
	if tss2TctiTransmitFcn3FB81C0DFunc != nil {
		var tcticontext3fb81c0d []Tss2TctiContext
		hxfc4425b := (*sliceHeader)(unsafe.Pointer(&tcticontext3fb81c0d))
		hxfc4425b.Data = unsafe.Pointer(ctcticontext)
		hxfc4425b.Cap = 0x7fffffff
		// hxfc4425b.Len = ?

		size3fb81c0d := (SizeT)(csize)
		var command3fb81c0d []Uint8T
		hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&command3fb81c0d))
		hxf95e7c8.Data = unsafe.Pointer(ccommand)
		hxf95e7c8.Cap = 0x7fffffff
		// hxf95e7c8.Len = ?

		ret3fb81c0d := tss2TctiTransmitFcn3FB81C0DFunc(tcticontext3fb81c0d, size3fb81c0d, command3fb81c0d)
		ret, _ := (C.TSS2_RC)(ret3fb81c0d), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var tss2TctiTransmitFcn3FB81C0DFunc Tss2TctiTransmitFcn

func (x Tss2TctiReceiveFcn) PassRef() (ref *C.TSS2_TCTI_RECEIVE_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiReceiveFcnF4548F13Func == nil {
		tss2TctiReceiveFcnF4548F13Func = x
	}
	return (*C.TSS2_TCTI_RECEIVE_FCN)(C.TSS2_TCTI_RECEIVE_FCN_f4548f13), nil
}

func (x Tss2TctiReceiveFcn) PassValue() (ref C.TSS2_TCTI_RECEIVE_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiReceiveFcnF4548F13Func == nil {
		tss2TctiReceiveFcnF4548F13Func = x
	}
	return (C.TSS2_TCTI_RECEIVE_FCN)(C.TSS2_TCTI_RECEIVE_FCN_f4548f13), nil
}

func NewTss2TctiReceiveFcnRef(ref unsafe.Pointer) *Tss2TctiReceiveFcn {
	return (*Tss2TctiReceiveFcn)(ref)
}

//export tss2TctiReceiveFcnF4548F13
func tss2TctiReceiveFcnF4548F13(ctcticontext *C.TSS2_TCTI_CONTEXT, csize *C.size_t, cresponse *C.uint8_t, ctimeout C.int32_t) C.TSS2_RC {
	if tss2TctiReceiveFcnF4548F13Func != nil {
		var tcticontextf4548f13 []Tss2TctiContext
		hxff2234b := (*sliceHeader)(unsafe.Pointer(&tcticontextf4548f13))
		hxff2234b.Data = unsafe.Pointer(ctcticontext)
		hxff2234b.Cap = 0x7fffffff
		// hxff2234b.Len = ?

		var sizef4548f13 []SizeT
		hxff73280 := (*sliceHeader)(unsafe.Pointer(&sizef4548f13))
		hxff73280.Data = unsafe.Pointer(csize)
		hxff73280.Cap = 0x7fffffff
		// hxff73280.Len = ?

		var responsef4548f13 []Uint8T
		hxfa9955c := (*sliceHeader)(unsafe.Pointer(&responsef4548f13))
		hxfa9955c.Data = unsafe.Pointer(cresponse)
		hxfa9955c.Cap = 0x7fffffff
		// hxfa9955c.Len = ?

		timeoutf4548f13 := (Int32T)(ctimeout)
		retf4548f13 := tss2TctiReceiveFcnF4548F13Func(tcticontextf4548f13, sizef4548f13, responsef4548f13, timeoutf4548f13)
		ret, _ := (C.TSS2_RC)(retf4548f13), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var tss2TctiReceiveFcnF4548F13Func Tss2TctiReceiveFcn

func (x Tss2TctiFinalizeFcn) PassRef() (ref *C.TSS2_TCTI_FINALIZE_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiFinalizeFcnF5E8712EFunc == nil {
		tss2TctiFinalizeFcnF5E8712EFunc = x
	}
	return (*C.TSS2_TCTI_FINALIZE_FCN)(C.TSS2_TCTI_FINALIZE_FCN_f5e8712e), nil
}

func (x Tss2TctiFinalizeFcn) PassValue() (ref C.TSS2_TCTI_FINALIZE_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiFinalizeFcnF5E8712EFunc == nil {
		tss2TctiFinalizeFcnF5E8712EFunc = x
	}
	return (C.TSS2_TCTI_FINALIZE_FCN)(C.TSS2_TCTI_FINALIZE_FCN_f5e8712e), nil
}

func NewTss2TctiFinalizeFcnRef(ref unsafe.Pointer) *Tss2TctiFinalizeFcn {
	return (*Tss2TctiFinalizeFcn)(ref)
}

//export tss2TctiFinalizeFcnF5E8712E
func tss2TctiFinalizeFcnF5E8712E(ctcticontext *C.TSS2_TCTI_CONTEXT) {
	if tss2TctiFinalizeFcnF5E8712EFunc != nil {
		var tcticontextf5e8712e []Tss2TctiContext
		hxfa3f05c := (*sliceHeader)(unsafe.Pointer(&tcticontextf5e8712e))
		hxfa3f05c.Data = unsafe.Pointer(ctcticontext)
		hxfa3f05c.Cap = 0x7fffffff
		// hxfa3f05c.Len = ?

		tss2TctiFinalizeFcnF5E8712EFunc(tcticontextf5e8712e)
		return
	}
	panic("callback func has not been set (race?)")
}

var tss2TctiFinalizeFcnF5E8712EFunc Tss2TctiFinalizeFcn

func (x Tss2TctiCancelFcn) PassRef() (ref *C.TSS2_TCTI_CANCEL_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiCancelFcn900241EBFunc == nil {
		tss2TctiCancelFcn900241EBFunc = x
	}
	return (*C.TSS2_TCTI_CANCEL_FCN)(C.TSS2_TCTI_CANCEL_FCN_900241eb), nil
}

func (x Tss2TctiCancelFcn) PassValue() (ref C.TSS2_TCTI_CANCEL_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiCancelFcn900241EBFunc == nil {
		tss2TctiCancelFcn900241EBFunc = x
	}
	return (C.TSS2_TCTI_CANCEL_FCN)(C.TSS2_TCTI_CANCEL_FCN_900241eb), nil
}

func NewTss2TctiCancelFcnRef(ref unsafe.Pointer) *Tss2TctiCancelFcn {
	return (*Tss2TctiCancelFcn)(ref)
}

//export tss2TctiCancelFcn900241EB
func tss2TctiCancelFcn900241EB(ctcticontext *C.TSS2_TCTI_CONTEXT) C.TSS2_RC {
	if tss2TctiCancelFcn900241EBFunc != nil {
		var tcticontext900241eb []Tss2TctiContext
		hxf0d18b7 := (*sliceHeader)(unsafe.Pointer(&tcticontext900241eb))
		hxf0d18b7.Data = unsafe.Pointer(ctcticontext)
		hxf0d18b7.Cap = 0x7fffffff
		// hxf0d18b7.Len = ?

		ret900241eb := tss2TctiCancelFcn900241EBFunc(tcticontext900241eb)
		ret, _ := (C.TSS2_RC)(ret900241eb), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var tss2TctiCancelFcn900241EBFunc Tss2TctiCancelFcn

func (x Tss2TctiGetPollHandlesFcn) PassRef() (ref *C.TSS2_TCTI_GET_POLL_HANDLES_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiGetPollHandlesFcnD9753DA9Func == nil {
		tss2TctiGetPollHandlesFcnD9753DA9Func = x
	}
	return (*C.TSS2_TCTI_GET_POLL_HANDLES_FCN)(C.TSS2_TCTI_GET_POLL_HANDLES_FCN_d9753da9), nil
}

func (x Tss2TctiGetPollHandlesFcn) PassValue() (ref C.TSS2_TCTI_GET_POLL_HANDLES_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiGetPollHandlesFcnD9753DA9Func == nil {
		tss2TctiGetPollHandlesFcnD9753DA9Func = x
	}
	return (C.TSS2_TCTI_GET_POLL_HANDLES_FCN)(C.TSS2_TCTI_GET_POLL_HANDLES_FCN_d9753da9), nil
}

func NewTss2TctiGetPollHandlesFcnRef(ref unsafe.Pointer) *Tss2TctiGetPollHandlesFcn {
	return (*Tss2TctiGetPollHandlesFcn)(ref)
}

//export tss2TctiGetPollHandlesFcnD9753DA9
func tss2TctiGetPollHandlesFcnD9753DA9(ctcticontext *C.TSS2_TCTI_CONTEXT, chandles *C.TSS2_TCTI_POLL_HANDLE, cnumHandles *C.size_t) C.TSS2_RC {
	if tss2TctiGetPollHandlesFcnD9753DA9Func != nil {
		var tcticontextd9753da9 []Tss2TctiContext
		hxf2fab0d := (*sliceHeader)(unsafe.Pointer(&tcticontextd9753da9))
		hxf2fab0d.Data = unsafe.Pointer(ctcticontext)
		hxf2fab0d.Cap = 0x7fffffff
		// hxf2fab0d.Len = ?

		handlesd9753da9 := (*Tss2TctiPollHandle)(unsafe.Pointer(chandles))
		var numHandlesd9753da9 []SizeT
		hxf69fe70 := (*sliceHeader)(unsafe.Pointer(&numHandlesd9753da9))
		hxf69fe70.Data = unsafe.Pointer(cnumHandles)
		hxf69fe70.Cap = 0x7fffffff
		// hxf69fe70.Len = ?

		retd9753da9 := tss2TctiGetPollHandlesFcnD9753DA9Func(tcticontextd9753da9, handlesd9753da9, numHandlesd9753da9)
		ret, _ := (C.TSS2_RC)(retd9753da9), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var tss2TctiGetPollHandlesFcnD9753DA9Func Tss2TctiGetPollHandlesFcn

func (x Tss2TctiSetLocalityFcn) PassRef() (ref *C.TSS2_TCTI_SET_LOCALITY_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiSetLocalityFcn47C1ECDAFunc == nil {
		tss2TctiSetLocalityFcn47C1ECDAFunc = x
	}
	return (*C.TSS2_TCTI_SET_LOCALITY_FCN)(C.TSS2_TCTI_SET_LOCALITY_FCN_47c1ecda), nil
}

func (x Tss2TctiSetLocalityFcn) PassValue() (ref C.TSS2_TCTI_SET_LOCALITY_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiSetLocalityFcn47C1ECDAFunc == nil {
		tss2TctiSetLocalityFcn47C1ECDAFunc = x
	}
	return (C.TSS2_TCTI_SET_LOCALITY_FCN)(C.TSS2_TCTI_SET_LOCALITY_FCN_47c1ecda), nil
}

func NewTss2TctiSetLocalityFcnRef(ref unsafe.Pointer) *Tss2TctiSetLocalityFcn {
	return (*Tss2TctiSetLocalityFcn)(ref)
}

//export tss2TctiSetLocalityFcn47C1ECDA
func tss2TctiSetLocalityFcn47C1ECDA(ctcticontext *C.TSS2_TCTI_CONTEXT, clocality C.uint8_t) C.TSS2_RC {
	if tss2TctiSetLocalityFcn47C1ECDAFunc != nil {
		var tcticontext47c1ecda []Tss2TctiContext
		hxf65bf54 := (*sliceHeader)(unsafe.Pointer(&tcticontext47c1ecda))
		hxf65bf54.Data = unsafe.Pointer(ctcticontext)
		hxf65bf54.Cap = 0x7fffffff
		// hxf65bf54.Len = ?

		locality47c1ecda := (Uint8T)(clocality)
		ret47c1ecda := tss2TctiSetLocalityFcn47C1ECDAFunc(tcticontext47c1ecda, locality47c1ecda)
		ret, _ := (C.TSS2_RC)(ret47c1ecda), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var tss2TctiSetLocalityFcn47C1ECDAFunc Tss2TctiSetLocalityFcn

func (x Tss2TctiMakeStickyFcn) PassRef() (ref *C.TSS2_TCTI_MAKE_STICKY_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiMakeStickyFcnDE2406FCFunc == nil {
		tss2TctiMakeStickyFcnDE2406FCFunc = x
	}
	return (*C.TSS2_TCTI_MAKE_STICKY_FCN)(C.TSS2_TCTI_MAKE_STICKY_FCN_de2406fc), nil
}

func (x Tss2TctiMakeStickyFcn) PassValue() (ref C.TSS2_TCTI_MAKE_STICKY_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiMakeStickyFcnDE2406FCFunc == nil {
		tss2TctiMakeStickyFcnDE2406FCFunc = x
	}
	return (C.TSS2_TCTI_MAKE_STICKY_FCN)(C.TSS2_TCTI_MAKE_STICKY_FCN_de2406fc), nil
}

func NewTss2TctiMakeStickyFcnRef(ref unsafe.Pointer) *Tss2TctiMakeStickyFcn {
	return (*Tss2TctiMakeStickyFcn)(ref)
}

//export tss2TctiMakeStickyFcnDE2406FC
func tss2TctiMakeStickyFcnDE2406FC(ctcticontext *C.TSS2_TCTI_CONTEXT, chandle *C.TPM2_HANDLE, csticky C.uint8_t) C.TSS2_RC {
	if tss2TctiMakeStickyFcnDE2406FCFunc != nil {
		var tcticontextde2406fc []Tss2TctiContext
		hxf3b8dbd := (*sliceHeader)(unsafe.Pointer(&tcticontextde2406fc))
		hxf3b8dbd.Data = unsafe.Pointer(ctcticontext)
		hxf3b8dbd.Cap = 0x7fffffff
		// hxf3b8dbd.Len = ?

		var handlede2406fc []Tpm2Handle
		hxf7a6dff := (*sliceHeader)(unsafe.Pointer(&handlede2406fc))
		hxf7a6dff.Data = unsafe.Pointer(chandle)
		hxf7a6dff.Cap = 0x7fffffff
		// hxf7a6dff.Len = ?

		stickyde2406fc := (Uint8T)(csticky)
		retde2406fc := tss2TctiMakeStickyFcnDE2406FCFunc(tcticontextde2406fc, handlede2406fc, stickyde2406fc)
		ret, _ := (C.TSS2_RC)(retde2406fc), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var tss2TctiMakeStickyFcnDE2406FCFunc Tss2TctiMakeStickyFcn

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}

func (x Tss2TctiInitFunc) PassRef() (ref *C.TSS2_TCTI_INIT_FUNC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiInitFuncA5EFFE61Func == nil {
		tss2TctiInitFuncA5EFFE61Func = x
	}
	return (*C.TSS2_TCTI_INIT_FUNC)(C.TSS2_TCTI_INIT_FUNC_a5effe61), nil
}

func (x Tss2TctiInitFunc) PassValue() (ref C.TSS2_TCTI_INIT_FUNC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiInitFuncA5EFFE61Func == nil {
		tss2TctiInitFuncA5EFFE61Func = x
	}
	return (C.TSS2_TCTI_INIT_FUNC)(C.TSS2_TCTI_INIT_FUNC_a5effe61), nil
}

func NewTss2TctiInitFuncRef(ref unsafe.Pointer) *Tss2TctiInitFunc {
	return (*Tss2TctiInitFunc)(ref)
}

//export tss2TctiInitFuncA5EFFE61
func tss2TctiInitFuncA5EFFE61(ctcticontext *C.TSS2_TCTI_CONTEXT, csize *C.size_t, cconfig *C.char) C.TSS2_RC {
	if tss2TctiInitFuncA5EFFE61Func != nil {
		var tcticontexta5effe61 []Tss2TctiContext
		hxfe48d67 := (*sliceHeader)(unsafe.Pointer(&tcticontexta5effe61))
		hxfe48d67.Data = unsafe.Pointer(ctcticontext)
		hxfe48d67.Cap = 0x7fffffff
		// hxfe48d67.Len = ?

		var sizea5effe61 []uint32
		hxf4171bf := (*sliceHeader)(unsafe.Pointer(&sizea5effe61))
		hxf4171bf.Data = unsafe.Pointer(csize)
		hxf4171bf.Cap = 0x7fffffff
		// hxf4171bf.Len = ?

		configa5effe61 := packPCharString(cconfig)
		reta5effe61 := tss2TctiInitFuncA5EFFE61Func(tcticontexta5effe61, sizea5effe61, configa5effe61)
		ret, _ := (C.TSS2_RC)(reta5effe61), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var tss2TctiInitFuncA5EFFE61Func Tss2TctiInitFunc

// Ref returns a reference to C object as it is.
func (x *Tss2TctiContextCommonV1) Ref() *C.TSS2_TCTI_CONTEXT_COMMON_V1 {
	if x == nil {
		return nil
	}
	return (*C.TSS2_TCTI_CONTEXT_COMMON_V1)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tss2TctiContextCommonV1) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTss2TctiContextCommonV1Ref converts the C object reference into a raw struct reference without wrapping.
func NewTss2TctiContextCommonV1Ref(ref unsafe.Pointer) *Tss2TctiContextCommonV1 {
	return (*Tss2TctiContextCommonV1)(ref)
}

// NewTss2TctiContextCommonV1 allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTss2TctiContextCommonV1() *Tss2TctiContextCommonV1 {
	return (*Tss2TctiContextCommonV1)(allocTss2TctiContextCommonV1Memory(1))
}

// allocTss2TctiContextCommonV1Memory allocates memory for type C.TSS2_TCTI_CONTEXT_COMMON_V1 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTss2TctiContextCommonV1Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTss2TctiContextCommonV1Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTss2TctiContextCommonV1Value = unsafe.Sizeof([1]C.TSS2_TCTI_CONTEXT_COMMON_V1{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tss2TctiContextCommonV1) PassRef() *C.TSS2_TCTI_CONTEXT_COMMON_V1 {
	if x == nil {
		x = (*Tss2TctiContextCommonV1)(allocTss2TctiContextCommonV1Memory(1))
	}
	return (*C.TSS2_TCTI_CONTEXT_COMMON_V1)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tss2TctiContextCommonV2) Ref() *C.TSS2_TCTI_CONTEXT_COMMON_V2 {
	if x == nil {
		return nil
	}
	return (*C.TSS2_TCTI_CONTEXT_COMMON_V2)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tss2TctiContextCommonV2) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTss2TctiContextCommonV2Ref converts the C object reference into a raw struct reference without wrapping.
func NewTss2TctiContextCommonV2Ref(ref unsafe.Pointer) *Tss2TctiContextCommonV2 {
	return (*Tss2TctiContextCommonV2)(ref)
}

// NewTss2TctiContextCommonV2 allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTss2TctiContextCommonV2() *Tss2TctiContextCommonV2 {
	return (*Tss2TctiContextCommonV2)(allocTss2TctiContextCommonV2Memory(1))
}

// allocTss2TctiContextCommonV2Memory allocates memory for type C.TSS2_TCTI_CONTEXT_COMMON_V2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTss2TctiContextCommonV2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTss2TctiContextCommonV2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTss2TctiContextCommonV2Value = unsafe.Sizeof([1]C.TSS2_TCTI_CONTEXT_COMMON_V2{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tss2TctiContextCommonV2) PassRef() *C.TSS2_TCTI_CONTEXT_COMMON_V2 {
	if x == nil {
		x = (*Tss2TctiContextCommonV2)(allocTss2TctiContextCommonV2Memory(1))
	}
	return (*C.TSS2_TCTI_CONTEXT_COMMON_V2)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tss2TctiContextCommonCurrent) Ref() *C.TSS2_TCTI_CONTEXT_COMMON_V2 {
	if x == nil {
		return nil
	}
	return (*C.TSS2_TCTI_CONTEXT_COMMON_V2)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tss2TctiContextCommonCurrent) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTss2TctiContextCommonCurrentRef converts the C object reference into a raw struct reference without wrapping.
func NewTss2TctiContextCommonCurrentRef(ref unsafe.Pointer) *Tss2TctiContextCommonCurrent {
	return (*Tss2TctiContextCommonCurrent)(ref)
}

// NewTss2TctiContextCommonCurrent allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTss2TctiContextCommonCurrent() *Tss2TctiContextCommonCurrent {
	return (*Tss2TctiContextCommonCurrent)(allocTss2TctiContextCommonV2Memory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tss2TctiContextCommonCurrent) PassRef() *C.TSS2_TCTI_CONTEXT_COMMON_V2 {
	if x == nil {
		x = (*Tss2TctiContextCommonCurrent)(allocTss2TctiContextCommonV2Memory(1))
	}
	return (*C.TSS2_TCTI_CONTEXT_COMMON_V2)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tss2TctiInfo) Ref() *C.TSS2_TCTI_INFO {
	if x == nil {
		return nil
	}
	return (*C.TSS2_TCTI_INFO)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tss2TctiInfo) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTss2TctiInfoRef converts the C object reference into a raw struct reference without wrapping.
func NewTss2TctiInfoRef(ref unsafe.Pointer) *Tss2TctiInfo {
	return (*Tss2TctiInfo)(ref)
}

// NewTss2TctiInfo allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTss2TctiInfo() *Tss2TctiInfo {
	return (*Tss2TctiInfo)(allocTss2TctiInfoMemory(1))
}

// allocTss2TctiInfoMemory allocates memory for type C.TSS2_TCTI_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTss2TctiInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTss2TctiInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTss2TctiInfoValue = unsafe.Sizeof([1]C.TSS2_TCTI_INFO{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tss2TctiInfo) PassRef() *C.TSS2_TCTI_INFO {
	if x == nil {
		x = (*Tss2TctiInfo)(allocTss2TctiInfoMemory(1))
	}
	return (*C.TSS2_TCTI_INFO)(unsafe.Pointer(x))
}

// copyPTss2TctiInfoBytes copies the data from Go slice as *C.TSS2_TCTI_INFO.
func copyPTss2TctiInfoBytes(slice *sliceHeader) (*C.TSS2_TCTI_INFO, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTss2TctiInfoValue) * slice.Len,
		Cap:  int(sizeOfTss2TctiInfoValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TSS2_TCTI_INFO)(mem0), allocs
}

func (x Tss2TctiInfoFunc) PassRef() (ref *C.TSS2_TCTI_INFO_FUNC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiInfoFunc3AB67CD0Func == nil {
		tss2TctiInfoFunc3AB67CD0Func = x
	}
	return (*C.TSS2_TCTI_INFO_FUNC)(C.TSS2_TCTI_INFO_FUNC_3ab67cd0), nil
}

func (x Tss2TctiInfoFunc) PassValue() (ref C.TSS2_TCTI_INFO_FUNC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiInfoFunc3AB67CD0Func == nil {
		tss2TctiInfoFunc3AB67CD0Func = x
	}
	return (C.TSS2_TCTI_INFO_FUNC)(C.TSS2_TCTI_INFO_FUNC_3ab67cd0), nil
}

func NewTss2TctiInfoFuncRef(ref unsafe.Pointer) *Tss2TctiInfoFunc {
	return (*Tss2TctiInfoFunc)(ref)
}

//export tss2TctiInfoFunc3AB67CD0
func tss2TctiInfoFunc3AB67CD0() *C.TSS2_TCTI_INFO {
	if tss2TctiInfoFunc3AB67CD0Func != nil {
		ret3ab67cd0 := tss2TctiInfoFunc3AB67CD0Func()
		ret, _ := copyPTss2TctiInfoBytes((*sliceHeader)(unsafe.Pointer(&ret3ab67cd0)))
		return ret
	}
	panic("callback func has not been set (race?)")
}

var tss2TctiInfoFunc3AB67CD0Func Tss2TctiInfoFunc

// Ref returns a reference to C object as it is.
func (x *TpmsEmpty) Ref() *C.TPMS_EMPTY {
	if x == nil {
		return nil
	}
	return (*C.TPMS_EMPTY)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsEmpty) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsEmptyRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsEmptyRef(ref unsafe.Pointer) *TpmsEmpty {
	return (*TpmsEmpty)(ref)
}

// NewTpmsEmpty allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsEmpty() *TpmsEmpty {
	return (*TpmsEmpty)(allocTpmsEmptyMemory(1))
}

// allocTpmsEmptyMemory allocates memory for type C.TPMS_EMPTY in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsEmptyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsEmptyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsEmptyValue = unsafe.Sizeof([1]C.TPMS_EMPTY{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsEmpty) PassRef() *C.TPMS_EMPTY {
	if x == nil {
		x = (*TpmsEmpty)(allocTpmsEmptyMemory(1))
	}
	return (*C.TPMS_EMPTY)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsAlgorithmDescription) Ref() *C.TPMS_ALGORITHM_DESCRIPTION {
	if x == nil {
		return nil
	}
	return (*C.TPMS_ALGORITHM_DESCRIPTION)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsAlgorithmDescription) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsAlgorithmDescriptionRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsAlgorithmDescriptionRef(ref unsafe.Pointer) *TpmsAlgorithmDescription {
	return (*TpmsAlgorithmDescription)(ref)
}

// NewTpmsAlgorithmDescription allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsAlgorithmDescription() *TpmsAlgorithmDescription {
	return (*TpmsAlgorithmDescription)(allocTpmsAlgorithmDescriptionMemory(1))
}

// allocTpmsAlgorithmDescriptionMemory allocates memory for type C.TPMS_ALGORITHM_DESCRIPTION in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsAlgorithmDescriptionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsAlgorithmDescriptionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsAlgorithmDescriptionValue = unsafe.Sizeof([1]C.TPMS_ALGORITHM_DESCRIPTION{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsAlgorithmDescription) PassRef() *C.TPMS_ALGORITHM_DESCRIPTION {
	if x == nil {
		x = (*TpmsAlgorithmDescription)(allocTpmsAlgorithmDescriptionMemory(1))
	}
	return (*C.TPMS_ALGORITHM_DESCRIPTION)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmtHa) Ref() *C.TPMT_HA {
	if x == nil {
		return nil
	}
	return (*C.TPMT_HA)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmtHa) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmtHaRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmtHaRef(ref unsafe.Pointer) *TpmtHa {
	return (*TpmtHa)(ref)
}

// NewTpmtHa allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmtHa() *TpmtHa {
	return (*TpmtHa)(allocTpmtHaMemory(1))
}

// allocTpmtHaMemory allocates memory for type C.TPMT_HA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtHaMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtHaValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtHaValue = unsafe.Sizeof([1]C.TPMT_HA{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmtHa) PassRef() *C.TPMT_HA {
	if x == nil {
		x = (*TpmtHa)(allocTpmtHaMemory(1))
	}
	return (*C.TPMT_HA)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bDigest) Ref() *C.TPM2B_DIGEST {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_DIGEST)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bDigest) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bDigestRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bDigestRef(ref unsafe.Pointer) *Tpm2bDigest {
	return (*Tpm2bDigest)(ref)
}

// NewTpm2bDigest allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bDigest() *Tpm2bDigest {
	return (*Tpm2bDigest)(allocTpm2bDigestMemory(1))
}

// allocTpm2bDigestMemory allocates memory for type C.TPM2B_DIGEST in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bDigestMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bDigestValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bDigestValue = unsafe.Sizeof([1]C.TPM2B_DIGEST{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bDigest) PassRef() *C.TPM2B_DIGEST {
	if x == nil {
		x = (*Tpm2bDigest)(allocTpm2bDigestMemory(1))
	}
	return (*C.TPM2B_DIGEST)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bData) Ref() *C.TPM2B_DATA {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_DATA)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bData) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bDataRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bDataRef(ref unsafe.Pointer) *Tpm2bData {
	return (*Tpm2bData)(ref)
}

// NewTpm2bData allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bData() *Tpm2bData {
	return (*Tpm2bData)(allocTpm2bDataMemory(1))
}

// allocTpm2bDataMemory allocates memory for type C.TPM2B_DATA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bDataValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bDataValue = unsafe.Sizeof([1]C.TPM2B_DATA{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bData) PassRef() *C.TPM2B_DATA {
	if x == nil {
		x = (*Tpm2bData)(allocTpm2bDataMemory(1))
	}
	return (*C.TPM2B_DATA)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bNonce) Ref() *C.TPM2B_DIGEST {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_DIGEST)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bNonce) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bNonceRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bNonceRef(ref unsafe.Pointer) *Tpm2bNonce {
	return (*Tpm2bNonce)(ref)
}

// NewTpm2bNonce allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bNonce() *Tpm2bNonce {
	return (*Tpm2bNonce)(allocTpm2bDigestMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bNonce) PassRef() *C.TPM2B_DIGEST {
	if x == nil {
		x = (*Tpm2bNonce)(allocTpm2bDigestMemory(1))
	}
	return (*C.TPM2B_DIGEST)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bAuth) Ref() *C.TPM2B_DIGEST {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_DIGEST)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bAuth) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bAuthRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bAuthRef(ref unsafe.Pointer) *Tpm2bAuth {
	return (*Tpm2bAuth)(ref)
}

// NewTpm2bAuth allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bAuth() *Tpm2bAuth {
	return (*Tpm2bAuth)(allocTpm2bDigestMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bAuth) PassRef() *C.TPM2B_DIGEST {
	if x == nil {
		x = (*Tpm2bAuth)(allocTpm2bDigestMemory(1))
	}
	return (*C.TPM2B_DIGEST)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bOperand) Ref() *C.TPM2B_DIGEST {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_DIGEST)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bOperand) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bOperandRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bOperandRef(ref unsafe.Pointer) *Tpm2bOperand {
	return (*Tpm2bOperand)(ref)
}

// NewTpm2bOperand allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bOperand() *Tpm2bOperand {
	return (*Tpm2bOperand)(allocTpm2bDigestMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bOperand) PassRef() *C.TPM2B_DIGEST {
	if x == nil {
		x = (*Tpm2bOperand)(allocTpm2bDigestMemory(1))
	}
	return (*C.TPM2B_DIGEST)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bEvent) Ref() *C.TPM2B_EVENT {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_EVENT)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bEvent) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bEventRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bEventRef(ref unsafe.Pointer) *Tpm2bEvent {
	return (*Tpm2bEvent)(ref)
}

// NewTpm2bEvent allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bEvent() *Tpm2bEvent {
	return (*Tpm2bEvent)(allocTpm2bEventMemory(1))
}

// allocTpm2bEventMemory allocates memory for type C.TPM2B_EVENT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bEventMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bEventValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bEventValue = unsafe.Sizeof([1]C.TPM2B_EVENT{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bEvent) PassRef() *C.TPM2B_EVENT {
	if x == nil {
		x = (*Tpm2bEvent)(allocTpm2bEventMemory(1))
	}
	return (*C.TPM2B_EVENT)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bMaxBuffer) Ref() *C.TPM2B_MAX_BUFFER {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_MAX_BUFFER)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bMaxBuffer) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bMaxBufferRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bMaxBufferRef(ref unsafe.Pointer) *Tpm2bMaxBuffer {
	return (*Tpm2bMaxBuffer)(ref)
}

// NewTpm2bMaxBuffer allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bMaxBuffer() *Tpm2bMaxBuffer {
	return (*Tpm2bMaxBuffer)(allocTpm2bMaxBufferMemory(1))
}

// allocTpm2bMaxBufferMemory allocates memory for type C.TPM2B_MAX_BUFFER in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bMaxBufferMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bMaxBufferValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bMaxBufferValue = unsafe.Sizeof([1]C.TPM2B_MAX_BUFFER{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bMaxBuffer) PassRef() *C.TPM2B_MAX_BUFFER {
	if x == nil {
		x = (*Tpm2bMaxBuffer)(allocTpm2bMaxBufferMemory(1))
	}
	return (*C.TPM2B_MAX_BUFFER)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bMaxNvBuffer) Ref() *C.TPM2B_MAX_NV_BUFFER {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_MAX_NV_BUFFER)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bMaxNvBuffer) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bMaxNvBufferRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bMaxNvBufferRef(ref unsafe.Pointer) *Tpm2bMaxNvBuffer {
	return (*Tpm2bMaxNvBuffer)(ref)
}

// NewTpm2bMaxNvBuffer allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bMaxNvBuffer() *Tpm2bMaxNvBuffer {
	return (*Tpm2bMaxNvBuffer)(allocTpm2bMaxNvBufferMemory(1))
}

// allocTpm2bMaxNvBufferMemory allocates memory for type C.TPM2B_MAX_NV_BUFFER in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bMaxNvBufferMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bMaxNvBufferValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bMaxNvBufferValue = unsafe.Sizeof([1]C.TPM2B_MAX_NV_BUFFER{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bMaxNvBuffer) PassRef() *C.TPM2B_MAX_NV_BUFFER {
	if x == nil {
		x = (*Tpm2bMaxNvBuffer)(allocTpm2bMaxNvBufferMemory(1))
	}
	return (*C.TPM2B_MAX_NV_BUFFER)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bTimeout) Ref() *C.TPM2B_DIGEST {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_DIGEST)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bTimeout) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bTimeoutRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bTimeoutRef(ref unsafe.Pointer) *Tpm2bTimeout {
	return (*Tpm2bTimeout)(ref)
}

// NewTpm2bTimeout allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bTimeout() *Tpm2bTimeout {
	return (*Tpm2bTimeout)(allocTpm2bDigestMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bTimeout) PassRef() *C.TPM2B_DIGEST {
	if x == nil {
		x = (*Tpm2bTimeout)(allocTpm2bDigestMemory(1))
	}
	return (*C.TPM2B_DIGEST)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bIv) Ref() *C.TPM2B_IV {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_IV)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bIv) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bIvRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bIvRef(ref unsafe.Pointer) *Tpm2bIv {
	return (*Tpm2bIv)(ref)
}

// NewTpm2bIv allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bIv() *Tpm2bIv {
	return (*Tpm2bIv)(allocTpm2bIvMemory(1))
}

// allocTpm2bIvMemory allocates memory for type C.TPM2B_IV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bIvMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bIvValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bIvValue = unsafe.Sizeof([1]C.TPM2B_IV{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bIv) PassRef() *C.TPM2B_IV {
	if x == nil {
		x = (*Tpm2bIv)(allocTpm2bIvMemory(1))
	}
	return (*C.TPM2B_IV)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bName) Ref() *C.TPM2B_NAME {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_NAME)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bName) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bNameRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bNameRef(ref unsafe.Pointer) *Tpm2bName {
	return (*Tpm2bName)(ref)
}

// NewTpm2bName allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bName() *Tpm2bName {
	return (*Tpm2bName)(allocTpm2bNameMemory(1))
}

// allocTpm2bNameMemory allocates memory for type C.TPM2B_NAME in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bNameMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bNameValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bNameValue = unsafe.Sizeof([1]C.TPM2B_NAME{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bName) PassRef() *C.TPM2B_NAME {
	if x == nil {
		x = (*Tpm2bName)(allocTpm2bNameMemory(1))
	}
	return (*C.TPM2B_NAME)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsPcrSelect) Ref() *C.TPMS_PCR_SELECT {
	if x == nil {
		return nil
	}
	return (*C.TPMS_PCR_SELECT)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsPcrSelect) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsPcrSelectRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsPcrSelectRef(ref unsafe.Pointer) *TpmsPcrSelect {
	return (*TpmsPcrSelect)(ref)
}

// NewTpmsPcrSelect allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsPcrSelect() *TpmsPcrSelect {
	return (*TpmsPcrSelect)(allocTpmsPcrSelectMemory(1))
}

// allocTpmsPcrSelectMemory allocates memory for type C.TPMS_PCR_SELECT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsPcrSelectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsPcrSelectValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsPcrSelectValue = unsafe.Sizeof([1]C.TPMS_PCR_SELECT{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsPcrSelect) PassRef() *C.TPMS_PCR_SELECT {
	if x == nil {
		x = (*TpmsPcrSelect)(allocTpmsPcrSelectMemory(1))
	}
	return (*C.TPMS_PCR_SELECT)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsPcrSelection) Ref() *C.TPMS_PCR_SELECTION {
	if x == nil {
		return nil
	}
	return (*C.TPMS_PCR_SELECTION)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsPcrSelection) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsPcrSelectionRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsPcrSelectionRef(ref unsafe.Pointer) *TpmsPcrSelection {
	return (*TpmsPcrSelection)(ref)
}

// NewTpmsPcrSelection allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsPcrSelection() *TpmsPcrSelection {
	return (*TpmsPcrSelection)(allocTpmsPcrSelectionMemory(1))
}

// allocTpmsPcrSelectionMemory allocates memory for type C.TPMS_PCR_SELECTION in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsPcrSelectionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsPcrSelectionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsPcrSelectionValue = unsafe.Sizeof([1]C.TPMS_PCR_SELECTION{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsPcrSelection) PassRef() *C.TPMS_PCR_SELECTION {
	if x == nil {
		x = (*TpmsPcrSelection)(allocTpmsPcrSelectionMemory(1))
	}
	return (*C.TPMS_PCR_SELECTION)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmtTkCreation) Ref() *C.TPMT_TK_CREATION {
	if x == nil {
		return nil
	}
	return (*C.TPMT_TK_CREATION)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmtTkCreation) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmtTkCreationRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmtTkCreationRef(ref unsafe.Pointer) *TpmtTkCreation {
	return (*TpmtTkCreation)(ref)
}

// NewTpmtTkCreation allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmtTkCreation() *TpmtTkCreation {
	return (*TpmtTkCreation)(allocTpmtTkCreationMemory(1))
}

// allocTpmtTkCreationMemory allocates memory for type C.TPMT_TK_CREATION in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtTkCreationMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtTkCreationValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtTkCreationValue = unsafe.Sizeof([1]C.TPMT_TK_CREATION{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmtTkCreation) PassRef() *C.TPMT_TK_CREATION {
	if x == nil {
		x = (*TpmtTkCreation)(allocTpmtTkCreationMemory(1))
	}
	return (*C.TPMT_TK_CREATION)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmtTkVerified) Ref() *C.TPMT_TK_VERIFIED {
	if x == nil {
		return nil
	}
	return (*C.TPMT_TK_VERIFIED)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmtTkVerified) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmtTkVerifiedRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmtTkVerifiedRef(ref unsafe.Pointer) *TpmtTkVerified {
	return (*TpmtTkVerified)(ref)
}

// NewTpmtTkVerified allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmtTkVerified() *TpmtTkVerified {
	return (*TpmtTkVerified)(allocTpmtTkVerifiedMemory(1))
}

// allocTpmtTkVerifiedMemory allocates memory for type C.TPMT_TK_VERIFIED in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtTkVerifiedMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtTkVerifiedValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtTkVerifiedValue = unsafe.Sizeof([1]C.TPMT_TK_VERIFIED{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmtTkVerified) PassRef() *C.TPMT_TK_VERIFIED {
	if x == nil {
		x = (*TpmtTkVerified)(allocTpmtTkVerifiedMemory(1))
	}
	return (*C.TPMT_TK_VERIFIED)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmtTkAuth) Ref() *C.TPMT_TK_AUTH {
	if x == nil {
		return nil
	}
	return (*C.TPMT_TK_AUTH)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmtTkAuth) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmtTkAuthRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmtTkAuthRef(ref unsafe.Pointer) *TpmtTkAuth {
	return (*TpmtTkAuth)(ref)
}

// NewTpmtTkAuth allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmtTkAuth() *TpmtTkAuth {
	return (*TpmtTkAuth)(allocTpmtTkAuthMemory(1))
}

// allocTpmtTkAuthMemory allocates memory for type C.TPMT_TK_AUTH in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtTkAuthMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtTkAuthValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtTkAuthValue = unsafe.Sizeof([1]C.TPMT_TK_AUTH{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmtTkAuth) PassRef() *C.TPMT_TK_AUTH {
	if x == nil {
		x = (*TpmtTkAuth)(allocTpmtTkAuthMemory(1))
	}
	return (*C.TPMT_TK_AUTH)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmtTkHashcheck) Ref() *C.TPMT_TK_HASHCHECK {
	if x == nil {
		return nil
	}
	return (*C.TPMT_TK_HASHCHECK)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmtTkHashcheck) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmtTkHashcheckRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmtTkHashcheckRef(ref unsafe.Pointer) *TpmtTkHashcheck {
	return (*TpmtTkHashcheck)(ref)
}

// NewTpmtTkHashcheck allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmtTkHashcheck() *TpmtTkHashcheck {
	return (*TpmtTkHashcheck)(allocTpmtTkHashcheckMemory(1))
}

// allocTpmtTkHashcheckMemory allocates memory for type C.TPMT_TK_HASHCHECK in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtTkHashcheckMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtTkHashcheckValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtTkHashcheckValue = unsafe.Sizeof([1]C.TPMT_TK_HASHCHECK{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmtTkHashcheck) PassRef() *C.TPMT_TK_HASHCHECK {
	if x == nil {
		x = (*TpmtTkHashcheck)(allocTpmtTkHashcheckMemory(1))
	}
	return (*C.TPMT_TK_HASHCHECK)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsAlgProperty) Ref() *C.TPMS_ALG_PROPERTY {
	if x == nil {
		return nil
	}
	return (*C.TPMS_ALG_PROPERTY)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsAlgProperty) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsAlgPropertyRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsAlgPropertyRef(ref unsafe.Pointer) *TpmsAlgProperty {
	return (*TpmsAlgProperty)(ref)
}

// NewTpmsAlgProperty allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsAlgProperty() *TpmsAlgProperty {
	return (*TpmsAlgProperty)(allocTpmsAlgPropertyMemory(1))
}

// allocTpmsAlgPropertyMemory allocates memory for type C.TPMS_ALG_PROPERTY in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsAlgPropertyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsAlgPropertyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsAlgPropertyValue = unsafe.Sizeof([1]C.TPMS_ALG_PROPERTY{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsAlgProperty) PassRef() *C.TPMS_ALG_PROPERTY {
	if x == nil {
		x = (*TpmsAlgProperty)(allocTpmsAlgPropertyMemory(1))
	}
	return (*C.TPMS_ALG_PROPERTY)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsTaggedProperty) Ref() *C.TPMS_TAGGED_PROPERTY {
	if x == nil {
		return nil
	}
	return (*C.TPMS_TAGGED_PROPERTY)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsTaggedProperty) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsTaggedPropertyRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsTaggedPropertyRef(ref unsafe.Pointer) *TpmsTaggedProperty {
	return (*TpmsTaggedProperty)(ref)
}

// NewTpmsTaggedProperty allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsTaggedProperty() *TpmsTaggedProperty {
	return (*TpmsTaggedProperty)(allocTpmsTaggedPropertyMemory(1))
}

// allocTpmsTaggedPropertyMemory allocates memory for type C.TPMS_TAGGED_PROPERTY in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsTaggedPropertyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsTaggedPropertyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsTaggedPropertyValue = unsafe.Sizeof([1]C.TPMS_TAGGED_PROPERTY{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsTaggedProperty) PassRef() *C.TPMS_TAGGED_PROPERTY {
	if x == nil {
		x = (*TpmsTaggedProperty)(allocTpmsTaggedPropertyMemory(1))
	}
	return (*C.TPMS_TAGGED_PROPERTY)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsTaggedPcrSelect) Ref() *C.TPMS_TAGGED_PCR_SELECT {
	if x == nil {
		return nil
	}
	return (*C.TPMS_TAGGED_PCR_SELECT)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsTaggedPcrSelect) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsTaggedPcrSelectRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsTaggedPcrSelectRef(ref unsafe.Pointer) *TpmsTaggedPcrSelect {
	return (*TpmsTaggedPcrSelect)(ref)
}

// NewTpmsTaggedPcrSelect allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsTaggedPcrSelect() *TpmsTaggedPcrSelect {
	return (*TpmsTaggedPcrSelect)(allocTpmsTaggedPcrSelectMemory(1))
}

// allocTpmsTaggedPcrSelectMemory allocates memory for type C.TPMS_TAGGED_PCR_SELECT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsTaggedPcrSelectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsTaggedPcrSelectValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsTaggedPcrSelectValue = unsafe.Sizeof([1]C.TPMS_TAGGED_PCR_SELECT{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsTaggedPcrSelect) PassRef() *C.TPMS_TAGGED_PCR_SELECT {
	if x == nil {
		x = (*TpmsTaggedPcrSelect)(allocTpmsTaggedPcrSelectMemory(1))
	}
	return (*C.TPMS_TAGGED_PCR_SELECT)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsTaggedPolicy) Ref() *C.TPMS_TAGGED_POLICY {
	if x == nil {
		return nil
	}
	return (*C.TPMS_TAGGED_POLICY)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsTaggedPolicy) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsTaggedPolicyRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsTaggedPolicyRef(ref unsafe.Pointer) *TpmsTaggedPolicy {
	return (*TpmsTaggedPolicy)(ref)
}

// NewTpmsTaggedPolicy allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsTaggedPolicy() *TpmsTaggedPolicy {
	return (*TpmsTaggedPolicy)(allocTpmsTaggedPolicyMemory(1))
}

// allocTpmsTaggedPolicyMemory allocates memory for type C.TPMS_TAGGED_POLICY in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsTaggedPolicyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsTaggedPolicyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsTaggedPolicyValue = unsafe.Sizeof([1]C.TPMS_TAGGED_POLICY{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsTaggedPolicy) PassRef() *C.TPMS_TAGGED_POLICY {
	if x == nil {
		x = (*TpmsTaggedPolicy)(allocTpmsTaggedPolicyMemory(1))
	}
	return (*C.TPMS_TAGGED_POLICY)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmlCc) Ref() *C.TPML_CC {
	if x == nil {
		return nil
	}
	return (*C.TPML_CC)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmlCc) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmlCcRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmlCcRef(ref unsafe.Pointer) *TpmlCc {
	return (*TpmlCc)(ref)
}

// NewTpmlCc allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmlCc() *TpmlCc {
	return (*TpmlCc)(allocTpmlCcMemory(1))
}

// allocTpmlCcMemory allocates memory for type C.TPML_CC in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmlCcMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmlCcValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmlCcValue = unsafe.Sizeof([1]C.TPML_CC{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmlCc) PassRef() *C.TPML_CC {
	if x == nil {
		x = (*TpmlCc)(allocTpmlCcMemory(1))
	}
	return (*C.TPML_CC)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmlCca) Ref() *C.TPML_CCA {
	if x == nil {
		return nil
	}
	return (*C.TPML_CCA)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmlCca) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmlCcaRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmlCcaRef(ref unsafe.Pointer) *TpmlCca {
	return (*TpmlCca)(ref)
}

// NewTpmlCca allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmlCca() *TpmlCca {
	return (*TpmlCca)(allocTpmlCcaMemory(1))
}

// allocTpmlCcaMemory allocates memory for type C.TPML_CCA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmlCcaMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmlCcaValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmlCcaValue = unsafe.Sizeof([1]C.TPML_CCA{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmlCca) PassRef() *C.TPML_CCA {
	if x == nil {
		x = (*TpmlCca)(allocTpmlCcaMemory(1))
	}
	return (*C.TPML_CCA)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmlAlg) Ref() *C.TPML_ALG {
	if x == nil {
		return nil
	}
	return (*C.TPML_ALG)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmlAlg) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmlAlgRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmlAlgRef(ref unsafe.Pointer) *TpmlAlg {
	return (*TpmlAlg)(ref)
}

// NewTpmlAlg allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmlAlg() *TpmlAlg {
	return (*TpmlAlg)(allocTpmlAlgMemory(1))
}

// allocTpmlAlgMemory allocates memory for type C.TPML_ALG in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmlAlgMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmlAlgValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmlAlgValue = unsafe.Sizeof([1]C.TPML_ALG{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmlAlg) PassRef() *C.TPML_ALG {
	if x == nil {
		x = (*TpmlAlg)(allocTpmlAlgMemory(1))
	}
	return (*C.TPML_ALG)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmlHandle) Ref() *C.TPML_HANDLE {
	if x == nil {
		return nil
	}
	return (*C.TPML_HANDLE)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmlHandle) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmlHandleRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmlHandleRef(ref unsafe.Pointer) *TpmlHandle {
	return (*TpmlHandle)(ref)
}

// NewTpmlHandle allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmlHandle() *TpmlHandle {
	return (*TpmlHandle)(allocTpmlHandleMemory(1))
}

// allocTpmlHandleMemory allocates memory for type C.TPML_HANDLE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmlHandleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmlHandleValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmlHandleValue = unsafe.Sizeof([1]C.TPML_HANDLE{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmlHandle) PassRef() *C.TPML_HANDLE {
	if x == nil {
		x = (*TpmlHandle)(allocTpmlHandleMemory(1))
	}
	return (*C.TPML_HANDLE)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmlDigest) Ref() *C.TPML_DIGEST {
	if x == nil {
		return nil
	}
	return (*C.TPML_DIGEST)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmlDigest) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmlDigestRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmlDigestRef(ref unsafe.Pointer) *TpmlDigest {
	return (*TpmlDigest)(ref)
}

// NewTpmlDigest allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmlDigest() *TpmlDigest {
	return (*TpmlDigest)(allocTpmlDigestMemory(1))
}

// allocTpmlDigestMemory allocates memory for type C.TPML_DIGEST in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmlDigestMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmlDigestValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmlDigestValue = unsafe.Sizeof([1]C.TPML_DIGEST{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmlDigest) PassRef() *C.TPML_DIGEST {
	if x == nil {
		x = (*TpmlDigest)(allocTpmlDigestMemory(1))
	}
	return (*C.TPML_DIGEST)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmlDigestValues) Ref() *C.TPML_DIGEST_VALUES {
	if x == nil {
		return nil
	}
	return (*C.TPML_DIGEST_VALUES)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmlDigestValues) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmlDigestValuesRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmlDigestValuesRef(ref unsafe.Pointer) *TpmlDigestValues {
	return (*TpmlDigestValues)(ref)
}

// NewTpmlDigestValues allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmlDigestValues() *TpmlDigestValues {
	return (*TpmlDigestValues)(allocTpmlDigestValuesMemory(1))
}

// allocTpmlDigestValuesMemory allocates memory for type C.TPML_DIGEST_VALUES in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmlDigestValuesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmlDigestValuesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmlDigestValuesValue = unsafe.Sizeof([1]C.TPML_DIGEST_VALUES{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmlDigestValues) PassRef() *C.TPML_DIGEST_VALUES {
	if x == nil {
		x = (*TpmlDigestValues)(allocTpmlDigestValuesMemory(1))
	}
	return (*C.TPML_DIGEST_VALUES)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmlPcrSelection) Ref() *C.TPML_PCR_SELECTION {
	if x == nil {
		return nil
	}
	return (*C.TPML_PCR_SELECTION)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmlPcrSelection) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmlPcrSelectionRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmlPcrSelectionRef(ref unsafe.Pointer) *TpmlPcrSelection {
	return (*TpmlPcrSelection)(ref)
}

// NewTpmlPcrSelection allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmlPcrSelection() *TpmlPcrSelection {
	return (*TpmlPcrSelection)(allocTpmlPcrSelectionMemory(1))
}

// allocTpmlPcrSelectionMemory allocates memory for type C.TPML_PCR_SELECTION in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmlPcrSelectionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmlPcrSelectionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmlPcrSelectionValue = unsafe.Sizeof([1]C.TPML_PCR_SELECTION{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmlPcrSelection) PassRef() *C.TPML_PCR_SELECTION {
	if x == nil {
		x = (*TpmlPcrSelection)(allocTpmlPcrSelectionMemory(1))
	}
	return (*C.TPML_PCR_SELECTION)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmlAlgProperty) Ref() *C.TPML_ALG_PROPERTY {
	if x == nil {
		return nil
	}
	return (*C.TPML_ALG_PROPERTY)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmlAlgProperty) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmlAlgPropertyRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmlAlgPropertyRef(ref unsafe.Pointer) *TpmlAlgProperty {
	return (*TpmlAlgProperty)(ref)
}

// NewTpmlAlgProperty allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmlAlgProperty() *TpmlAlgProperty {
	return (*TpmlAlgProperty)(allocTpmlAlgPropertyMemory(1))
}

// allocTpmlAlgPropertyMemory allocates memory for type C.TPML_ALG_PROPERTY in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmlAlgPropertyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmlAlgPropertyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmlAlgPropertyValue = unsafe.Sizeof([1]C.TPML_ALG_PROPERTY{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmlAlgProperty) PassRef() *C.TPML_ALG_PROPERTY {
	if x == nil {
		x = (*TpmlAlgProperty)(allocTpmlAlgPropertyMemory(1))
	}
	return (*C.TPML_ALG_PROPERTY)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmlTaggedTpmProperty) Ref() *C.TPML_TAGGED_TPM_PROPERTY {
	if x == nil {
		return nil
	}
	return (*C.TPML_TAGGED_TPM_PROPERTY)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmlTaggedTpmProperty) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmlTaggedTpmPropertyRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmlTaggedTpmPropertyRef(ref unsafe.Pointer) *TpmlTaggedTpmProperty {
	return (*TpmlTaggedTpmProperty)(ref)
}

// NewTpmlTaggedTpmProperty allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmlTaggedTpmProperty() *TpmlTaggedTpmProperty {
	return (*TpmlTaggedTpmProperty)(allocTpmlTaggedTpmPropertyMemory(1))
}

// allocTpmlTaggedTpmPropertyMemory allocates memory for type C.TPML_TAGGED_TPM_PROPERTY in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmlTaggedTpmPropertyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmlTaggedTpmPropertyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmlTaggedTpmPropertyValue = unsafe.Sizeof([1]C.TPML_TAGGED_TPM_PROPERTY{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmlTaggedTpmProperty) PassRef() *C.TPML_TAGGED_TPM_PROPERTY {
	if x == nil {
		x = (*TpmlTaggedTpmProperty)(allocTpmlTaggedTpmPropertyMemory(1))
	}
	return (*C.TPML_TAGGED_TPM_PROPERTY)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmlTaggedPcrProperty) Ref() *C.TPML_TAGGED_PCR_PROPERTY {
	if x == nil {
		return nil
	}
	return (*C.TPML_TAGGED_PCR_PROPERTY)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmlTaggedPcrProperty) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmlTaggedPcrPropertyRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmlTaggedPcrPropertyRef(ref unsafe.Pointer) *TpmlTaggedPcrProperty {
	return (*TpmlTaggedPcrProperty)(ref)
}

// NewTpmlTaggedPcrProperty allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmlTaggedPcrProperty() *TpmlTaggedPcrProperty {
	return (*TpmlTaggedPcrProperty)(allocTpmlTaggedPcrPropertyMemory(1))
}

// allocTpmlTaggedPcrPropertyMemory allocates memory for type C.TPML_TAGGED_PCR_PROPERTY in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmlTaggedPcrPropertyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmlTaggedPcrPropertyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmlTaggedPcrPropertyValue = unsafe.Sizeof([1]C.TPML_TAGGED_PCR_PROPERTY{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmlTaggedPcrProperty) PassRef() *C.TPML_TAGGED_PCR_PROPERTY {
	if x == nil {
		x = (*TpmlTaggedPcrProperty)(allocTpmlTaggedPcrPropertyMemory(1))
	}
	return (*C.TPML_TAGGED_PCR_PROPERTY)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmlEccCurve) Ref() *C.TPML_ECC_CURVE {
	if x == nil {
		return nil
	}
	return (*C.TPML_ECC_CURVE)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmlEccCurve) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmlEccCurveRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmlEccCurveRef(ref unsafe.Pointer) *TpmlEccCurve {
	return (*TpmlEccCurve)(ref)
}

// NewTpmlEccCurve allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmlEccCurve() *TpmlEccCurve {
	return (*TpmlEccCurve)(allocTpmlEccCurveMemory(1))
}

// allocTpmlEccCurveMemory allocates memory for type C.TPML_ECC_CURVE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmlEccCurveMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmlEccCurveValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmlEccCurveValue = unsafe.Sizeof([1]C.TPML_ECC_CURVE{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmlEccCurve) PassRef() *C.TPML_ECC_CURVE {
	if x == nil {
		x = (*TpmlEccCurve)(allocTpmlEccCurveMemory(1))
	}
	return (*C.TPML_ECC_CURVE)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmlIntelPttProperty) Ref() *C.TPML_INTEL_PTT_PROPERTY {
	if x == nil {
		return nil
	}
	return (*C.TPML_INTEL_PTT_PROPERTY)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmlIntelPttProperty) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmlIntelPttPropertyRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmlIntelPttPropertyRef(ref unsafe.Pointer) *TpmlIntelPttProperty {
	return (*TpmlIntelPttProperty)(ref)
}

// NewTpmlIntelPttProperty allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmlIntelPttProperty() *TpmlIntelPttProperty {
	return (*TpmlIntelPttProperty)(allocTpmlIntelPttPropertyMemory(1))
}

// allocTpmlIntelPttPropertyMemory allocates memory for type C.TPML_INTEL_PTT_PROPERTY in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmlIntelPttPropertyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmlIntelPttPropertyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmlIntelPttPropertyValue = unsafe.Sizeof([1]C.TPML_INTEL_PTT_PROPERTY{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmlIntelPttProperty) PassRef() *C.TPML_INTEL_PTT_PROPERTY {
	if x == nil {
		x = (*TpmlIntelPttProperty)(allocTpmlIntelPttPropertyMemory(1))
	}
	return (*C.TPML_INTEL_PTT_PROPERTY)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsCapabilityData) Ref() *C.TPMS_CAPABILITY_DATA {
	if x == nil {
		return nil
	}
	return (*C.TPMS_CAPABILITY_DATA)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsCapabilityData) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsCapabilityDataRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsCapabilityDataRef(ref unsafe.Pointer) *TpmsCapabilityData {
	return (*TpmsCapabilityData)(ref)
}

// NewTpmsCapabilityData allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsCapabilityData() *TpmsCapabilityData {
	return (*TpmsCapabilityData)(allocTpmsCapabilityDataMemory(1))
}

// allocTpmsCapabilityDataMemory allocates memory for type C.TPMS_CAPABILITY_DATA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsCapabilityDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsCapabilityDataValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsCapabilityDataValue = unsafe.Sizeof([1]C.TPMS_CAPABILITY_DATA{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsCapabilityData) PassRef() *C.TPMS_CAPABILITY_DATA {
	if x == nil {
		x = (*TpmsCapabilityData)(allocTpmsCapabilityDataMemory(1))
	}
	return (*C.TPMS_CAPABILITY_DATA)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsClockInfo) Ref() *C.TPMS_CLOCK_INFO {
	if x == nil {
		return nil
	}
	return (*C.TPMS_CLOCK_INFO)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsClockInfo) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsClockInfoRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsClockInfoRef(ref unsafe.Pointer) *TpmsClockInfo {
	return (*TpmsClockInfo)(ref)
}

// NewTpmsClockInfo allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsClockInfo() *TpmsClockInfo {
	return (*TpmsClockInfo)(allocTpmsClockInfoMemory(1))
}

// allocTpmsClockInfoMemory allocates memory for type C.TPMS_CLOCK_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsClockInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsClockInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsClockInfoValue = unsafe.Sizeof([1]C.TPMS_CLOCK_INFO{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsClockInfo) PassRef() *C.TPMS_CLOCK_INFO {
	if x == nil {
		x = (*TpmsClockInfo)(allocTpmsClockInfoMemory(1))
	}
	return (*C.TPMS_CLOCK_INFO)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsTimeInfo) Ref() *C.TPMS_TIME_INFO {
	if x == nil {
		return nil
	}
	return (*C.TPMS_TIME_INFO)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsTimeInfo) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsTimeInfoRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsTimeInfoRef(ref unsafe.Pointer) *TpmsTimeInfo {
	return (*TpmsTimeInfo)(ref)
}

// NewTpmsTimeInfo allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsTimeInfo() *TpmsTimeInfo {
	return (*TpmsTimeInfo)(allocTpmsTimeInfoMemory(1))
}

// allocTpmsTimeInfoMemory allocates memory for type C.TPMS_TIME_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsTimeInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsTimeInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsTimeInfoValue = unsafe.Sizeof([1]C.TPMS_TIME_INFO{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsTimeInfo) PassRef() *C.TPMS_TIME_INFO {
	if x == nil {
		x = (*TpmsTimeInfo)(allocTpmsTimeInfoMemory(1))
	}
	return (*C.TPMS_TIME_INFO)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsTimeAttestInfo) Ref() *C.TPMS_TIME_ATTEST_INFO {
	if x == nil {
		return nil
	}
	return (*C.TPMS_TIME_ATTEST_INFO)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsTimeAttestInfo) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsTimeAttestInfoRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsTimeAttestInfoRef(ref unsafe.Pointer) *TpmsTimeAttestInfo {
	return (*TpmsTimeAttestInfo)(ref)
}

// NewTpmsTimeAttestInfo allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsTimeAttestInfo() *TpmsTimeAttestInfo {
	return (*TpmsTimeAttestInfo)(allocTpmsTimeAttestInfoMemory(1))
}

// allocTpmsTimeAttestInfoMemory allocates memory for type C.TPMS_TIME_ATTEST_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsTimeAttestInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsTimeAttestInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsTimeAttestInfoValue = unsafe.Sizeof([1]C.TPMS_TIME_ATTEST_INFO{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsTimeAttestInfo) PassRef() *C.TPMS_TIME_ATTEST_INFO {
	if x == nil {
		x = (*TpmsTimeAttestInfo)(allocTpmsTimeAttestInfoMemory(1))
	}
	return (*C.TPMS_TIME_ATTEST_INFO)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsCertifyInfo) Ref() *C.TPMS_CERTIFY_INFO {
	if x == nil {
		return nil
	}
	return (*C.TPMS_CERTIFY_INFO)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsCertifyInfo) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsCertifyInfoRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsCertifyInfoRef(ref unsafe.Pointer) *TpmsCertifyInfo {
	return (*TpmsCertifyInfo)(ref)
}

// NewTpmsCertifyInfo allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsCertifyInfo() *TpmsCertifyInfo {
	return (*TpmsCertifyInfo)(allocTpmsCertifyInfoMemory(1))
}

// allocTpmsCertifyInfoMemory allocates memory for type C.TPMS_CERTIFY_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsCertifyInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsCertifyInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsCertifyInfoValue = unsafe.Sizeof([1]C.TPMS_CERTIFY_INFO{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsCertifyInfo) PassRef() *C.TPMS_CERTIFY_INFO {
	if x == nil {
		x = (*TpmsCertifyInfo)(allocTpmsCertifyInfoMemory(1))
	}
	return (*C.TPMS_CERTIFY_INFO)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsQuoteInfo) Ref() *C.TPMS_QUOTE_INFO {
	if x == nil {
		return nil
	}
	return (*C.TPMS_QUOTE_INFO)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsQuoteInfo) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsQuoteInfoRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsQuoteInfoRef(ref unsafe.Pointer) *TpmsQuoteInfo {
	return (*TpmsQuoteInfo)(ref)
}

// NewTpmsQuoteInfo allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsQuoteInfo() *TpmsQuoteInfo {
	return (*TpmsQuoteInfo)(allocTpmsQuoteInfoMemory(1))
}

// allocTpmsQuoteInfoMemory allocates memory for type C.TPMS_QUOTE_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsQuoteInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsQuoteInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsQuoteInfoValue = unsafe.Sizeof([1]C.TPMS_QUOTE_INFO{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsQuoteInfo) PassRef() *C.TPMS_QUOTE_INFO {
	if x == nil {
		x = (*TpmsQuoteInfo)(allocTpmsQuoteInfoMemory(1))
	}
	return (*C.TPMS_QUOTE_INFO)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsCommandAuditInfo) Ref() *C.TPMS_COMMAND_AUDIT_INFO {
	if x == nil {
		return nil
	}
	return (*C.TPMS_COMMAND_AUDIT_INFO)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsCommandAuditInfo) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsCommandAuditInfoRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsCommandAuditInfoRef(ref unsafe.Pointer) *TpmsCommandAuditInfo {
	return (*TpmsCommandAuditInfo)(ref)
}

// NewTpmsCommandAuditInfo allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsCommandAuditInfo() *TpmsCommandAuditInfo {
	return (*TpmsCommandAuditInfo)(allocTpmsCommandAuditInfoMemory(1))
}

// allocTpmsCommandAuditInfoMemory allocates memory for type C.TPMS_COMMAND_AUDIT_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsCommandAuditInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsCommandAuditInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsCommandAuditInfoValue = unsafe.Sizeof([1]C.TPMS_COMMAND_AUDIT_INFO{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsCommandAuditInfo) PassRef() *C.TPMS_COMMAND_AUDIT_INFO {
	if x == nil {
		x = (*TpmsCommandAuditInfo)(allocTpmsCommandAuditInfoMemory(1))
	}
	return (*C.TPMS_COMMAND_AUDIT_INFO)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSessionAuditInfo) Ref() *C.TPMS_SESSION_AUDIT_INFO {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SESSION_AUDIT_INFO)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSessionAuditInfo) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSessionAuditInfoRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSessionAuditInfoRef(ref unsafe.Pointer) *TpmsSessionAuditInfo {
	return (*TpmsSessionAuditInfo)(ref)
}

// NewTpmsSessionAuditInfo allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSessionAuditInfo() *TpmsSessionAuditInfo {
	return (*TpmsSessionAuditInfo)(allocTpmsSessionAuditInfoMemory(1))
}

// allocTpmsSessionAuditInfoMemory allocates memory for type C.TPMS_SESSION_AUDIT_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsSessionAuditInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsSessionAuditInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsSessionAuditInfoValue = unsafe.Sizeof([1]C.TPMS_SESSION_AUDIT_INFO{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSessionAuditInfo) PassRef() *C.TPMS_SESSION_AUDIT_INFO {
	if x == nil {
		x = (*TpmsSessionAuditInfo)(allocTpmsSessionAuditInfoMemory(1))
	}
	return (*C.TPMS_SESSION_AUDIT_INFO)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsCreationInfo) Ref() *C.TPMS_CREATION_INFO {
	if x == nil {
		return nil
	}
	return (*C.TPMS_CREATION_INFO)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsCreationInfo) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsCreationInfoRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsCreationInfoRef(ref unsafe.Pointer) *TpmsCreationInfo {
	return (*TpmsCreationInfo)(ref)
}

// NewTpmsCreationInfo allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsCreationInfo() *TpmsCreationInfo {
	return (*TpmsCreationInfo)(allocTpmsCreationInfoMemory(1))
}

// allocTpmsCreationInfoMemory allocates memory for type C.TPMS_CREATION_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsCreationInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsCreationInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsCreationInfoValue = unsafe.Sizeof([1]C.TPMS_CREATION_INFO{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsCreationInfo) PassRef() *C.TPMS_CREATION_INFO {
	if x == nil {
		x = (*TpmsCreationInfo)(allocTpmsCreationInfoMemory(1))
	}
	return (*C.TPMS_CREATION_INFO)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsNvCertifyInfo) Ref() *C.TPMS_NV_CERTIFY_INFO {
	if x == nil {
		return nil
	}
	return (*C.TPMS_NV_CERTIFY_INFO)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsNvCertifyInfo) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsNvCertifyInfoRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsNvCertifyInfoRef(ref unsafe.Pointer) *TpmsNvCertifyInfo {
	return (*TpmsNvCertifyInfo)(ref)
}

// NewTpmsNvCertifyInfo allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsNvCertifyInfo() *TpmsNvCertifyInfo {
	return (*TpmsNvCertifyInfo)(allocTpmsNvCertifyInfoMemory(1))
}

// allocTpmsNvCertifyInfoMemory allocates memory for type C.TPMS_NV_CERTIFY_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsNvCertifyInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsNvCertifyInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsNvCertifyInfoValue = unsafe.Sizeof([1]C.TPMS_NV_CERTIFY_INFO{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsNvCertifyInfo) PassRef() *C.TPMS_NV_CERTIFY_INFO {
	if x == nil {
		x = (*TpmsNvCertifyInfo)(allocTpmsNvCertifyInfoMemory(1))
	}
	return (*C.TPMS_NV_CERTIFY_INFO)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsAttest) Ref() *C.TPMS_ATTEST {
	if x == nil {
		return nil
	}
	return (*C.TPMS_ATTEST)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsAttest) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsAttestRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsAttestRef(ref unsafe.Pointer) *TpmsAttest {
	return (*TpmsAttest)(ref)
}

// NewTpmsAttest allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsAttest() *TpmsAttest {
	return (*TpmsAttest)(allocTpmsAttestMemory(1))
}

// allocTpmsAttestMemory allocates memory for type C.TPMS_ATTEST in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsAttestMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsAttestValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsAttestValue = unsafe.Sizeof([1]C.TPMS_ATTEST{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsAttest) PassRef() *C.TPMS_ATTEST {
	if x == nil {
		x = (*TpmsAttest)(allocTpmsAttestMemory(1))
	}
	return (*C.TPMS_ATTEST)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bAttest) Ref() *C.TPM2B_ATTEST {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_ATTEST)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bAttest) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bAttestRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bAttestRef(ref unsafe.Pointer) *Tpm2bAttest {
	return (*Tpm2bAttest)(ref)
}

// NewTpm2bAttest allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bAttest() *Tpm2bAttest {
	return (*Tpm2bAttest)(allocTpm2bAttestMemory(1))
}

// allocTpm2bAttestMemory allocates memory for type C.TPM2B_ATTEST in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bAttestMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bAttestValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bAttestValue = unsafe.Sizeof([1]C.TPM2B_ATTEST{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bAttest) PassRef() *C.TPM2B_ATTEST {
	if x == nil {
		x = (*Tpm2bAttest)(allocTpm2bAttestMemory(1))
	}
	return (*C.TPM2B_ATTEST)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsAuthCommand) Ref() *C.TPMS_AUTH_COMMAND {
	if x == nil {
		return nil
	}
	return (*C.TPMS_AUTH_COMMAND)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsAuthCommand) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsAuthCommandRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsAuthCommandRef(ref unsafe.Pointer) *TpmsAuthCommand {
	return (*TpmsAuthCommand)(ref)
}

// NewTpmsAuthCommand allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsAuthCommand() *TpmsAuthCommand {
	return (*TpmsAuthCommand)(allocTpmsAuthCommandMemory(1))
}

// allocTpmsAuthCommandMemory allocates memory for type C.TPMS_AUTH_COMMAND in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsAuthCommandMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsAuthCommandValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsAuthCommandValue = unsafe.Sizeof([1]C.TPMS_AUTH_COMMAND{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsAuthCommand) PassRef() *C.TPMS_AUTH_COMMAND {
	if x == nil {
		x = (*TpmsAuthCommand)(allocTpmsAuthCommandMemory(1))
	}
	return (*C.TPMS_AUTH_COMMAND)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsAuthResponse) Ref() *C.TPMS_AUTH_RESPONSE {
	if x == nil {
		return nil
	}
	return (*C.TPMS_AUTH_RESPONSE)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsAuthResponse) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsAuthResponseRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsAuthResponseRef(ref unsafe.Pointer) *TpmsAuthResponse {
	return (*TpmsAuthResponse)(ref)
}

// NewTpmsAuthResponse allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsAuthResponse() *TpmsAuthResponse {
	return (*TpmsAuthResponse)(allocTpmsAuthResponseMemory(1))
}

// allocTpmsAuthResponseMemory allocates memory for type C.TPMS_AUTH_RESPONSE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsAuthResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsAuthResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsAuthResponseValue = unsafe.Sizeof([1]C.TPMS_AUTH_RESPONSE{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsAuthResponse) PassRef() *C.TPMS_AUTH_RESPONSE {
	if x == nil {
		x = (*TpmsAuthResponse)(allocTpmsAuthResponseMemory(1))
	}
	return (*C.TPMS_AUTH_RESPONSE)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmtSymDef) Ref() *C.TPMT_SYM_DEF {
	if x == nil {
		return nil
	}
	return (*C.TPMT_SYM_DEF)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmtSymDef) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmtSymDefRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmtSymDefRef(ref unsafe.Pointer) *TpmtSymDef {
	return (*TpmtSymDef)(ref)
}

// NewTpmtSymDef allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmtSymDef() *TpmtSymDef {
	return (*TpmtSymDef)(allocTpmtSymDefMemory(1))
}

// allocTpmtSymDefMemory allocates memory for type C.TPMT_SYM_DEF in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtSymDefMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtSymDefValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtSymDefValue = unsafe.Sizeof([1]C.TPMT_SYM_DEF{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmtSymDef) PassRef() *C.TPMT_SYM_DEF {
	if x == nil {
		x = (*TpmtSymDef)(allocTpmtSymDefMemory(1))
	}
	return (*C.TPMT_SYM_DEF)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmtSymDefObject) Ref() *C.TPMT_SYM_DEF_OBJECT {
	if x == nil {
		return nil
	}
	return (*C.TPMT_SYM_DEF_OBJECT)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmtSymDefObject) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmtSymDefObjectRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmtSymDefObjectRef(ref unsafe.Pointer) *TpmtSymDefObject {
	return (*TpmtSymDefObject)(ref)
}

// NewTpmtSymDefObject allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmtSymDefObject() *TpmtSymDefObject {
	return (*TpmtSymDefObject)(allocTpmtSymDefObjectMemory(1))
}

// allocTpmtSymDefObjectMemory allocates memory for type C.TPMT_SYM_DEF_OBJECT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtSymDefObjectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtSymDefObjectValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtSymDefObjectValue = unsafe.Sizeof([1]C.TPMT_SYM_DEF_OBJECT{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmtSymDefObject) PassRef() *C.TPMT_SYM_DEF_OBJECT {
	if x == nil {
		x = (*TpmtSymDefObject)(allocTpmtSymDefObjectMemory(1))
	}
	return (*C.TPMT_SYM_DEF_OBJECT)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bSymKey) Ref() *C.TPM2B_SYM_KEY {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_SYM_KEY)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bSymKey) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bSymKeyRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bSymKeyRef(ref unsafe.Pointer) *Tpm2bSymKey {
	return (*Tpm2bSymKey)(ref)
}

// NewTpm2bSymKey allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bSymKey() *Tpm2bSymKey {
	return (*Tpm2bSymKey)(allocTpm2bSymKeyMemory(1))
}

// allocTpm2bSymKeyMemory allocates memory for type C.TPM2B_SYM_KEY in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bSymKeyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bSymKeyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bSymKeyValue = unsafe.Sizeof([1]C.TPM2B_SYM_KEY{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bSymKey) PassRef() *C.TPM2B_SYM_KEY {
	if x == nil {
		x = (*Tpm2bSymKey)(allocTpm2bSymKeyMemory(1))
	}
	return (*C.TPM2B_SYM_KEY)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSymcipherParms) Ref() *C.TPMS_SYMCIPHER_PARMS {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SYMCIPHER_PARMS)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSymcipherParms) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSymcipherParmsRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSymcipherParmsRef(ref unsafe.Pointer) *TpmsSymcipherParms {
	return (*TpmsSymcipherParms)(ref)
}

// NewTpmsSymcipherParms allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSymcipherParms() *TpmsSymcipherParms {
	return (*TpmsSymcipherParms)(allocTpmsSymcipherParmsMemory(1))
}

// allocTpmsSymcipherParmsMemory allocates memory for type C.TPMS_SYMCIPHER_PARMS in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsSymcipherParmsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsSymcipherParmsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsSymcipherParmsValue = unsafe.Sizeof([1]C.TPMS_SYMCIPHER_PARMS{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSymcipherParms) PassRef() *C.TPMS_SYMCIPHER_PARMS {
	if x == nil {
		x = (*TpmsSymcipherParms)(allocTpmsSymcipherParmsMemory(1))
	}
	return (*C.TPMS_SYMCIPHER_PARMS)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bSensitiveData) Ref() *C.TPM2B_SENSITIVE_DATA {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_SENSITIVE_DATA)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bSensitiveData) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bSensitiveDataRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bSensitiveDataRef(ref unsafe.Pointer) *Tpm2bSensitiveData {
	return (*Tpm2bSensitiveData)(ref)
}

// NewTpm2bSensitiveData allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bSensitiveData() *Tpm2bSensitiveData {
	return (*Tpm2bSensitiveData)(allocTpm2bSensitiveDataMemory(1))
}

// allocTpm2bSensitiveDataMemory allocates memory for type C.TPM2B_SENSITIVE_DATA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bSensitiveDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bSensitiveDataValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bSensitiveDataValue = unsafe.Sizeof([1]C.TPM2B_SENSITIVE_DATA{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bSensitiveData) PassRef() *C.TPM2B_SENSITIVE_DATA {
	if x == nil {
		x = (*Tpm2bSensitiveData)(allocTpm2bSensitiveDataMemory(1))
	}
	return (*C.TPM2B_SENSITIVE_DATA)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSensitiveCreate) Ref() *C.TPMS_SENSITIVE_CREATE {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SENSITIVE_CREATE)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSensitiveCreate) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSensitiveCreateRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSensitiveCreateRef(ref unsafe.Pointer) *TpmsSensitiveCreate {
	return (*TpmsSensitiveCreate)(ref)
}

// NewTpmsSensitiveCreate allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSensitiveCreate() *TpmsSensitiveCreate {
	return (*TpmsSensitiveCreate)(allocTpmsSensitiveCreateMemory(1))
}

// allocTpmsSensitiveCreateMemory allocates memory for type C.TPMS_SENSITIVE_CREATE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsSensitiveCreateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsSensitiveCreateValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsSensitiveCreateValue = unsafe.Sizeof([1]C.TPMS_SENSITIVE_CREATE{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSensitiveCreate) PassRef() *C.TPMS_SENSITIVE_CREATE {
	if x == nil {
		x = (*TpmsSensitiveCreate)(allocTpmsSensitiveCreateMemory(1))
	}
	return (*C.TPMS_SENSITIVE_CREATE)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bSensitiveCreate) Ref() *C.TPM2B_SENSITIVE_CREATE {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_SENSITIVE_CREATE)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bSensitiveCreate) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bSensitiveCreateRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bSensitiveCreateRef(ref unsafe.Pointer) *Tpm2bSensitiveCreate {
	return (*Tpm2bSensitiveCreate)(ref)
}

// NewTpm2bSensitiveCreate allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bSensitiveCreate() *Tpm2bSensitiveCreate {
	return (*Tpm2bSensitiveCreate)(allocTpm2bSensitiveCreateMemory(1))
}

// allocTpm2bSensitiveCreateMemory allocates memory for type C.TPM2B_SENSITIVE_CREATE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bSensitiveCreateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bSensitiveCreateValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bSensitiveCreateValue = unsafe.Sizeof([1]C.TPM2B_SENSITIVE_CREATE{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bSensitiveCreate) PassRef() *C.TPM2B_SENSITIVE_CREATE {
	if x == nil {
		x = (*Tpm2bSensitiveCreate)(allocTpm2bSensitiveCreateMemory(1))
	}
	return (*C.TPM2B_SENSITIVE_CREATE)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSchemeHash) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSchemeHash) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSchemeHashRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSchemeHashRef(ref unsafe.Pointer) *TpmsSchemeHash {
	return (*TpmsSchemeHash)(ref)
}

// NewTpmsSchemeHash allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSchemeHash() *TpmsSchemeHash {
	return (*TpmsSchemeHash)(allocTpmsSchemeHashMemory(1))
}

// allocTpmsSchemeHashMemory allocates memory for type C.TPMS_SCHEME_HASH in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsSchemeHashMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsSchemeHashValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsSchemeHashValue = unsafe.Sizeof([1]C.TPMS_SCHEME_HASH{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSchemeHash) PassRef() *C.TPMS_SCHEME_HASH {
	if x == nil {
		x = (*TpmsSchemeHash)(allocTpmsSchemeHashMemory(1))
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSchemeEcdaa) Ref() *C.TPMS_SCHEME_ECDAA {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SCHEME_ECDAA)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSchemeEcdaa) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSchemeEcdaaRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSchemeEcdaaRef(ref unsafe.Pointer) *TpmsSchemeEcdaa {
	return (*TpmsSchemeEcdaa)(ref)
}

// NewTpmsSchemeEcdaa allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSchemeEcdaa() *TpmsSchemeEcdaa {
	return (*TpmsSchemeEcdaa)(allocTpmsSchemeEcdaaMemory(1))
}

// allocTpmsSchemeEcdaaMemory allocates memory for type C.TPMS_SCHEME_ECDAA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsSchemeEcdaaMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsSchemeEcdaaValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsSchemeEcdaaValue = unsafe.Sizeof([1]C.TPMS_SCHEME_ECDAA{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSchemeEcdaa) PassRef() *C.TPMS_SCHEME_ECDAA {
	if x == nil {
		x = (*TpmsSchemeEcdaa)(allocTpmsSchemeEcdaaMemory(1))
	}
	return (*C.TPMS_SCHEME_ECDAA)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSchemeHmac) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSchemeHmac) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSchemeHmacRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSchemeHmacRef(ref unsafe.Pointer) *TpmsSchemeHmac {
	return (*TpmsSchemeHmac)(ref)
}

// NewTpmsSchemeHmac allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSchemeHmac() *TpmsSchemeHmac {
	return (*TpmsSchemeHmac)(allocTpmsSchemeHashMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSchemeHmac) PassRef() *C.TPMS_SCHEME_HASH {
	if x == nil {
		x = (*TpmsSchemeHmac)(allocTpmsSchemeHashMemory(1))
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSchemeXor) Ref() *C.TPMS_SCHEME_XOR {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SCHEME_XOR)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSchemeXor) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSchemeXorRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSchemeXorRef(ref unsafe.Pointer) *TpmsSchemeXor {
	return (*TpmsSchemeXor)(ref)
}

// NewTpmsSchemeXor allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSchemeXor() *TpmsSchemeXor {
	return (*TpmsSchemeXor)(allocTpmsSchemeXorMemory(1))
}

// allocTpmsSchemeXorMemory allocates memory for type C.TPMS_SCHEME_XOR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsSchemeXorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsSchemeXorValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsSchemeXorValue = unsafe.Sizeof([1]C.TPMS_SCHEME_XOR{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSchemeXor) PassRef() *C.TPMS_SCHEME_XOR {
	if x == nil {
		x = (*TpmsSchemeXor)(allocTpmsSchemeXorMemory(1))
	}
	return (*C.TPMS_SCHEME_XOR)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmtKeyedhashScheme) Ref() *C.TPMT_KEYEDHASH_SCHEME {
	if x == nil {
		return nil
	}
	return (*C.TPMT_KEYEDHASH_SCHEME)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmtKeyedhashScheme) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmtKeyedhashSchemeRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmtKeyedhashSchemeRef(ref unsafe.Pointer) *TpmtKeyedhashScheme {
	return (*TpmtKeyedhashScheme)(ref)
}

// NewTpmtKeyedhashScheme allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmtKeyedhashScheme() *TpmtKeyedhashScheme {
	return (*TpmtKeyedhashScheme)(allocTpmtKeyedhashSchemeMemory(1))
}

// allocTpmtKeyedhashSchemeMemory allocates memory for type C.TPMT_KEYEDHASH_SCHEME in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtKeyedhashSchemeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtKeyedhashSchemeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtKeyedhashSchemeValue = unsafe.Sizeof([1]C.TPMT_KEYEDHASH_SCHEME{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmtKeyedhashScheme) PassRef() *C.TPMT_KEYEDHASH_SCHEME {
	if x == nil {
		x = (*TpmtKeyedhashScheme)(allocTpmtKeyedhashSchemeMemory(1))
	}
	return (*C.TPMT_KEYEDHASH_SCHEME)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSigSchemeRsassa) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSigSchemeRsassa) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSigSchemeRsassaRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSigSchemeRsassaRef(ref unsafe.Pointer) *TpmsSigSchemeRsassa {
	return (*TpmsSigSchemeRsassa)(ref)
}

// NewTpmsSigSchemeRsassa allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSigSchemeRsassa() *TpmsSigSchemeRsassa {
	return (*TpmsSigSchemeRsassa)(allocTpmsSchemeHashMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSigSchemeRsassa) PassRef() *C.TPMS_SCHEME_HASH {
	if x == nil {
		x = (*TpmsSigSchemeRsassa)(allocTpmsSchemeHashMemory(1))
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSigSchemeRsapss) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSigSchemeRsapss) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSigSchemeRsapssRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSigSchemeRsapssRef(ref unsafe.Pointer) *TpmsSigSchemeRsapss {
	return (*TpmsSigSchemeRsapss)(ref)
}

// NewTpmsSigSchemeRsapss allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSigSchemeRsapss() *TpmsSigSchemeRsapss {
	return (*TpmsSigSchemeRsapss)(allocTpmsSchemeHashMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSigSchemeRsapss) PassRef() *C.TPMS_SCHEME_HASH {
	if x == nil {
		x = (*TpmsSigSchemeRsapss)(allocTpmsSchemeHashMemory(1))
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSigSchemeEcdsa) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSigSchemeEcdsa) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSigSchemeEcdsaRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSigSchemeEcdsaRef(ref unsafe.Pointer) *TpmsSigSchemeEcdsa {
	return (*TpmsSigSchemeEcdsa)(ref)
}

// NewTpmsSigSchemeEcdsa allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSigSchemeEcdsa() *TpmsSigSchemeEcdsa {
	return (*TpmsSigSchemeEcdsa)(allocTpmsSchemeHashMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSigSchemeEcdsa) PassRef() *C.TPMS_SCHEME_HASH {
	if x == nil {
		x = (*TpmsSigSchemeEcdsa)(allocTpmsSchemeHashMemory(1))
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSigSchemeSm2) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSigSchemeSm2) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSigSchemeSm2Ref converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSigSchemeSm2Ref(ref unsafe.Pointer) *TpmsSigSchemeSm2 {
	return (*TpmsSigSchemeSm2)(ref)
}

// NewTpmsSigSchemeSm2 allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSigSchemeSm2() *TpmsSigSchemeSm2 {
	return (*TpmsSigSchemeSm2)(allocTpmsSchemeHashMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSigSchemeSm2) PassRef() *C.TPMS_SCHEME_HASH {
	if x == nil {
		x = (*TpmsSigSchemeSm2)(allocTpmsSchemeHashMemory(1))
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSigSchemeEcschnorr) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSigSchemeEcschnorr) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSigSchemeEcschnorrRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSigSchemeEcschnorrRef(ref unsafe.Pointer) *TpmsSigSchemeEcschnorr {
	return (*TpmsSigSchemeEcschnorr)(ref)
}

// NewTpmsSigSchemeEcschnorr allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSigSchemeEcschnorr() *TpmsSigSchemeEcschnorr {
	return (*TpmsSigSchemeEcschnorr)(allocTpmsSchemeHashMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSigSchemeEcschnorr) PassRef() *C.TPMS_SCHEME_HASH {
	if x == nil {
		x = (*TpmsSigSchemeEcschnorr)(allocTpmsSchemeHashMemory(1))
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSigSchemeEcdaa) Ref() *C.TPMS_SCHEME_ECDAA {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SCHEME_ECDAA)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSigSchemeEcdaa) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSigSchemeEcdaaRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSigSchemeEcdaaRef(ref unsafe.Pointer) *TpmsSigSchemeEcdaa {
	return (*TpmsSigSchemeEcdaa)(ref)
}

// NewTpmsSigSchemeEcdaa allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSigSchemeEcdaa() *TpmsSigSchemeEcdaa {
	return (*TpmsSigSchemeEcdaa)(allocTpmsSchemeEcdaaMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSigSchemeEcdaa) PassRef() *C.TPMS_SCHEME_ECDAA {
	if x == nil {
		x = (*TpmsSigSchemeEcdaa)(allocTpmsSchemeEcdaaMemory(1))
	}
	return (*C.TPMS_SCHEME_ECDAA)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmtSigScheme) Ref() *C.TPMT_SIG_SCHEME {
	if x == nil {
		return nil
	}
	return (*C.TPMT_SIG_SCHEME)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmtSigScheme) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmtSigSchemeRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmtSigSchemeRef(ref unsafe.Pointer) *TpmtSigScheme {
	return (*TpmtSigScheme)(ref)
}

// NewTpmtSigScheme allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmtSigScheme() *TpmtSigScheme {
	return (*TpmtSigScheme)(allocTpmtSigSchemeMemory(1))
}

// allocTpmtSigSchemeMemory allocates memory for type C.TPMT_SIG_SCHEME in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtSigSchemeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtSigSchemeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtSigSchemeValue = unsafe.Sizeof([1]C.TPMT_SIG_SCHEME{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmtSigScheme) PassRef() *C.TPMT_SIG_SCHEME {
	if x == nil {
		x = (*TpmtSigScheme)(allocTpmtSigSchemeMemory(1))
	}
	return (*C.TPMT_SIG_SCHEME)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsEncSchemeOaep) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsEncSchemeOaep) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsEncSchemeOaepRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsEncSchemeOaepRef(ref unsafe.Pointer) *TpmsEncSchemeOaep {
	return (*TpmsEncSchemeOaep)(ref)
}

// NewTpmsEncSchemeOaep allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsEncSchemeOaep() *TpmsEncSchemeOaep {
	return (*TpmsEncSchemeOaep)(allocTpmsSchemeHashMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsEncSchemeOaep) PassRef() *C.TPMS_SCHEME_HASH {
	if x == nil {
		x = (*TpmsEncSchemeOaep)(allocTpmsSchemeHashMemory(1))
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsEncSchemeRsaes) Ref() *C.TPMS_EMPTY {
	if x == nil {
		return nil
	}
	return (*C.TPMS_EMPTY)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsEncSchemeRsaes) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsEncSchemeRsaesRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsEncSchemeRsaesRef(ref unsafe.Pointer) *TpmsEncSchemeRsaes {
	return (*TpmsEncSchemeRsaes)(ref)
}

// NewTpmsEncSchemeRsaes allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsEncSchemeRsaes() *TpmsEncSchemeRsaes {
	return (*TpmsEncSchemeRsaes)(allocTpmsEmptyMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsEncSchemeRsaes) PassRef() *C.TPMS_EMPTY {
	if x == nil {
		x = (*TpmsEncSchemeRsaes)(allocTpmsEmptyMemory(1))
	}
	return (*C.TPMS_EMPTY)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsKeySchemeEcdh) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsKeySchemeEcdh) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsKeySchemeEcdhRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsKeySchemeEcdhRef(ref unsafe.Pointer) *TpmsKeySchemeEcdh {
	return (*TpmsKeySchemeEcdh)(ref)
}

// NewTpmsKeySchemeEcdh allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsKeySchemeEcdh() *TpmsKeySchemeEcdh {
	return (*TpmsKeySchemeEcdh)(allocTpmsSchemeHashMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsKeySchemeEcdh) PassRef() *C.TPMS_SCHEME_HASH {
	if x == nil {
		x = (*TpmsKeySchemeEcdh)(allocTpmsSchemeHashMemory(1))
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsKeySchemeEcmqv) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsKeySchemeEcmqv) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsKeySchemeEcmqvRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsKeySchemeEcmqvRef(ref unsafe.Pointer) *TpmsKeySchemeEcmqv {
	return (*TpmsKeySchemeEcmqv)(ref)
}

// NewTpmsKeySchemeEcmqv allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsKeySchemeEcmqv() *TpmsKeySchemeEcmqv {
	return (*TpmsKeySchemeEcmqv)(allocTpmsSchemeHashMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsKeySchemeEcmqv) PassRef() *C.TPMS_SCHEME_HASH {
	if x == nil {
		x = (*TpmsKeySchemeEcmqv)(allocTpmsSchemeHashMemory(1))
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSchemeMgf1) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSchemeMgf1) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSchemeMgf1Ref converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSchemeMgf1Ref(ref unsafe.Pointer) *TpmsSchemeMgf1 {
	return (*TpmsSchemeMgf1)(ref)
}

// NewTpmsSchemeMgf1 allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSchemeMgf1() *TpmsSchemeMgf1 {
	return (*TpmsSchemeMgf1)(allocTpmsSchemeHashMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSchemeMgf1) PassRef() *C.TPMS_SCHEME_HASH {
	if x == nil {
		x = (*TpmsSchemeMgf1)(allocTpmsSchemeHashMemory(1))
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSchemeKdf1Sp80056a) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSchemeKdf1Sp80056a) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSchemeKdf1Sp80056aRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSchemeKdf1Sp80056aRef(ref unsafe.Pointer) *TpmsSchemeKdf1Sp80056a {
	return (*TpmsSchemeKdf1Sp80056a)(ref)
}

// NewTpmsSchemeKdf1Sp80056a allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSchemeKdf1Sp80056a() *TpmsSchemeKdf1Sp80056a {
	return (*TpmsSchemeKdf1Sp80056a)(allocTpmsSchemeHashMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSchemeKdf1Sp80056a) PassRef() *C.TPMS_SCHEME_HASH {
	if x == nil {
		x = (*TpmsSchemeKdf1Sp80056a)(allocTpmsSchemeHashMemory(1))
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSchemeKdf2) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSchemeKdf2) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSchemeKdf2Ref converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSchemeKdf2Ref(ref unsafe.Pointer) *TpmsSchemeKdf2 {
	return (*TpmsSchemeKdf2)(ref)
}

// NewTpmsSchemeKdf2 allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSchemeKdf2() *TpmsSchemeKdf2 {
	return (*TpmsSchemeKdf2)(allocTpmsSchemeHashMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSchemeKdf2) PassRef() *C.TPMS_SCHEME_HASH {
	if x == nil {
		x = (*TpmsSchemeKdf2)(allocTpmsSchemeHashMemory(1))
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSchemeKdf1Sp800108) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSchemeKdf1Sp800108) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSchemeKdf1Sp800108Ref converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSchemeKdf1Sp800108Ref(ref unsafe.Pointer) *TpmsSchemeKdf1Sp800108 {
	return (*TpmsSchemeKdf1Sp800108)(ref)
}

// NewTpmsSchemeKdf1Sp800108 allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSchemeKdf1Sp800108() *TpmsSchemeKdf1Sp800108 {
	return (*TpmsSchemeKdf1Sp800108)(allocTpmsSchemeHashMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSchemeKdf1Sp800108) PassRef() *C.TPMS_SCHEME_HASH {
	if x == nil {
		x = (*TpmsSchemeKdf1Sp800108)(allocTpmsSchemeHashMemory(1))
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmtKdfScheme) Ref() *C.TPMT_KDF_SCHEME {
	if x == nil {
		return nil
	}
	return (*C.TPMT_KDF_SCHEME)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmtKdfScheme) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmtKdfSchemeRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmtKdfSchemeRef(ref unsafe.Pointer) *TpmtKdfScheme {
	return (*TpmtKdfScheme)(ref)
}

// NewTpmtKdfScheme allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmtKdfScheme() *TpmtKdfScheme {
	return (*TpmtKdfScheme)(allocTpmtKdfSchemeMemory(1))
}

// allocTpmtKdfSchemeMemory allocates memory for type C.TPMT_KDF_SCHEME in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtKdfSchemeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtKdfSchemeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtKdfSchemeValue = unsafe.Sizeof([1]C.TPMT_KDF_SCHEME{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmtKdfScheme) PassRef() *C.TPMT_KDF_SCHEME {
	if x == nil {
		x = (*TpmtKdfScheme)(allocTpmtKdfSchemeMemory(1))
	}
	return (*C.TPMT_KDF_SCHEME)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmtAsymScheme) Ref() *C.TPMT_ASYM_SCHEME {
	if x == nil {
		return nil
	}
	return (*C.TPMT_ASYM_SCHEME)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmtAsymScheme) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmtAsymSchemeRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmtAsymSchemeRef(ref unsafe.Pointer) *TpmtAsymScheme {
	return (*TpmtAsymScheme)(ref)
}

// NewTpmtAsymScheme allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmtAsymScheme() *TpmtAsymScheme {
	return (*TpmtAsymScheme)(allocTpmtAsymSchemeMemory(1))
}

// allocTpmtAsymSchemeMemory allocates memory for type C.TPMT_ASYM_SCHEME in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtAsymSchemeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtAsymSchemeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtAsymSchemeValue = unsafe.Sizeof([1]C.TPMT_ASYM_SCHEME{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmtAsymScheme) PassRef() *C.TPMT_ASYM_SCHEME {
	if x == nil {
		x = (*TpmtAsymScheme)(allocTpmtAsymSchemeMemory(1))
	}
	return (*C.TPMT_ASYM_SCHEME)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmtRsaScheme) Ref() *C.TPMT_RSA_SCHEME {
	if x == nil {
		return nil
	}
	return (*C.TPMT_RSA_SCHEME)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmtRsaScheme) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmtRsaSchemeRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmtRsaSchemeRef(ref unsafe.Pointer) *TpmtRsaScheme {
	return (*TpmtRsaScheme)(ref)
}

// NewTpmtRsaScheme allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmtRsaScheme() *TpmtRsaScheme {
	return (*TpmtRsaScheme)(allocTpmtRsaSchemeMemory(1))
}

// allocTpmtRsaSchemeMemory allocates memory for type C.TPMT_RSA_SCHEME in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtRsaSchemeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtRsaSchemeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtRsaSchemeValue = unsafe.Sizeof([1]C.TPMT_RSA_SCHEME{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmtRsaScheme) PassRef() *C.TPMT_RSA_SCHEME {
	if x == nil {
		x = (*TpmtRsaScheme)(allocTpmtRsaSchemeMemory(1))
	}
	return (*C.TPMT_RSA_SCHEME)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmtRsaDecrypt) Ref() *C.TPMT_RSA_DECRYPT {
	if x == nil {
		return nil
	}
	return (*C.TPMT_RSA_DECRYPT)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmtRsaDecrypt) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmtRsaDecryptRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmtRsaDecryptRef(ref unsafe.Pointer) *TpmtRsaDecrypt {
	return (*TpmtRsaDecrypt)(ref)
}

// NewTpmtRsaDecrypt allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmtRsaDecrypt() *TpmtRsaDecrypt {
	return (*TpmtRsaDecrypt)(allocTpmtRsaDecryptMemory(1))
}

// allocTpmtRsaDecryptMemory allocates memory for type C.TPMT_RSA_DECRYPT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtRsaDecryptMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtRsaDecryptValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtRsaDecryptValue = unsafe.Sizeof([1]C.TPMT_RSA_DECRYPT{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmtRsaDecrypt) PassRef() *C.TPMT_RSA_DECRYPT {
	if x == nil {
		x = (*TpmtRsaDecrypt)(allocTpmtRsaDecryptMemory(1))
	}
	return (*C.TPMT_RSA_DECRYPT)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bPublicKeyRsa) Ref() *C.TPM2B_PUBLIC_KEY_RSA {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_PUBLIC_KEY_RSA)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bPublicKeyRsa) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bPublicKeyRsaRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bPublicKeyRsaRef(ref unsafe.Pointer) *Tpm2bPublicKeyRsa {
	return (*Tpm2bPublicKeyRsa)(ref)
}

// NewTpm2bPublicKeyRsa allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bPublicKeyRsa() *Tpm2bPublicKeyRsa {
	return (*Tpm2bPublicKeyRsa)(allocTpm2bPublicKeyRsaMemory(1))
}

// allocTpm2bPublicKeyRsaMemory allocates memory for type C.TPM2B_PUBLIC_KEY_RSA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bPublicKeyRsaMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bPublicKeyRsaValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bPublicKeyRsaValue = unsafe.Sizeof([1]C.TPM2B_PUBLIC_KEY_RSA{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bPublicKeyRsa) PassRef() *C.TPM2B_PUBLIC_KEY_RSA {
	if x == nil {
		x = (*Tpm2bPublicKeyRsa)(allocTpm2bPublicKeyRsaMemory(1))
	}
	return (*C.TPM2B_PUBLIC_KEY_RSA)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bPrivateKeyRsa) Ref() *C.TPM2B_PRIVATE_KEY_RSA {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_PRIVATE_KEY_RSA)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bPrivateKeyRsa) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bPrivateKeyRsaRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bPrivateKeyRsaRef(ref unsafe.Pointer) *Tpm2bPrivateKeyRsa {
	return (*Tpm2bPrivateKeyRsa)(ref)
}

// NewTpm2bPrivateKeyRsa allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bPrivateKeyRsa() *Tpm2bPrivateKeyRsa {
	return (*Tpm2bPrivateKeyRsa)(allocTpm2bPrivateKeyRsaMemory(1))
}

// allocTpm2bPrivateKeyRsaMemory allocates memory for type C.TPM2B_PRIVATE_KEY_RSA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bPrivateKeyRsaMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bPrivateKeyRsaValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bPrivateKeyRsaValue = unsafe.Sizeof([1]C.TPM2B_PRIVATE_KEY_RSA{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bPrivateKeyRsa) PassRef() *C.TPM2B_PRIVATE_KEY_RSA {
	if x == nil {
		x = (*Tpm2bPrivateKeyRsa)(allocTpm2bPrivateKeyRsaMemory(1))
	}
	return (*C.TPM2B_PRIVATE_KEY_RSA)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bEccParameter) Ref() *C.TPM2B_ECC_PARAMETER {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_ECC_PARAMETER)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bEccParameter) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bEccParameterRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bEccParameterRef(ref unsafe.Pointer) *Tpm2bEccParameter {
	return (*Tpm2bEccParameter)(ref)
}

// NewTpm2bEccParameter allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bEccParameter() *Tpm2bEccParameter {
	return (*Tpm2bEccParameter)(allocTpm2bEccParameterMemory(1))
}

// allocTpm2bEccParameterMemory allocates memory for type C.TPM2B_ECC_PARAMETER in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bEccParameterMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bEccParameterValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bEccParameterValue = unsafe.Sizeof([1]C.TPM2B_ECC_PARAMETER{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bEccParameter) PassRef() *C.TPM2B_ECC_PARAMETER {
	if x == nil {
		x = (*Tpm2bEccParameter)(allocTpm2bEccParameterMemory(1))
	}
	return (*C.TPM2B_ECC_PARAMETER)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsEccPoint) Ref() *C.TPMS_ECC_POINT {
	if x == nil {
		return nil
	}
	return (*C.TPMS_ECC_POINT)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsEccPoint) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsEccPointRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsEccPointRef(ref unsafe.Pointer) *TpmsEccPoint {
	return (*TpmsEccPoint)(ref)
}

// NewTpmsEccPoint allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsEccPoint() *TpmsEccPoint {
	return (*TpmsEccPoint)(allocTpmsEccPointMemory(1))
}

// allocTpmsEccPointMemory allocates memory for type C.TPMS_ECC_POINT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsEccPointMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsEccPointValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsEccPointValue = unsafe.Sizeof([1]C.TPMS_ECC_POINT{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsEccPoint) PassRef() *C.TPMS_ECC_POINT {
	if x == nil {
		x = (*TpmsEccPoint)(allocTpmsEccPointMemory(1))
	}
	return (*C.TPMS_ECC_POINT)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bEccPoint) Ref() *C.TPM2B_ECC_POINT {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_ECC_POINT)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bEccPoint) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bEccPointRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bEccPointRef(ref unsafe.Pointer) *Tpm2bEccPoint {
	return (*Tpm2bEccPoint)(ref)
}

// NewTpm2bEccPoint allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bEccPoint() *Tpm2bEccPoint {
	return (*Tpm2bEccPoint)(allocTpm2bEccPointMemory(1))
}

// allocTpm2bEccPointMemory allocates memory for type C.TPM2B_ECC_POINT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bEccPointMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bEccPointValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bEccPointValue = unsafe.Sizeof([1]C.TPM2B_ECC_POINT{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bEccPoint) PassRef() *C.TPM2B_ECC_POINT {
	if x == nil {
		x = (*Tpm2bEccPoint)(allocTpm2bEccPointMemory(1))
	}
	return (*C.TPM2B_ECC_POINT)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmtEccScheme) Ref() *C.TPMT_ECC_SCHEME {
	if x == nil {
		return nil
	}
	return (*C.TPMT_ECC_SCHEME)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmtEccScheme) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmtEccSchemeRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmtEccSchemeRef(ref unsafe.Pointer) *TpmtEccScheme {
	return (*TpmtEccScheme)(ref)
}

// NewTpmtEccScheme allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmtEccScheme() *TpmtEccScheme {
	return (*TpmtEccScheme)(allocTpmtEccSchemeMemory(1))
}

// allocTpmtEccSchemeMemory allocates memory for type C.TPMT_ECC_SCHEME in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtEccSchemeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtEccSchemeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtEccSchemeValue = unsafe.Sizeof([1]C.TPMT_ECC_SCHEME{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmtEccScheme) PassRef() *C.TPMT_ECC_SCHEME {
	if x == nil {
		x = (*TpmtEccScheme)(allocTpmtEccSchemeMemory(1))
	}
	return (*C.TPMT_ECC_SCHEME)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsAlgorithmDetailEcc) Ref() *C.TPMS_ALGORITHM_DETAIL_ECC {
	if x == nil {
		return nil
	}
	return (*C.TPMS_ALGORITHM_DETAIL_ECC)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsAlgorithmDetailEcc) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsAlgorithmDetailEccRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsAlgorithmDetailEccRef(ref unsafe.Pointer) *TpmsAlgorithmDetailEcc {
	return (*TpmsAlgorithmDetailEcc)(ref)
}

// NewTpmsAlgorithmDetailEcc allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsAlgorithmDetailEcc() *TpmsAlgorithmDetailEcc {
	return (*TpmsAlgorithmDetailEcc)(allocTpmsAlgorithmDetailEccMemory(1))
}

// allocTpmsAlgorithmDetailEccMemory allocates memory for type C.TPMS_ALGORITHM_DETAIL_ECC in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsAlgorithmDetailEccMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsAlgorithmDetailEccValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsAlgorithmDetailEccValue = unsafe.Sizeof([1]C.TPMS_ALGORITHM_DETAIL_ECC{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsAlgorithmDetailEcc) PassRef() *C.TPMS_ALGORITHM_DETAIL_ECC {
	if x == nil {
		x = (*TpmsAlgorithmDetailEcc)(allocTpmsAlgorithmDetailEccMemory(1))
	}
	return (*C.TPMS_ALGORITHM_DETAIL_ECC)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSignatureRsa) Ref() *C.TPMS_SIGNATURE_RSA {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SIGNATURE_RSA)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSignatureRsa) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSignatureRsaRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSignatureRsaRef(ref unsafe.Pointer) *TpmsSignatureRsa {
	return (*TpmsSignatureRsa)(ref)
}

// NewTpmsSignatureRsa allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSignatureRsa() *TpmsSignatureRsa {
	return (*TpmsSignatureRsa)(allocTpmsSignatureRsaMemory(1))
}

// allocTpmsSignatureRsaMemory allocates memory for type C.TPMS_SIGNATURE_RSA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsSignatureRsaMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsSignatureRsaValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsSignatureRsaValue = unsafe.Sizeof([1]C.TPMS_SIGNATURE_RSA{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSignatureRsa) PassRef() *C.TPMS_SIGNATURE_RSA {
	if x == nil {
		x = (*TpmsSignatureRsa)(allocTpmsSignatureRsaMemory(1))
	}
	return (*C.TPMS_SIGNATURE_RSA)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSignatureRsassa) Ref() *C.TPMS_SIGNATURE_RSA {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SIGNATURE_RSA)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSignatureRsassa) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSignatureRsassaRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSignatureRsassaRef(ref unsafe.Pointer) *TpmsSignatureRsassa {
	return (*TpmsSignatureRsassa)(ref)
}

// NewTpmsSignatureRsassa allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSignatureRsassa() *TpmsSignatureRsassa {
	return (*TpmsSignatureRsassa)(allocTpmsSignatureRsaMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSignatureRsassa) PassRef() *C.TPMS_SIGNATURE_RSA {
	if x == nil {
		x = (*TpmsSignatureRsassa)(allocTpmsSignatureRsaMemory(1))
	}
	return (*C.TPMS_SIGNATURE_RSA)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSignatureRsapss) Ref() *C.TPMS_SIGNATURE_RSA {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SIGNATURE_RSA)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSignatureRsapss) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSignatureRsapssRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSignatureRsapssRef(ref unsafe.Pointer) *TpmsSignatureRsapss {
	return (*TpmsSignatureRsapss)(ref)
}

// NewTpmsSignatureRsapss allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSignatureRsapss() *TpmsSignatureRsapss {
	return (*TpmsSignatureRsapss)(allocTpmsSignatureRsaMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSignatureRsapss) PassRef() *C.TPMS_SIGNATURE_RSA {
	if x == nil {
		x = (*TpmsSignatureRsapss)(allocTpmsSignatureRsaMemory(1))
	}
	return (*C.TPMS_SIGNATURE_RSA)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSignatureEcc) Ref() *C.TPMS_SIGNATURE_ECC {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SIGNATURE_ECC)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSignatureEcc) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSignatureEccRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSignatureEccRef(ref unsafe.Pointer) *TpmsSignatureEcc {
	return (*TpmsSignatureEcc)(ref)
}

// NewTpmsSignatureEcc allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSignatureEcc() *TpmsSignatureEcc {
	return (*TpmsSignatureEcc)(allocTpmsSignatureEccMemory(1))
}

// allocTpmsSignatureEccMemory allocates memory for type C.TPMS_SIGNATURE_ECC in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsSignatureEccMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsSignatureEccValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsSignatureEccValue = unsafe.Sizeof([1]C.TPMS_SIGNATURE_ECC{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSignatureEcc) PassRef() *C.TPMS_SIGNATURE_ECC {
	if x == nil {
		x = (*TpmsSignatureEcc)(allocTpmsSignatureEccMemory(1))
	}
	return (*C.TPMS_SIGNATURE_ECC)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSignatureEcdsa) Ref() *C.TPMS_SIGNATURE_ECC {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SIGNATURE_ECC)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSignatureEcdsa) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSignatureEcdsaRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSignatureEcdsaRef(ref unsafe.Pointer) *TpmsSignatureEcdsa {
	return (*TpmsSignatureEcdsa)(ref)
}

// NewTpmsSignatureEcdsa allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSignatureEcdsa() *TpmsSignatureEcdsa {
	return (*TpmsSignatureEcdsa)(allocTpmsSignatureEccMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSignatureEcdsa) PassRef() *C.TPMS_SIGNATURE_ECC {
	if x == nil {
		x = (*TpmsSignatureEcdsa)(allocTpmsSignatureEccMemory(1))
	}
	return (*C.TPMS_SIGNATURE_ECC)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSignatureEcdaa) Ref() *C.TPMS_SIGNATURE_ECC {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SIGNATURE_ECC)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSignatureEcdaa) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSignatureEcdaaRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSignatureEcdaaRef(ref unsafe.Pointer) *TpmsSignatureEcdaa {
	return (*TpmsSignatureEcdaa)(ref)
}

// NewTpmsSignatureEcdaa allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSignatureEcdaa() *TpmsSignatureEcdaa {
	return (*TpmsSignatureEcdaa)(allocTpmsSignatureEccMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSignatureEcdaa) PassRef() *C.TPMS_SIGNATURE_ECC {
	if x == nil {
		x = (*TpmsSignatureEcdaa)(allocTpmsSignatureEccMemory(1))
	}
	return (*C.TPMS_SIGNATURE_ECC)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSignatureSm2) Ref() *C.TPMS_SIGNATURE_ECC {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SIGNATURE_ECC)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSignatureSm2) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSignatureSm2Ref converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSignatureSm2Ref(ref unsafe.Pointer) *TpmsSignatureSm2 {
	return (*TpmsSignatureSm2)(ref)
}

// NewTpmsSignatureSm2 allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSignatureSm2() *TpmsSignatureSm2 {
	return (*TpmsSignatureSm2)(allocTpmsSignatureEccMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSignatureSm2) PassRef() *C.TPMS_SIGNATURE_ECC {
	if x == nil {
		x = (*TpmsSignatureSm2)(allocTpmsSignatureEccMemory(1))
	}
	return (*C.TPMS_SIGNATURE_ECC)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSignatureEcschnorr) Ref() *C.TPMS_SIGNATURE_ECC {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SIGNATURE_ECC)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSignatureEcschnorr) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSignatureEcschnorrRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSignatureEcschnorrRef(ref unsafe.Pointer) *TpmsSignatureEcschnorr {
	return (*TpmsSignatureEcschnorr)(ref)
}

// NewTpmsSignatureEcschnorr allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSignatureEcschnorr() *TpmsSignatureEcschnorr {
	return (*TpmsSignatureEcschnorr)(allocTpmsSignatureEccMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSignatureEcschnorr) PassRef() *C.TPMS_SIGNATURE_ECC {
	if x == nil {
		x = (*TpmsSignatureEcschnorr)(allocTpmsSignatureEccMemory(1))
	}
	return (*C.TPMS_SIGNATURE_ECC)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmtSignature) Ref() *C.TPMT_SIGNATURE {
	if x == nil {
		return nil
	}
	return (*C.TPMT_SIGNATURE)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmtSignature) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmtSignatureRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmtSignatureRef(ref unsafe.Pointer) *TpmtSignature {
	return (*TpmtSignature)(ref)
}

// NewTpmtSignature allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmtSignature() *TpmtSignature {
	return (*TpmtSignature)(allocTpmtSignatureMemory(1))
}

// allocTpmtSignatureMemory allocates memory for type C.TPMT_SIGNATURE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtSignatureMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtSignatureValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtSignatureValue = unsafe.Sizeof([1]C.TPMT_SIGNATURE{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmtSignature) PassRef() *C.TPMT_SIGNATURE {
	if x == nil {
		x = (*TpmtSignature)(allocTpmtSignatureMemory(1))
	}
	return (*C.TPMT_SIGNATURE)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bEncryptedSecret) Ref() *C.TPM2B_ENCRYPTED_SECRET {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_ENCRYPTED_SECRET)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bEncryptedSecret) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bEncryptedSecretRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bEncryptedSecretRef(ref unsafe.Pointer) *Tpm2bEncryptedSecret {
	return (*Tpm2bEncryptedSecret)(ref)
}

// NewTpm2bEncryptedSecret allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bEncryptedSecret() *Tpm2bEncryptedSecret {
	return (*Tpm2bEncryptedSecret)(allocTpm2bEncryptedSecretMemory(1))
}

// allocTpm2bEncryptedSecretMemory allocates memory for type C.TPM2B_ENCRYPTED_SECRET in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bEncryptedSecretMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bEncryptedSecretValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bEncryptedSecretValue = unsafe.Sizeof([1]C.TPM2B_ENCRYPTED_SECRET{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bEncryptedSecret) PassRef() *C.TPM2B_ENCRYPTED_SECRET {
	if x == nil {
		x = (*Tpm2bEncryptedSecret)(allocTpm2bEncryptedSecretMemory(1))
	}
	return (*C.TPM2B_ENCRYPTED_SECRET)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsKeyedhashParms) Ref() *C.TPMS_KEYEDHASH_PARMS {
	if x == nil {
		return nil
	}
	return (*C.TPMS_KEYEDHASH_PARMS)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsKeyedhashParms) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsKeyedhashParmsRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsKeyedhashParmsRef(ref unsafe.Pointer) *TpmsKeyedhashParms {
	return (*TpmsKeyedhashParms)(ref)
}

// NewTpmsKeyedhashParms allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsKeyedhashParms() *TpmsKeyedhashParms {
	return (*TpmsKeyedhashParms)(allocTpmsKeyedhashParmsMemory(1))
}

// allocTpmsKeyedhashParmsMemory allocates memory for type C.TPMS_KEYEDHASH_PARMS in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsKeyedhashParmsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsKeyedhashParmsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsKeyedhashParmsValue = unsafe.Sizeof([1]C.TPMS_KEYEDHASH_PARMS{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsKeyedhashParms) PassRef() *C.TPMS_KEYEDHASH_PARMS {
	if x == nil {
		x = (*TpmsKeyedhashParms)(allocTpmsKeyedhashParmsMemory(1))
	}
	return (*C.TPMS_KEYEDHASH_PARMS)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsAsymParms) Ref() *C.TPMS_ASYM_PARMS {
	if x == nil {
		return nil
	}
	return (*C.TPMS_ASYM_PARMS)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsAsymParms) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsAsymParmsRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsAsymParmsRef(ref unsafe.Pointer) *TpmsAsymParms {
	return (*TpmsAsymParms)(ref)
}

// NewTpmsAsymParms allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsAsymParms() *TpmsAsymParms {
	return (*TpmsAsymParms)(allocTpmsAsymParmsMemory(1))
}

// allocTpmsAsymParmsMemory allocates memory for type C.TPMS_ASYM_PARMS in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsAsymParmsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsAsymParmsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsAsymParmsValue = unsafe.Sizeof([1]C.TPMS_ASYM_PARMS{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsAsymParms) PassRef() *C.TPMS_ASYM_PARMS {
	if x == nil {
		x = (*TpmsAsymParms)(allocTpmsAsymParmsMemory(1))
	}
	return (*C.TPMS_ASYM_PARMS)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsRsaParms) Ref() *C.TPMS_RSA_PARMS {
	if x == nil {
		return nil
	}
	return (*C.TPMS_RSA_PARMS)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsRsaParms) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsRsaParmsRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsRsaParmsRef(ref unsafe.Pointer) *TpmsRsaParms {
	return (*TpmsRsaParms)(ref)
}

// NewTpmsRsaParms allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsRsaParms() *TpmsRsaParms {
	return (*TpmsRsaParms)(allocTpmsRsaParmsMemory(1))
}

// allocTpmsRsaParmsMemory allocates memory for type C.TPMS_RSA_PARMS in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsRsaParmsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsRsaParmsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsRsaParmsValue = unsafe.Sizeof([1]C.TPMS_RSA_PARMS{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsRsaParms) PassRef() *C.TPMS_RSA_PARMS {
	if x == nil {
		x = (*TpmsRsaParms)(allocTpmsRsaParmsMemory(1))
	}
	return (*C.TPMS_RSA_PARMS)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsEccParms) Ref() *C.TPMS_ECC_PARMS {
	if x == nil {
		return nil
	}
	return (*C.TPMS_ECC_PARMS)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsEccParms) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsEccParmsRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsEccParmsRef(ref unsafe.Pointer) *TpmsEccParms {
	return (*TpmsEccParms)(ref)
}

// NewTpmsEccParms allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsEccParms() *TpmsEccParms {
	return (*TpmsEccParms)(allocTpmsEccParmsMemory(1))
}

// allocTpmsEccParmsMemory allocates memory for type C.TPMS_ECC_PARMS in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsEccParmsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsEccParmsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsEccParmsValue = unsafe.Sizeof([1]C.TPMS_ECC_PARMS{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsEccParms) PassRef() *C.TPMS_ECC_PARMS {
	if x == nil {
		x = (*TpmsEccParms)(allocTpmsEccParmsMemory(1))
	}
	return (*C.TPMS_ECC_PARMS)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmtPublicParms) Ref() *C.TPMT_PUBLIC_PARMS {
	if x == nil {
		return nil
	}
	return (*C.TPMT_PUBLIC_PARMS)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmtPublicParms) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmtPublicParmsRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmtPublicParmsRef(ref unsafe.Pointer) *TpmtPublicParms {
	return (*TpmtPublicParms)(ref)
}

// NewTpmtPublicParms allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmtPublicParms() *TpmtPublicParms {
	return (*TpmtPublicParms)(allocTpmtPublicParmsMemory(1))
}

// allocTpmtPublicParmsMemory allocates memory for type C.TPMT_PUBLIC_PARMS in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtPublicParmsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtPublicParmsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtPublicParmsValue = unsafe.Sizeof([1]C.TPMT_PUBLIC_PARMS{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmtPublicParms) PassRef() *C.TPMT_PUBLIC_PARMS {
	if x == nil {
		x = (*TpmtPublicParms)(allocTpmtPublicParmsMemory(1))
	}
	return (*C.TPMT_PUBLIC_PARMS)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmtPublic) Ref() *C.TPMT_PUBLIC {
	if x == nil {
		return nil
	}
	return (*C.TPMT_PUBLIC)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmtPublic) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmtPublicRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmtPublicRef(ref unsafe.Pointer) *TpmtPublic {
	return (*TpmtPublic)(ref)
}

// NewTpmtPublic allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmtPublic() *TpmtPublic {
	return (*TpmtPublic)(allocTpmtPublicMemory(1))
}

// allocTpmtPublicMemory allocates memory for type C.TPMT_PUBLIC in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtPublicMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtPublicValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtPublicValue = unsafe.Sizeof([1]C.TPMT_PUBLIC{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmtPublic) PassRef() *C.TPMT_PUBLIC {
	if x == nil {
		x = (*TpmtPublic)(allocTpmtPublicMemory(1))
	}
	return (*C.TPMT_PUBLIC)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bPublic) Ref() *C.TPM2B_PUBLIC {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_PUBLIC)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bPublic) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bPublicRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bPublicRef(ref unsafe.Pointer) *Tpm2bPublic {
	return (*Tpm2bPublic)(ref)
}

// NewTpm2bPublic allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bPublic() *Tpm2bPublic {
	return (*Tpm2bPublic)(allocTpm2bPublicMemory(1))
}

// allocTpm2bPublicMemory allocates memory for type C.TPM2B_PUBLIC in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bPublicMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bPublicValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bPublicValue = unsafe.Sizeof([1]C.TPM2B_PUBLIC{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bPublic) PassRef() *C.TPM2B_PUBLIC {
	if x == nil {
		x = (*Tpm2bPublic)(allocTpm2bPublicMemory(1))
	}
	return (*C.TPM2B_PUBLIC)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bTemplate) Ref() *C.TPM2B_TEMPLATE {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_TEMPLATE)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bTemplate) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bTemplateRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bTemplateRef(ref unsafe.Pointer) *Tpm2bTemplate {
	return (*Tpm2bTemplate)(ref)
}

// NewTpm2bTemplate allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bTemplate() *Tpm2bTemplate {
	return (*Tpm2bTemplate)(allocTpm2bTemplateMemory(1))
}

// allocTpm2bTemplateMemory allocates memory for type C.TPM2B_TEMPLATE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bTemplateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bTemplateValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bTemplateValue = unsafe.Sizeof([1]C.TPM2B_TEMPLATE{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bTemplate) PassRef() *C.TPM2B_TEMPLATE {
	if x == nil {
		x = (*Tpm2bTemplate)(allocTpm2bTemplateMemory(1))
	}
	return (*C.TPM2B_TEMPLATE)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bPrivateVendorSpecific) Ref() *C.TPM2B_PRIVATE_VENDOR_SPECIFIC {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_PRIVATE_VENDOR_SPECIFIC)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bPrivateVendorSpecific) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bPrivateVendorSpecificRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bPrivateVendorSpecificRef(ref unsafe.Pointer) *Tpm2bPrivateVendorSpecific {
	return (*Tpm2bPrivateVendorSpecific)(ref)
}

// NewTpm2bPrivateVendorSpecific allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bPrivateVendorSpecific() *Tpm2bPrivateVendorSpecific {
	return (*Tpm2bPrivateVendorSpecific)(allocTpm2bPrivateVendorSpecificMemory(1))
}

// allocTpm2bPrivateVendorSpecificMemory allocates memory for type C.TPM2B_PRIVATE_VENDOR_SPECIFIC in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bPrivateVendorSpecificMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bPrivateVendorSpecificValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bPrivateVendorSpecificValue = unsafe.Sizeof([1]C.TPM2B_PRIVATE_VENDOR_SPECIFIC{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bPrivateVendorSpecific) PassRef() *C.TPM2B_PRIVATE_VENDOR_SPECIFIC {
	if x == nil {
		x = (*Tpm2bPrivateVendorSpecific)(allocTpm2bPrivateVendorSpecificMemory(1))
	}
	return (*C.TPM2B_PRIVATE_VENDOR_SPECIFIC)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmtSensitive) Ref() *C.TPMT_SENSITIVE {
	if x == nil {
		return nil
	}
	return (*C.TPMT_SENSITIVE)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmtSensitive) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmtSensitiveRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmtSensitiveRef(ref unsafe.Pointer) *TpmtSensitive {
	return (*TpmtSensitive)(ref)
}

// NewTpmtSensitive allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmtSensitive() *TpmtSensitive {
	return (*TpmtSensitive)(allocTpmtSensitiveMemory(1))
}

// allocTpmtSensitiveMemory allocates memory for type C.TPMT_SENSITIVE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtSensitiveMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtSensitiveValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtSensitiveValue = unsafe.Sizeof([1]C.TPMT_SENSITIVE{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmtSensitive) PassRef() *C.TPMT_SENSITIVE {
	if x == nil {
		x = (*TpmtSensitive)(allocTpmtSensitiveMemory(1))
	}
	return (*C.TPMT_SENSITIVE)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bSensitive) Ref() *C.TPM2B_SENSITIVE {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_SENSITIVE)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bSensitive) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bSensitiveRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bSensitiveRef(ref unsafe.Pointer) *Tpm2bSensitive {
	return (*Tpm2bSensitive)(ref)
}

// NewTpm2bSensitive allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bSensitive() *Tpm2bSensitive {
	return (*Tpm2bSensitive)(allocTpm2bSensitiveMemory(1))
}

// allocTpm2bSensitiveMemory allocates memory for type C.TPM2B_SENSITIVE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bSensitiveMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bSensitiveValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bSensitiveValue = unsafe.Sizeof([1]C.TPM2B_SENSITIVE{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bSensitive) PassRef() *C.TPM2B_SENSITIVE {
	if x == nil {
		x = (*Tpm2bSensitive)(allocTpm2bSensitiveMemory(1))
	}
	return (*C.TPM2B_SENSITIVE)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Private) Ref() *C._PRIVATE {
	if x == nil {
		return nil
	}
	return (*C._PRIVATE)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Private) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPrivateRef converts the C object reference into a raw struct reference without wrapping.
func NewPrivateRef(ref unsafe.Pointer) *Private {
	return (*Private)(ref)
}

// NewPrivate allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPrivate() *Private {
	return (*Private)(allocPrivateMemory(1))
}

// allocPrivateMemory allocates memory for type C._PRIVATE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPrivateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPrivateValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPrivateValue = unsafe.Sizeof([1]C._PRIVATE{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Private) PassRef() *C._PRIVATE {
	if x == nil {
		x = (*Private)(allocPrivateMemory(1))
	}
	return (*C._PRIVATE)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bPrivate) Ref() *C.TPM2B_PRIVATE {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_PRIVATE)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bPrivate) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bPrivateRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bPrivateRef(ref unsafe.Pointer) *Tpm2bPrivate {
	return (*Tpm2bPrivate)(ref)
}

// NewTpm2bPrivate allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bPrivate() *Tpm2bPrivate {
	return (*Tpm2bPrivate)(allocTpm2bPrivateMemory(1))
}

// allocTpm2bPrivateMemory allocates memory for type C.TPM2B_PRIVATE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bPrivateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bPrivateValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bPrivateValue = unsafe.Sizeof([1]C.TPM2B_PRIVATE{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bPrivate) PassRef() *C.TPM2B_PRIVATE {
	if x == nil {
		x = (*Tpm2bPrivate)(allocTpm2bPrivateMemory(1))
	}
	return (*C.TPM2B_PRIVATE)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsIdObject) Ref() *C.TPMS_ID_OBJECT {
	if x == nil {
		return nil
	}
	return (*C.TPMS_ID_OBJECT)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsIdObject) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsIdObjectRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsIdObjectRef(ref unsafe.Pointer) *TpmsIdObject {
	return (*TpmsIdObject)(ref)
}

// NewTpmsIdObject allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsIdObject() *TpmsIdObject {
	return (*TpmsIdObject)(allocTpmsIdObjectMemory(1))
}

// allocTpmsIdObjectMemory allocates memory for type C.TPMS_ID_OBJECT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsIdObjectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsIdObjectValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsIdObjectValue = unsafe.Sizeof([1]C.TPMS_ID_OBJECT{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsIdObject) PassRef() *C.TPMS_ID_OBJECT {
	if x == nil {
		x = (*TpmsIdObject)(allocTpmsIdObjectMemory(1))
	}
	return (*C.TPMS_ID_OBJECT)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bIdObject) Ref() *C.TPM2B_ID_OBJECT {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_ID_OBJECT)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bIdObject) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bIdObjectRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bIdObjectRef(ref unsafe.Pointer) *Tpm2bIdObject {
	return (*Tpm2bIdObject)(ref)
}

// NewTpm2bIdObject allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bIdObject() *Tpm2bIdObject {
	return (*Tpm2bIdObject)(allocTpm2bIdObjectMemory(1))
}

// allocTpm2bIdObjectMemory allocates memory for type C.TPM2B_ID_OBJECT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bIdObjectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bIdObjectValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bIdObjectValue = unsafe.Sizeof([1]C.TPM2B_ID_OBJECT{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bIdObject) PassRef() *C.TPM2B_ID_OBJECT {
	if x == nil {
		x = (*Tpm2bIdObject)(allocTpm2bIdObjectMemory(1))
	}
	return (*C.TPM2B_ID_OBJECT)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsNvPinCounterParameters) Ref() *C.TPMS_NV_PIN_COUNTER_PARAMETERS {
	if x == nil {
		return nil
	}
	return (*C.TPMS_NV_PIN_COUNTER_PARAMETERS)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsNvPinCounterParameters) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsNvPinCounterParametersRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsNvPinCounterParametersRef(ref unsafe.Pointer) *TpmsNvPinCounterParameters {
	return (*TpmsNvPinCounterParameters)(ref)
}

// NewTpmsNvPinCounterParameters allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsNvPinCounterParameters() *TpmsNvPinCounterParameters {
	return (*TpmsNvPinCounterParameters)(allocTpmsNvPinCounterParametersMemory(1))
}

// allocTpmsNvPinCounterParametersMemory allocates memory for type C.TPMS_NV_PIN_COUNTER_PARAMETERS in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsNvPinCounterParametersMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsNvPinCounterParametersValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsNvPinCounterParametersValue = unsafe.Sizeof([1]C.TPMS_NV_PIN_COUNTER_PARAMETERS{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsNvPinCounterParameters) PassRef() *C.TPMS_NV_PIN_COUNTER_PARAMETERS {
	if x == nil {
		x = (*TpmsNvPinCounterParameters)(allocTpmsNvPinCounterParametersMemory(1))
	}
	return (*C.TPMS_NV_PIN_COUNTER_PARAMETERS)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsNvPublic) Ref() *C.TPMS_NV_PUBLIC {
	if x == nil {
		return nil
	}
	return (*C.TPMS_NV_PUBLIC)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsNvPublic) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsNvPublicRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsNvPublicRef(ref unsafe.Pointer) *TpmsNvPublic {
	return (*TpmsNvPublic)(ref)
}

// NewTpmsNvPublic allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsNvPublic() *TpmsNvPublic {
	return (*TpmsNvPublic)(allocTpmsNvPublicMemory(1))
}

// allocTpmsNvPublicMemory allocates memory for type C.TPMS_NV_PUBLIC in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsNvPublicMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsNvPublicValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsNvPublicValue = unsafe.Sizeof([1]C.TPMS_NV_PUBLIC{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsNvPublic) PassRef() *C.TPMS_NV_PUBLIC {
	if x == nil {
		x = (*TpmsNvPublic)(allocTpmsNvPublicMemory(1))
	}
	return (*C.TPMS_NV_PUBLIC)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bNvPublic) Ref() *C.TPM2B_NV_PUBLIC {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_NV_PUBLIC)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bNvPublic) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bNvPublicRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bNvPublicRef(ref unsafe.Pointer) *Tpm2bNvPublic {
	return (*Tpm2bNvPublic)(ref)
}

// NewTpm2bNvPublic allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bNvPublic() *Tpm2bNvPublic {
	return (*Tpm2bNvPublic)(allocTpm2bNvPublicMemory(1))
}

// allocTpm2bNvPublicMemory allocates memory for type C.TPM2B_NV_PUBLIC in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bNvPublicMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bNvPublicValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bNvPublicValue = unsafe.Sizeof([1]C.TPM2B_NV_PUBLIC{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bNvPublic) PassRef() *C.TPM2B_NV_PUBLIC {
	if x == nil {
		x = (*Tpm2bNvPublic)(allocTpm2bNvPublicMemory(1))
	}
	return (*C.TPM2B_NV_PUBLIC)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bContextSensitive) Ref() *C.TPM2B_CONTEXT_SENSITIVE {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_CONTEXT_SENSITIVE)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bContextSensitive) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bContextSensitiveRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bContextSensitiveRef(ref unsafe.Pointer) *Tpm2bContextSensitive {
	return (*Tpm2bContextSensitive)(ref)
}

// NewTpm2bContextSensitive allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bContextSensitive() *Tpm2bContextSensitive {
	return (*Tpm2bContextSensitive)(allocTpm2bContextSensitiveMemory(1))
}

// allocTpm2bContextSensitiveMemory allocates memory for type C.TPM2B_CONTEXT_SENSITIVE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bContextSensitiveMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bContextSensitiveValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bContextSensitiveValue = unsafe.Sizeof([1]C.TPM2B_CONTEXT_SENSITIVE{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bContextSensitive) PassRef() *C.TPM2B_CONTEXT_SENSITIVE {
	if x == nil {
		x = (*Tpm2bContextSensitive)(allocTpm2bContextSensitiveMemory(1))
	}
	return (*C.TPM2B_CONTEXT_SENSITIVE)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsContextData) Ref() *C.TPMS_CONTEXT_DATA {
	if x == nil {
		return nil
	}
	return (*C.TPMS_CONTEXT_DATA)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsContextData) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsContextDataRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsContextDataRef(ref unsafe.Pointer) *TpmsContextData {
	return (*TpmsContextData)(ref)
}

// NewTpmsContextData allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsContextData() *TpmsContextData {
	return (*TpmsContextData)(allocTpmsContextDataMemory(1))
}

// allocTpmsContextDataMemory allocates memory for type C.TPMS_CONTEXT_DATA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsContextDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsContextDataValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsContextDataValue = unsafe.Sizeof([1]C.TPMS_CONTEXT_DATA{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsContextData) PassRef() *C.TPMS_CONTEXT_DATA {
	if x == nil {
		x = (*TpmsContextData)(allocTpmsContextDataMemory(1))
	}
	return (*C.TPMS_CONTEXT_DATA)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bContextData) Ref() *C.TPM2B_CONTEXT_DATA {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_CONTEXT_DATA)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bContextData) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bContextDataRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bContextDataRef(ref unsafe.Pointer) *Tpm2bContextData {
	return (*Tpm2bContextData)(ref)
}

// NewTpm2bContextData allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bContextData() *Tpm2bContextData {
	return (*Tpm2bContextData)(allocTpm2bContextDataMemory(1))
}

// allocTpm2bContextDataMemory allocates memory for type C.TPM2B_CONTEXT_DATA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bContextDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bContextDataValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bContextDataValue = unsafe.Sizeof([1]C.TPM2B_CONTEXT_DATA{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bContextData) PassRef() *C.TPM2B_CONTEXT_DATA {
	if x == nil {
		x = (*Tpm2bContextData)(allocTpm2bContextDataMemory(1))
	}
	return (*C.TPM2B_CONTEXT_DATA)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsContext) Ref() *C.TPMS_CONTEXT {
	if x == nil {
		return nil
	}
	return (*C.TPMS_CONTEXT)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsContext) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsContextRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsContextRef(ref unsafe.Pointer) *TpmsContext {
	return (*TpmsContext)(ref)
}

// NewTpmsContext allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsContext() *TpmsContext {
	return (*TpmsContext)(allocTpmsContextMemory(1))
}

// allocTpmsContextMemory allocates memory for type C.TPMS_CONTEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsContextValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsContextValue = unsafe.Sizeof([1]C.TPMS_CONTEXT{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsContext) PassRef() *C.TPMS_CONTEXT {
	if x == nil {
		x = (*TpmsContext)(allocTpmsContextMemory(1))
	}
	return (*C.TPMS_CONTEXT)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsCreationData) Ref() *C.TPMS_CREATION_DATA {
	if x == nil {
		return nil
	}
	return (*C.TPMS_CREATION_DATA)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsCreationData) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsCreationDataRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsCreationDataRef(ref unsafe.Pointer) *TpmsCreationData {
	return (*TpmsCreationData)(ref)
}

// NewTpmsCreationData allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsCreationData() *TpmsCreationData {
	return (*TpmsCreationData)(allocTpmsCreationDataMemory(1))
}

// allocTpmsCreationDataMemory allocates memory for type C.TPMS_CREATION_DATA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsCreationDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsCreationDataValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsCreationDataValue = unsafe.Sizeof([1]C.TPMS_CREATION_DATA{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsCreationData) PassRef() *C.TPMS_CREATION_DATA {
	if x == nil {
		x = (*TpmsCreationData)(allocTpmsCreationDataMemory(1))
	}
	return (*C.TPMS_CREATION_DATA)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bCreationData) Ref() *C.TPM2B_CREATION_DATA {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_CREATION_DATA)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bCreationData) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bCreationDataRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bCreationDataRef(ref unsafe.Pointer) *Tpm2bCreationData {
	return (*Tpm2bCreationData)(ref)
}

// NewTpm2bCreationData allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bCreationData() *Tpm2bCreationData {
	return (*Tpm2bCreationData)(allocTpm2bCreationDataMemory(1))
}

// allocTpm2bCreationDataMemory allocates memory for type C.TPM2B_CREATION_DATA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bCreationDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bCreationDataValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bCreationDataValue = unsafe.Sizeof([1]C.TPM2B_CREATION_DATA{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bCreationData) PassRef() *C.TPM2B_CREATION_DATA {
	if x == nil {
		x = (*Tpm2bCreationData)(allocTpm2bCreationDataMemory(1))
	}
	return (*C.TPM2B_CREATION_DATA)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsAcOutput) Ref() *C.TPMS_AC_OUTPUT {
	if x == nil {
		return nil
	}
	return (*C.TPMS_AC_OUTPUT)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsAcOutput) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsAcOutputRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsAcOutputRef(ref unsafe.Pointer) *TpmsAcOutput {
	return (*TpmsAcOutput)(ref)
}

// NewTpmsAcOutput allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsAcOutput() *TpmsAcOutput {
	return (*TpmsAcOutput)(allocTpmsAcOutputMemory(1))
}

// allocTpmsAcOutputMemory allocates memory for type C.TPMS_AC_OUTPUT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsAcOutputMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsAcOutputValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsAcOutputValue = unsafe.Sizeof([1]C.TPMS_AC_OUTPUT{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsAcOutput) PassRef() *C.TPMS_AC_OUTPUT {
	if x == nil {
		x = (*TpmsAcOutput)(allocTpmsAcOutputMemory(1))
	}
	return (*C.TPMS_AC_OUTPUT)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmlAcCapabilities) Ref() *C.TPML_AC_CAPABILITIES {
	if x == nil {
		return nil
	}
	return (*C.TPML_AC_CAPABILITIES)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmlAcCapabilities) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmlAcCapabilitiesRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmlAcCapabilitiesRef(ref unsafe.Pointer) *TpmlAcCapabilities {
	return (*TpmlAcCapabilities)(ref)
}

// NewTpmlAcCapabilities allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmlAcCapabilities() *TpmlAcCapabilities {
	return (*TpmlAcCapabilities)(allocTpmlAcCapabilitiesMemory(1))
}

// allocTpmlAcCapabilitiesMemory allocates memory for type C.TPML_AC_CAPABILITIES in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmlAcCapabilitiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmlAcCapabilitiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmlAcCapabilitiesValue = unsafe.Sizeof([1]C.TPML_AC_CAPABILITIES{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmlAcCapabilities) PassRef() *C.TPML_AC_CAPABILITIES {
	if x == nil {
		x = (*TpmlAcCapabilities)(allocTpmlAcCapabilitiesMemory(1))
	}
	return (*C.TPML_AC_CAPABILITIES)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tss2SysContext) Ref() *C.TSS2_SYS_CONTEXT {
	if x == nil {
		return nil
	}
	return (*C.TSS2_SYS_CONTEXT)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tss2SysContext) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTss2SysContextRef converts the C object reference into a raw struct reference without wrapping.
func NewTss2SysContextRef(ref unsafe.Pointer) *Tss2SysContext {
	return (*Tss2SysContext)(ref)
}

// NewTss2SysContext allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTss2SysContext() *Tss2SysContext {
	return (*Tss2SysContext)(allocTss2SysContextMemory(1))
}

// allocTss2SysContextMemory allocates memory for type C.TSS2_SYS_CONTEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTss2SysContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTss2SysContextValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTss2SysContextValue = unsafe.Sizeof([1]C.TSS2_SYS_CONTEXT{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tss2SysContext) PassRef() *C.TSS2_SYS_CONTEXT {
	if x == nil {
		x = (*Tss2SysContext)(allocTss2SysContextMemory(1))
	}
	return (*C.TSS2_SYS_CONTEXT)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tss2lSysAuthCommand) Ref() *C.TSS2L_SYS_AUTH_COMMAND {
	if x == nil {
		return nil
	}
	return (*C.TSS2L_SYS_AUTH_COMMAND)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tss2lSysAuthCommand) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTss2lSysAuthCommandRef converts the C object reference into a raw struct reference without wrapping.
func NewTss2lSysAuthCommandRef(ref unsafe.Pointer) *Tss2lSysAuthCommand {
	return (*Tss2lSysAuthCommand)(ref)
}

// NewTss2lSysAuthCommand allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTss2lSysAuthCommand() *Tss2lSysAuthCommand {
	return (*Tss2lSysAuthCommand)(allocTss2lSysAuthCommandMemory(1))
}

// allocTss2lSysAuthCommandMemory allocates memory for type C.TSS2L_SYS_AUTH_COMMAND in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTss2lSysAuthCommandMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTss2lSysAuthCommandValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTss2lSysAuthCommandValue = unsafe.Sizeof([1]C.TSS2L_SYS_AUTH_COMMAND{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tss2lSysAuthCommand) PassRef() *C.TSS2L_SYS_AUTH_COMMAND {
	if x == nil {
		x = (*Tss2lSysAuthCommand)(allocTss2lSysAuthCommandMemory(1))
	}
	return (*C.TSS2L_SYS_AUTH_COMMAND)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tss2lSysAuthResponse) Ref() *C.TSS2L_SYS_AUTH_RESPONSE {
	if x == nil {
		return nil
	}
	return (*C.TSS2L_SYS_AUTH_RESPONSE)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tss2lSysAuthResponse) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTss2lSysAuthResponseRef converts the C object reference into a raw struct reference without wrapping.
func NewTss2lSysAuthResponseRef(ref unsafe.Pointer) *Tss2lSysAuthResponse {
	return (*Tss2lSysAuthResponse)(ref)
}

// NewTss2lSysAuthResponse allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTss2lSysAuthResponse() *Tss2lSysAuthResponse {
	return (*Tss2lSysAuthResponse)(allocTss2lSysAuthResponseMemory(1))
}

// allocTss2lSysAuthResponseMemory allocates memory for type C.TSS2L_SYS_AUTH_RESPONSE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTss2lSysAuthResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTss2lSysAuthResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTss2lSysAuthResponseValue = unsafe.Sizeof([1]C.TSS2L_SYS_AUTH_RESPONSE{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tss2lSysAuthResponse) PassRef() *C.TSS2L_SYS_AUTH_RESPONSE {
	if x == nil {
		x = (*Tss2lSysAuthResponse)(allocTss2lSysAuthResponseMemory(1))
	}
	return (*C.TSS2L_SYS_AUTH_RESPONSE)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *DivT) Ref() *C.div_t {
	if x == nil {
		return nil
	}
	return (*C.div_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *DivT) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewDivTRef converts the C object reference into a raw struct reference without wrapping.
func NewDivTRef(ref unsafe.Pointer) *DivT {
	return (*DivT)(ref)
}

// NewDivT allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewDivT() *DivT {
	return (*DivT)(allocDivTMemory(1))
}

// allocDivTMemory allocates memory for type C.div_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDivTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDivTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDivTValue = unsafe.Sizeof([1]C.div_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *DivT) PassRef() *C.div_t {
	if x == nil {
		x = (*DivT)(allocDivTMemory(1))
	}
	return (*C.div_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *LdivT) Ref() *C.ldiv_t {
	if x == nil {
		return nil
	}
	return (*C.ldiv_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *LdivT) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewLdivTRef converts the C object reference into a raw struct reference without wrapping.
func NewLdivTRef(ref unsafe.Pointer) *LdivT {
	return (*LdivT)(ref)
}

// NewLdivT allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewLdivT() *LdivT {
	return (*LdivT)(allocLdivTMemory(1))
}

// allocLdivTMemory allocates memory for type C.ldiv_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocLdivTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfLdivTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfLdivTValue = unsafe.Sizeof([1]C.ldiv_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *LdivT) PassRef() *C.ldiv_t {
	if x == nil {
		x = (*LdivT)(allocLdivTMemory(1))
	}
	return (*C.ldiv_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *LldivT) Ref() *C.lldiv_t {
	if x == nil {
		return nil
	}
	return (*C.lldiv_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *LldivT) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewLldivTRef converts the C object reference into a raw struct reference without wrapping.
func NewLldivTRef(ref unsafe.Pointer) *LldivT {
	return (*LldivT)(ref)
}

// NewLldivT allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewLldivT() *LldivT {
	return (*LldivT)(allocLldivTMemory(1))
}

// allocLldivTMemory allocates memory for type C.lldiv_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocLldivTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfLldivTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfLldivTValue = unsafe.Sizeof([1]C.lldiv_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *LldivT) PassRef() *C.lldiv_t {
	if x == nil {
		x = (*LldivT)(allocLldivTMemory(1))
	}
	return (*C.lldiv_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FsidT) Ref() *C.__fsid_t {
	if x == nil {
		return nil
	}
	return (*C.__fsid_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FsidT) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFsidTRef converts the C object reference into a raw struct reference without wrapping.
func NewFsidTRef(ref unsafe.Pointer) *FsidT {
	return (*FsidT)(ref)
}

// NewFsidT allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFsidT() *FsidT {
	return (*FsidT)(alloc_FsidTMemory(1))
}

// alloc_FsidTMemory allocates memory for type C.__fsid_t in C.
// The caller is responsible for freeing the this memory via C.free.
func alloc_FsidTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOf_FsidTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOf_FsidTValue = unsafe.Sizeof([1]C.__fsid_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FsidT) PassRef() *C.__fsid_t {
	if x == nil {
		x = (*FsidT)(alloc_FsidTMemory(1))
	}
	return (*C.__fsid_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FdSet) Ref() *C.fd_set {
	if x == nil {
		return nil
	}
	return (*C.fd_set)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FdSet) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFdSetRef converts the C object reference into a raw struct reference without wrapping.
func NewFdSetRef(ref unsafe.Pointer) *FdSet {
	return (*FdSet)(ref)
}

// NewFdSet allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFdSet() *FdSet {
	return (*FdSet)(allocFdSetMemory(1))
}

// allocFdSetMemory allocates memory for type C.fd_set in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFdSetMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFdSetValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFdSetValue = unsafe.Sizeof([1]C.fd_set{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FdSet) PassRef() *C.fd_set {
	if x == nil {
		x = (*FdSet)(allocFdSetMemory(1))
	}
	return (*C.fd_set)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *SigsetT) Ref() *C.__sigset_t {
	if x == nil {
		return nil
	}
	return (*C.__sigset_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *SigsetT) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewSigsetTRef converts the C object reference into a raw struct reference without wrapping.
func NewSigsetTRef(ref unsafe.Pointer) *SigsetT {
	return (*SigsetT)(ref)
}

// NewSigsetT allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewSigsetT() *SigsetT {
	return (*SigsetT)(alloc_SigsetTMemory(1))
}

// alloc_SigsetTMemory allocates memory for type C.__sigset_t in C.
// The caller is responsible for freeing the this memory via C.free.
func alloc_SigsetTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOf_SigsetTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOf_SigsetTValue = unsafe.Sizeof([1]C.__sigset_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *SigsetT) PassRef() *C.__sigset_t {
	if x == nil {
		x = (*SigsetT)(alloc_SigsetTMemory(1))
	}
	return (*C.__sigset_t)(unsafe.Pointer(x))
}

// copyPCharBytes copies the data from Go slice as *C.char.
func copyPCharBytes(slice *sliceHeader) (*C.char, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfCharValue) * slice.Len,
		Cap:  int(sizeOfCharValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.char)(mem0), allocs
}

// allocCharMemory allocates memory for type C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCharValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCharValue = unsafe.Sizeof([1]C.char{})

func (x Tss2RcHandler) PassRef() (ref *C.TSS2_RC_HANDLER, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2RcHandlerC80E0A42Func == nil {
		tss2RcHandlerC80E0A42Func = x
	}
	return (*C.TSS2_RC_HANDLER)(C.TSS2_RC_HANDLER_c80e0a42), nil
}

func (x Tss2RcHandler) PassValue() (ref C.TSS2_RC_HANDLER, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2RcHandlerC80E0A42Func == nil {
		tss2RcHandlerC80E0A42Func = x
	}
	return (C.TSS2_RC_HANDLER)(C.TSS2_RC_HANDLER_c80e0a42), nil
}

func NewTss2RcHandlerRef(ref unsafe.Pointer) *Tss2RcHandler {
	return (*Tss2RcHandler)(ref)
}

//export tss2RcHandlerC80E0A42
func tss2RcHandlerC80E0A42(crc C.TSS2_RC) *C.char {
	if tss2RcHandlerC80E0A42Func != nil {
		rcc80e0a42 := (Tss2Rc)(crc)
		retc80e0a42 := tss2RcHandlerC80E0A42Func(rcc80e0a42)
		ret, _ := copyPCharBytes((*sliceHeader)(unsafe.Pointer(&retc80e0a42)))
		return ret
	}
	panic("callback func has not been set (race?)")
}

var tss2RcHandlerC80E0A42Func Tss2RcHandler

// Ref returns a reference to C object as it is.
func (x *ImaxdivT) Ref() *C.imaxdiv_t {
	if x == nil {
		return nil
	}
	return (*C.imaxdiv_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *ImaxdivT) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewImaxdivTRef converts the C object reference into a raw struct reference without wrapping.
func NewImaxdivTRef(ref unsafe.Pointer) *ImaxdivT {
	return (*ImaxdivT)(ref)
}

// NewImaxdivT allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewImaxdivT() *ImaxdivT {
	return (*ImaxdivT)(allocImaxdivTMemory(1))
}

// allocImaxdivTMemory allocates memory for type C.imaxdiv_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImaxdivTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImaxdivTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImaxdivTValue = unsafe.Sizeof([1]C.imaxdiv_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *ImaxdivT) PassRef() *C.imaxdiv_t {
	if x == nil {
		x = (*ImaxdivT)(allocImaxdivTMemory(1))
	}
	return (*C.imaxdiv_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Drand48Data) Ref() *C.struct_drand48_data {
	if x == nil {
		return nil
	}
	return (*C.struct_drand48_data)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Drand48Data) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewDrand48DataRef converts the C object reference into a raw struct reference without wrapping.
func NewDrand48DataRef(ref unsafe.Pointer) *Drand48Data {
	return (*Drand48Data)(ref)
}

// NewDrand48Data allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewDrand48Data() *Drand48Data {
	return (*Drand48Data)(allocStructDrand48DataMemory(1))
}

// allocStructDrand48DataMemory allocates memory for type C.struct_drand48_data in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructDrand48DataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructDrand48DataValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStructDrand48DataValue = unsafe.Sizeof([1]C.struct_drand48_data{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Drand48Data) PassRef() *C.struct_drand48_data {
	if x == nil {
		x = (*Drand48Data)(allocStructDrand48DataMemory(1))
	}
	return (*C.struct_drand48_data)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *RandomData) Ref() *C.struct_random_data {
	if x == nil {
		return nil
	}
	return (*C.struct_random_data)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *RandomData) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewRandomDataRef converts the C object reference into a raw struct reference without wrapping.
func NewRandomDataRef(ref unsafe.Pointer) *RandomData {
	return (*RandomData)(ref)
}

// NewRandomData allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewRandomData() *RandomData {
	return (*RandomData)(allocStructRandomDataMemory(1))
}

// allocStructRandomDataMemory allocates memory for type C.struct_random_data in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructRandomDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructRandomDataValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStructRandomDataValue = unsafe.Sizeof([1]C.struct_random_data{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *RandomData) PassRef() *C.struct_random_data {
	if x == nil {
		x = (*RandomData)(allocStructRandomDataMemory(1))
	}
	return (*C.struct_random_data)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Timespec) Ref() *C.struct_timespec {
	if x == nil {
		return nil
	}
	return (*C.struct_timespec)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Timespec) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTimespecRef converts the C object reference into a raw struct reference without wrapping.
func NewTimespecRef(ref unsafe.Pointer) *Timespec {
	return (*Timespec)(ref)
}

// NewTimespec allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTimespec() *Timespec {
	return (*Timespec)(allocStructTimespecMemory(1))
}

// allocStructTimespecMemory allocates memory for type C.struct_timespec in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructTimespecMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructTimespecValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStructTimespecValue = unsafe.Sizeof([1]C.struct_timespec{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Timespec) PassRef() *C.struct_timespec {
	if x == nil {
		x = (*Timespec)(allocStructTimespecMemory(1))
	}
	return (*C.struct_timespec)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Timeval) Ref() *C.struct_timeval {
	if x == nil {
		return nil
	}
	return (*C.struct_timeval)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Timeval) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTimevalRef converts the C object reference into a raw struct reference without wrapping.
func NewTimevalRef(ref unsafe.Pointer) *Timeval {
	return (*Timeval)(ref)
}

// NewTimeval allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTimeval() *Timeval {
	return (*Timeval)(allocStructTimevalMemory(1))
}

// allocStructTimevalMemory allocates memory for type C.struct_timeval in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructTimevalMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructTimevalValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStructTimevalValue = unsafe.Sizeof([1]C.struct_timeval{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Timeval) PassRef() *C.struct_timeval {
	if x == nil {
		x = (*Timeval)(allocStructTimevalMemory(1))
	}
	return (*C.struct_timeval)(unsafe.Pointer(x))
}

// allocPEsysContextMemory allocates memory for type *C.ESYS_CONTEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPEsysContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPEsysContextValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPEsysContextValue = unsafe.Sizeof([1]*C.ESYS_CONTEXT{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackArgSSEsysContext transforms a sliced Go data structure into plain C format.
func unpackArgSSEsysContext(x [][]EsysContext) (unpacked **C.ESYS_CONTEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPEsysContextMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.ESYS_CONTEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.ESYS_CONTEXT)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.ESYS_CONTEXT)(h.Data)
	return
}

// packSSEsysContext reads sliced Go data structure out from plain C format.
func packSSEsysContext(v [][]EsysContext, ptr0 **C.ESYS_CONTEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.ESYS_CONTEXT)(unsafe.Pointer(ptr0)))[i0]
		hxf058b18 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf058b18.Data = unsafe.Pointer(ptr1)
		hxf058b18.Cap = 0x7fffffff
		// hxf058b18.Len = ?
	}
}

// copyPTss2TctiContextBytes copies the data from Go slice as *C.TSS2_TCTI_CONTEXT.
func copyPTss2TctiContextBytes(slice *sliceHeader) (*C.TSS2_TCTI_CONTEXT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTss2TctiContextValue) * slice.Len,
		Cap:  int(sizeOfTss2TctiContextValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TSS2_TCTI_CONTEXT)(mem0), allocs
}

// copyPTss2AbiVersionBytes copies the data from Go slice as *C.TSS2_ABI_VERSION.
func copyPTss2AbiVersionBytes(slice *sliceHeader) (*C.TSS2_ABI_VERSION, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTss2AbiVersionValue) * slice.Len,
		Cap:  int(sizeOfTss2AbiVersionValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TSS2_ABI_VERSION)(mem0), allocs
}

// copyPEsysContextBytes copies the data from Go slice as *C.ESYS_CONTEXT.
func copyPEsysContextBytes(slice *sliceHeader) (*C.ESYS_CONTEXT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfEsysContextValue) * slice.Len,
		Cap:  int(sizeOfEsysContextValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.ESYS_CONTEXT)(mem0), allocs
}

// allocPTss2TctiContextMemory allocates memory for type *C.TSS2_TCTI_CONTEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTss2TctiContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTss2TctiContextValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTss2TctiContextValue = unsafe.Sizeof([1]*C.TSS2_TCTI_CONTEXT{})

// unpackArgSSTss2TctiContext transforms a sliced Go data structure into plain C format.
func unpackArgSSTss2TctiContext(x [][]Tss2TctiContext) (unpacked **C.TSS2_TCTI_CONTEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTss2TctiContextMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TSS2_TCTI_CONTEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.TSS2_TCTI_CONTEXT)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TSS2_TCTI_CONTEXT)(h.Data)
	return
}

// packSSTss2TctiContext reads sliced Go data structure out from plain C format.
func packSSTss2TctiContext(v [][]Tss2TctiContext, ptr0 **C.TSS2_TCTI_CONTEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TSS2_TCTI_CONTEXT)(unsafe.Pointer(ptr0)))[i0]
		hxf5fa529 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf5fa529.Data = unsafe.Pointer(ptr1)
		hxf5fa529.Cap = 0x7fffffff
		// hxf5fa529.Len = ?
	}
}

// copyPTss2TctiPollHandleBytes copies the data from Go slice as *C.TSS2_TCTI_POLL_HANDLE.
func copyPTss2TctiPollHandleBytes(slice *sliceHeader) (*C.TSS2_TCTI_POLL_HANDLE, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTss2TctiPollHandleValue) * slice.Len,
		Cap:  int(sizeOfTss2TctiPollHandleValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TSS2_TCTI_POLL_HANDLE)(mem0), allocs
}

// allocTss2TctiPollHandleMemory allocates memory for type C.TSS2_TCTI_POLL_HANDLE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTss2TctiPollHandleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTss2TctiPollHandleValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTss2TctiPollHandleValue = unsafe.Sizeof([1]C.TSS2_TCTI_POLL_HANDLE{})

// copyPSizeTBytes copies the data from Go slice as *C.size_t.
func copyPSizeTBytes(slice *sliceHeader) (*C.size_t, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfSizeTValue) * slice.Len,
		Cap:  int(sizeOfSizeTValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.size_t)(mem0), allocs
}

// allocSizeTMemory allocates memory for type C.size_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSizeTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSizeTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSizeTValue = unsafe.Sizeof([1]C.size_t{})

// allocPUint8TMemory allocates memory for type *C.uint8_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPUint8TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPUint8TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPUint8TValue = unsafe.Sizeof([1]*C.uint8_t{})

// unpackArgSSUint8T transforms a sliced Go data structure into plain C format.
func unpackArgSSUint8T(x [][]Uint8T) (unpacked **C.uint8_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPUint8TMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.uint8_t)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.uint8_t)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.uint8_t)(h.Data)
	return
}

// packSSUint8T reads sliced Go data structure out from plain C format.
func packSSUint8T(v [][]Uint8T, ptr0 **C.uint8_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.uint8_t)(unsafe.Pointer(ptr0)))[i0]
		hxf21690b := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf21690b.Data = unsafe.Pointer(ptr1)
		hxf21690b.Cap = 0x7fffffff
		// hxf21690b.Len = ?
	}
}

// copyPUint8TBytes copies the data from Go slice as *C.uint8_t.
func copyPUint8TBytes(slice *sliceHeader) (*C.uint8_t, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfUint8TValue) * slice.Len,
		Cap:  int(sizeOfUint8TValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.uint8_t)(mem0), allocs
}

// allocUint8TMemory allocates memory for type C.uint8_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUint8TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUint8TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUint8TValue = unsafe.Sizeof([1]C.uint8_t{})

// copyPEsysTrBytes copies the data from Go slice as *C.ESYS_TR.
func copyPEsysTrBytes(slice *sliceHeader) (*C.ESYS_TR, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfEsysTrValue) * slice.Len,
		Cap:  int(sizeOfEsysTrValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.ESYS_TR)(mem0), allocs
}

// allocEsysTrMemory allocates memory for type C.ESYS_TR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocEsysTrMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfEsysTrValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfEsysTrValue = unsafe.Sizeof([1]C.ESYS_TR{})

// copyPTpm2bAuthBytes copies the data from Go slice as *C.TPM2B_AUTH.
func copyPTpm2bAuthBytes(slice *sliceHeader) (*C.TPM2B_AUTH, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2bAuthValue) * slice.Len,
		Cap:  int(sizeOfTpm2bAuthValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2B_AUTH)(mem0), allocs
}

// allocTpm2bAuthMemory allocates memory for type C.TPM2B_AUTH in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bAuthMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bAuthValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bAuthValue = unsafe.Sizeof([1]C.TPM2B_AUTH{})

// allocPTpm2bNameMemory allocates memory for type *C.TPM2B_NAME in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpm2bNameMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpm2bNameValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpm2bNameValue = unsafe.Sizeof([1]*C.TPM2B_NAME{})

// unpackArgSSTpm2bName transforms a sliced Go data structure into plain C format.
func unpackArgSSTpm2bName(x [][]Tpm2bName) (unpacked **C.TPM2B_NAME, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpm2bNameMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPM2B_NAME)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpm2bNameMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPM2B_NAME)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPM2B_NAME)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPM2B_NAME)(h.Data)
	return
}

// packSSTpm2bName reads sliced Go data structure out from plain C format.
func packSSTpm2bName(v [][]Tpm2bName, ptr0 **C.TPM2B_NAME) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPM2B_NAME)(unsafe.Pointer(ptr0)))[i0]
		hxf1231c9 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf1231c9.Data = unsafe.Pointer(ptr1)
		hxf1231c9.Cap = 0x7fffffff
		// hxf1231c9.Len = ?
	}
}

// copyPTpmaSessionBytes copies the data from Go slice as *C.TPMA_SESSION.
func copyPTpmaSessionBytes(slice *sliceHeader) (*C.TPMA_SESSION, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmaSessionValue) * slice.Len,
		Cap:  int(sizeOfTpmaSessionValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMA_SESSION)(mem0), allocs
}

// allocTpmaSessionMemory allocates memory for type C.TPMA_SESSION in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmaSessionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmaSessionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmaSessionValue = unsafe.Sizeof([1]C.TPMA_SESSION{})

// allocPTpm2bNonceMemory allocates memory for type *C.TPM2B_NONCE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpm2bNonceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpm2bNonceValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpm2bNonceValue = unsafe.Sizeof([1]*C.TPM2B_NONCE{})

// allocTpm2bNonceMemory allocates memory for type C.TPM2B_NONCE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bNonceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bNonceValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bNonceValue = unsafe.Sizeof([1]C.TPM2B_NONCE{})

// unpackArgSSTpm2bNonce transforms a sliced Go data structure into plain C format.
func unpackArgSSTpm2bNonce(x [][]Tpm2bNonce) (unpacked **C.TPM2B_NONCE, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpm2bNonceMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPM2B_NONCE)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpm2bNonceMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPM2B_NONCE)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPM2B_NONCE)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPM2B_NONCE)(h.Data)
	return
}

// packSSTpm2bNonce reads sliced Go data structure out from plain C format.
func packSSTpm2bNonce(v [][]Tpm2bNonce, ptr0 **C.TPM2B_NONCE) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPM2B_NONCE)(unsafe.Pointer(ptr0)))[i0]
		hxf04b15b := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf04b15b.Data = unsafe.Pointer(ptr1)
		hxf04b15b.Cap = 0x7fffffff
		// hxf04b15b.Len = ?
	}
}

// copyPTpmlAlgBytes copies the data from Go slice as *C.TPML_ALG.
func copyPTpmlAlgBytes(slice *sliceHeader) (*C.TPML_ALG, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmlAlgValue) * slice.Len,
		Cap:  int(sizeOfTpmlAlgValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPML_ALG)(mem0), allocs
}

// allocPTpmlAlgMemory allocates memory for type *C.TPML_ALG in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpmlAlgMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpmlAlgValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpmlAlgValue = unsafe.Sizeof([1]*C.TPML_ALG{})

// unpackArgSSTpmlAlg transforms a sliced Go data structure into plain C format.
func unpackArgSSTpmlAlg(x [][]TpmlAlg) (unpacked **C.TPML_ALG, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpmlAlgMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPML_ALG)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpmlAlgMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPML_ALG)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPML_ALG)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPML_ALG)(h.Data)
	return
}

// packSSTpmlAlg reads sliced Go data structure out from plain C format.
func packSSTpmlAlg(v [][]TpmlAlg, ptr0 **C.TPML_ALG) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPML_ALG)(unsafe.Pointer(ptr0)))[i0]
		hxf2f888b := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf2f888b.Data = unsafe.Pointer(ptr1)
		hxf2f888b.Cap = 0x7fffffff
		// hxf2f888b.Len = ?
	}
}

// allocPTpm2bMaxBufferMemory allocates memory for type *C.TPM2B_MAX_BUFFER in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpm2bMaxBufferMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpm2bMaxBufferValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpm2bMaxBufferValue = unsafe.Sizeof([1]*C.TPM2B_MAX_BUFFER{})

// unpackArgSSTpm2bMaxBuffer transforms a sliced Go data structure into plain C format.
func unpackArgSSTpm2bMaxBuffer(x [][]Tpm2bMaxBuffer) (unpacked **C.TPM2B_MAX_BUFFER, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpm2bMaxBufferMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPM2B_MAX_BUFFER)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpm2bMaxBufferMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPM2B_MAX_BUFFER)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPM2B_MAX_BUFFER)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPM2B_MAX_BUFFER)(h.Data)
	return
}

// packSSTpm2bMaxBuffer reads sliced Go data structure out from plain C format.
func packSSTpm2bMaxBuffer(v [][]Tpm2bMaxBuffer, ptr0 **C.TPM2B_MAX_BUFFER) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPM2B_MAX_BUFFER)(unsafe.Pointer(ptr0)))[i0]
		hxfe53d34 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxfe53d34.Data = unsafe.Pointer(ptr1)
		hxfe53d34.Cap = 0x7fffffff
		// hxfe53d34.Len = ?
	}
}

// copyPTpm2RcBytes copies the data from Go slice as *C.TPM2_RC.
func copyPTpm2RcBytes(slice *sliceHeader) (*C.TPM2_RC, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2RcValue) * slice.Len,
		Cap:  int(sizeOfTpm2RcValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2_RC)(mem0), allocs
}

// allocTpm2RcMemory allocates memory for type C.TPM2_RC in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2RcMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2RcValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2RcValue = unsafe.Sizeof([1]C.TPM2_RC{})

// copyPTpm2bNonceBytes copies the data from Go slice as *C.TPM2B_NONCE.
func copyPTpm2bNonceBytes(slice *sliceHeader) (*C.TPM2B_NONCE, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2bNonceValue) * slice.Len,
		Cap:  int(sizeOfTpm2bNonceValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2B_NONCE)(mem0), allocs
}

// copyPTpmtSymDefBytes copies the data from Go slice as *C.TPMT_SYM_DEF.
func copyPTpmtSymDefBytes(slice *sliceHeader) (*C.TPMT_SYM_DEF, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmtSymDefValue) * slice.Len,
		Cap:  int(sizeOfTpmtSymDefValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMT_SYM_DEF)(mem0), allocs
}

// copyPTpm2bSensitiveCreateBytes copies the data from Go slice as *C.TPM2B_SENSITIVE_CREATE.
func copyPTpm2bSensitiveCreateBytes(slice *sliceHeader) (*C.TPM2B_SENSITIVE_CREATE, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2bSensitiveCreateValue) * slice.Len,
		Cap:  int(sizeOfTpm2bSensitiveCreateValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2B_SENSITIVE_CREATE)(mem0), allocs
}

// copyPTpm2bPublicBytes copies the data from Go slice as *C.TPM2B_PUBLIC.
func copyPTpm2bPublicBytes(slice *sliceHeader) (*C.TPM2B_PUBLIC, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2bPublicValue) * slice.Len,
		Cap:  int(sizeOfTpm2bPublicValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2B_PUBLIC)(mem0), allocs
}

// copyPTpm2bDataBytes copies the data from Go slice as *C.TPM2B_DATA.
func copyPTpm2bDataBytes(slice *sliceHeader) (*C.TPM2B_DATA, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2bDataValue) * slice.Len,
		Cap:  int(sizeOfTpm2bDataValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2B_DATA)(mem0), allocs
}

// copyPTpmlPcrSelectionBytes copies the data from Go slice as *C.TPML_PCR_SELECTION.
func copyPTpmlPcrSelectionBytes(slice *sliceHeader) (*C.TPML_PCR_SELECTION, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmlPcrSelectionValue) * slice.Len,
		Cap:  int(sizeOfTpmlPcrSelectionValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPML_PCR_SELECTION)(mem0), allocs
}

// allocPTpm2bPrivateMemory allocates memory for type *C.TPM2B_PRIVATE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpm2bPrivateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpm2bPrivateValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpm2bPrivateValue = unsafe.Sizeof([1]*C.TPM2B_PRIVATE{})

// unpackArgSSTpm2bPrivate transforms a sliced Go data structure into plain C format.
func unpackArgSSTpm2bPrivate(x [][]Tpm2bPrivate) (unpacked **C.TPM2B_PRIVATE, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpm2bPrivateMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPM2B_PRIVATE)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpm2bPrivateMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPM2B_PRIVATE)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPM2B_PRIVATE)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPM2B_PRIVATE)(h.Data)
	return
}

// packSSTpm2bPrivate reads sliced Go data structure out from plain C format.
func packSSTpm2bPrivate(v [][]Tpm2bPrivate, ptr0 **C.TPM2B_PRIVATE) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPM2B_PRIVATE)(unsafe.Pointer(ptr0)))[i0]
		hxf5ebb88 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf5ebb88.Data = unsafe.Pointer(ptr1)
		hxf5ebb88.Cap = 0x7fffffff
		// hxf5ebb88.Len = ?
	}
}

// allocPTpm2bPublicMemory allocates memory for type *C.TPM2B_PUBLIC in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpm2bPublicMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpm2bPublicValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpm2bPublicValue = unsafe.Sizeof([1]*C.TPM2B_PUBLIC{})

// unpackArgSSTpm2bPublic transforms a sliced Go data structure into plain C format.
func unpackArgSSTpm2bPublic(x [][]Tpm2bPublic) (unpacked **C.TPM2B_PUBLIC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpm2bPublicMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPM2B_PUBLIC)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpm2bPublicMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPM2B_PUBLIC)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPM2B_PUBLIC)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPM2B_PUBLIC)(h.Data)
	return
}

// packSSTpm2bPublic reads sliced Go data structure out from plain C format.
func packSSTpm2bPublic(v [][]Tpm2bPublic, ptr0 **C.TPM2B_PUBLIC) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPM2B_PUBLIC)(unsafe.Pointer(ptr0)))[i0]
		hxff20e84 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxff20e84.Data = unsafe.Pointer(ptr1)
		hxff20e84.Cap = 0x7fffffff
		// hxff20e84.Len = ?
	}
}

// allocPTpm2bCreationDataMemory allocates memory for type *C.TPM2B_CREATION_DATA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpm2bCreationDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpm2bCreationDataValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpm2bCreationDataValue = unsafe.Sizeof([1]*C.TPM2B_CREATION_DATA{})

// unpackArgSSTpm2bCreationData transforms a sliced Go data structure into plain C format.
func unpackArgSSTpm2bCreationData(x [][]Tpm2bCreationData) (unpacked **C.TPM2B_CREATION_DATA, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpm2bCreationDataMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPM2B_CREATION_DATA)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpm2bCreationDataMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPM2B_CREATION_DATA)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPM2B_CREATION_DATA)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPM2B_CREATION_DATA)(h.Data)
	return
}

// packSSTpm2bCreationData reads sliced Go data structure out from plain C format.
func packSSTpm2bCreationData(v [][]Tpm2bCreationData, ptr0 **C.TPM2B_CREATION_DATA) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPM2B_CREATION_DATA)(unsafe.Pointer(ptr0)))[i0]
		hxfa26a4d := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxfa26a4d.Data = unsafe.Pointer(ptr1)
		hxfa26a4d.Cap = 0x7fffffff
		// hxfa26a4d.Len = ?
	}
}

// allocPTpm2bDigestMemory allocates memory for type *C.TPM2B_DIGEST in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpm2bDigestMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpm2bDigestValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpm2bDigestValue = unsafe.Sizeof([1]*C.TPM2B_DIGEST{})

// unpackArgSSTpm2bDigest transforms a sliced Go data structure into plain C format.
func unpackArgSSTpm2bDigest(x [][]Tpm2bDigest) (unpacked **C.TPM2B_DIGEST, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpm2bDigestMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPM2B_DIGEST)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpm2bDigestMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPM2B_DIGEST)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPM2B_DIGEST)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPM2B_DIGEST)(h.Data)
	return
}

// packSSTpm2bDigest reads sliced Go data structure out from plain C format.
func packSSTpm2bDigest(v [][]Tpm2bDigest, ptr0 **C.TPM2B_DIGEST) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPM2B_DIGEST)(unsafe.Pointer(ptr0)))[i0]
		hxfe48098 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxfe48098.Data = unsafe.Pointer(ptr1)
		hxfe48098.Cap = 0x7fffffff
		// hxfe48098.Len = ?
	}
}

// allocPTpmtTkCreationMemory allocates memory for type *C.TPMT_TK_CREATION in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpmtTkCreationMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpmtTkCreationValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpmtTkCreationValue = unsafe.Sizeof([1]*C.TPMT_TK_CREATION{})

// unpackArgSSTpmtTkCreation transforms a sliced Go data structure into plain C format.
func unpackArgSSTpmtTkCreation(x [][]TpmtTkCreation) (unpacked **C.TPMT_TK_CREATION, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpmtTkCreationMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPMT_TK_CREATION)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpmtTkCreationMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPMT_TK_CREATION)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPMT_TK_CREATION)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPMT_TK_CREATION)(h.Data)
	return
}

// packSSTpmtTkCreation reads sliced Go data structure out from plain C format.
func packSSTpmtTkCreation(v [][]TpmtTkCreation, ptr0 **C.TPMT_TK_CREATION) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPMT_TK_CREATION)(unsafe.Pointer(ptr0)))[i0]
		hxffe3496 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxffe3496.Data = unsafe.Pointer(ptr1)
		hxffe3496.Cap = 0x7fffffff
		// hxffe3496.Len = ?
	}
}

// copyPTpm2bPrivateBytes copies the data from Go slice as *C.TPM2B_PRIVATE.
func copyPTpm2bPrivateBytes(slice *sliceHeader) (*C.TPM2B_PRIVATE, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2bPrivateValue) * slice.Len,
		Cap:  int(sizeOfTpm2bPrivateValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2B_PRIVATE)(mem0), allocs
}

// copyPTpm2bSensitiveBytes copies the data from Go slice as *C.TPM2B_SENSITIVE.
func copyPTpm2bSensitiveBytes(slice *sliceHeader) (*C.TPM2B_SENSITIVE, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2bSensitiveValue) * slice.Len,
		Cap:  int(sizeOfTpm2bSensitiveValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2B_SENSITIVE)(mem0), allocs
}

// copyPTpm2bIdObjectBytes copies the data from Go slice as *C.TPM2B_ID_OBJECT.
func copyPTpm2bIdObjectBytes(slice *sliceHeader) (*C.TPM2B_ID_OBJECT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2bIdObjectValue) * slice.Len,
		Cap:  int(sizeOfTpm2bIdObjectValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2B_ID_OBJECT)(mem0), allocs
}

// copyPTpm2bEncryptedSecretBytes copies the data from Go slice as *C.TPM2B_ENCRYPTED_SECRET.
func copyPTpm2bEncryptedSecretBytes(slice *sliceHeader) (*C.TPM2B_ENCRYPTED_SECRET, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2bEncryptedSecretValue) * slice.Len,
		Cap:  int(sizeOfTpm2bEncryptedSecretValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2B_ENCRYPTED_SECRET)(mem0), allocs
}

// copyPTpm2bDigestBytes copies the data from Go slice as *C.TPM2B_DIGEST.
func copyPTpm2bDigestBytes(slice *sliceHeader) (*C.TPM2B_DIGEST, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2bDigestValue) * slice.Len,
		Cap:  int(sizeOfTpm2bDigestValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2B_DIGEST)(mem0), allocs
}

// copyPTpm2bNameBytes copies the data from Go slice as *C.TPM2B_NAME.
func copyPTpm2bNameBytes(slice *sliceHeader) (*C.TPM2B_NAME, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2bNameValue) * slice.Len,
		Cap:  int(sizeOfTpm2bNameValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2B_NAME)(mem0), allocs
}

// allocPTpm2bIdObjectMemory allocates memory for type *C.TPM2B_ID_OBJECT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpm2bIdObjectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpm2bIdObjectValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpm2bIdObjectValue = unsafe.Sizeof([1]*C.TPM2B_ID_OBJECT{})

// unpackArgSSTpm2bIdObject transforms a sliced Go data structure into plain C format.
func unpackArgSSTpm2bIdObject(x [][]Tpm2bIdObject) (unpacked **C.TPM2B_ID_OBJECT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpm2bIdObjectMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPM2B_ID_OBJECT)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpm2bIdObjectMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPM2B_ID_OBJECT)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPM2B_ID_OBJECT)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPM2B_ID_OBJECT)(h.Data)
	return
}

// packSSTpm2bIdObject reads sliced Go data structure out from plain C format.
func packSSTpm2bIdObject(v [][]Tpm2bIdObject, ptr0 **C.TPM2B_ID_OBJECT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPM2B_ID_OBJECT)(unsafe.Pointer(ptr0)))[i0]
		hxf44d909 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf44d909.Data = unsafe.Pointer(ptr1)
		hxf44d909.Cap = 0x7fffffff
		// hxf44d909.Len = ?
	}
}

// allocPTpm2bEncryptedSecretMemory allocates memory for type *C.TPM2B_ENCRYPTED_SECRET in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpm2bEncryptedSecretMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpm2bEncryptedSecretValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpm2bEncryptedSecretValue = unsafe.Sizeof([1]*C.TPM2B_ENCRYPTED_SECRET{})

// unpackArgSSTpm2bEncryptedSecret transforms a sliced Go data structure into plain C format.
func unpackArgSSTpm2bEncryptedSecret(x [][]Tpm2bEncryptedSecret) (unpacked **C.TPM2B_ENCRYPTED_SECRET, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpm2bEncryptedSecretMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPM2B_ENCRYPTED_SECRET)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpm2bEncryptedSecretMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPM2B_ENCRYPTED_SECRET)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPM2B_ENCRYPTED_SECRET)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPM2B_ENCRYPTED_SECRET)(h.Data)
	return
}

// packSSTpm2bEncryptedSecret reads sliced Go data structure out from plain C format.
func packSSTpm2bEncryptedSecret(v [][]Tpm2bEncryptedSecret, ptr0 **C.TPM2B_ENCRYPTED_SECRET) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPM2B_ENCRYPTED_SECRET)(unsafe.Pointer(ptr0)))[i0]
		hxfa835e7 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxfa835e7.Data = unsafe.Pointer(ptr1)
		hxfa835e7.Cap = 0x7fffffff
		// hxfa835e7.Len = ?
	}
}

// allocPTpm2bSensitiveDataMemory allocates memory for type *C.TPM2B_SENSITIVE_DATA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpm2bSensitiveDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpm2bSensitiveDataValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpm2bSensitiveDataValue = unsafe.Sizeof([1]*C.TPM2B_SENSITIVE_DATA{})

// unpackArgSSTpm2bSensitiveData transforms a sliced Go data structure into plain C format.
func unpackArgSSTpm2bSensitiveData(x [][]Tpm2bSensitiveData) (unpacked **C.TPM2B_SENSITIVE_DATA, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpm2bSensitiveDataMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPM2B_SENSITIVE_DATA)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpm2bSensitiveDataMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPM2B_SENSITIVE_DATA)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPM2B_SENSITIVE_DATA)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPM2B_SENSITIVE_DATA)(h.Data)
	return
}

// packSSTpm2bSensitiveData reads sliced Go data structure out from plain C format.
func packSSTpm2bSensitiveData(v [][]Tpm2bSensitiveData, ptr0 **C.TPM2B_SENSITIVE_DATA) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPM2B_SENSITIVE_DATA)(unsafe.Pointer(ptr0)))[i0]
		hxf458096 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf458096.Data = unsafe.Pointer(ptr1)
		hxf458096.Cap = 0x7fffffff
		// hxf458096.Len = ?
	}
}

// copyPTpm2bTemplateBytes copies the data from Go slice as *C.TPM2B_TEMPLATE.
func copyPTpm2bTemplateBytes(slice *sliceHeader) (*C.TPM2B_TEMPLATE, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2bTemplateValue) * slice.Len,
		Cap:  int(sizeOfTpm2bTemplateValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2B_TEMPLATE)(mem0), allocs
}

// copyPTpmtSymDefObjectBytes copies the data from Go slice as *C.TPMT_SYM_DEF_OBJECT.
func copyPTpmtSymDefObjectBytes(slice *sliceHeader) (*C.TPMT_SYM_DEF_OBJECT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmtSymDefObjectValue) * slice.Len,
		Cap:  int(sizeOfTpmtSymDefObjectValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMT_SYM_DEF_OBJECT)(mem0), allocs
}

// allocPTpm2bDataMemory allocates memory for type *C.TPM2B_DATA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpm2bDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpm2bDataValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpm2bDataValue = unsafe.Sizeof([1]*C.TPM2B_DATA{})

// unpackArgSSTpm2bData transforms a sliced Go data structure into plain C format.
func unpackArgSSTpm2bData(x [][]Tpm2bData) (unpacked **C.TPM2B_DATA, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpm2bDataMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPM2B_DATA)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpm2bDataMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPM2B_DATA)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPM2B_DATA)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPM2B_DATA)(h.Data)
	return
}

// packSSTpm2bData reads sliced Go data structure out from plain C format.
func packSSTpm2bData(v [][]Tpm2bData, ptr0 **C.TPM2B_DATA) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPM2B_DATA)(unsafe.Pointer(ptr0)))[i0]
		hxf9b1633 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf9b1633.Data = unsafe.Pointer(ptr1)
		hxf9b1633.Cap = 0x7fffffff
		// hxf9b1633.Len = ?
	}
}

// copyPTpm2bPublicKeyRsaBytes copies the data from Go slice as *C.TPM2B_PUBLIC_KEY_RSA.
func copyPTpm2bPublicKeyRsaBytes(slice *sliceHeader) (*C.TPM2B_PUBLIC_KEY_RSA, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2bPublicKeyRsaValue) * slice.Len,
		Cap:  int(sizeOfTpm2bPublicKeyRsaValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2B_PUBLIC_KEY_RSA)(mem0), allocs
}

// copyPTpmtRsaDecryptBytes copies the data from Go slice as *C.TPMT_RSA_DECRYPT.
func copyPTpmtRsaDecryptBytes(slice *sliceHeader) (*C.TPMT_RSA_DECRYPT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmtRsaDecryptValue) * slice.Len,
		Cap:  int(sizeOfTpmtRsaDecryptValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMT_RSA_DECRYPT)(mem0), allocs
}

// allocPTpm2bPublicKeyRsaMemory allocates memory for type *C.TPM2B_PUBLIC_KEY_RSA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpm2bPublicKeyRsaMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpm2bPublicKeyRsaValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpm2bPublicKeyRsaValue = unsafe.Sizeof([1]*C.TPM2B_PUBLIC_KEY_RSA{})

// unpackArgSSTpm2bPublicKeyRsa transforms a sliced Go data structure into plain C format.
func unpackArgSSTpm2bPublicKeyRsa(x [][]Tpm2bPublicKeyRsa) (unpacked **C.TPM2B_PUBLIC_KEY_RSA, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpm2bPublicKeyRsaMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPM2B_PUBLIC_KEY_RSA)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpm2bPublicKeyRsaMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPM2B_PUBLIC_KEY_RSA)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPM2B_PUBLIC_KEY_RSA)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPM2B_PUBLIC_KEY_RSA)(h.Data)
	return
}

// packSSTpm2bPublicKeyRsa reads sliced Go data structure out from plain C format.
func packSSTpm2bPublicKeyRsa(v [][]Tpm2bPublicKeyRsa, ptr0 **C.TPM2B_PUBLIC_KEY_RSA) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPM2B_PUBLIC_KEY_RSA)(unsafe.Pointer(ptr0)))[i0]
		hxfb2f596 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxfb2f596.Data = unsafe.Pointer(ptr1)
		hxfb2f596.Cap = 0x7fffffff
		// hxfb2f596.Len = ?
	}
}

// allocPTpm2bEccPointMemory allocates memory for type *C.TPM2B_ECC_POINT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpm2bEccPointMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpm2bEccPointValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpm2bEccPointValue = unsafe.Sizeof([1]*C.TPM2B_ECC_POINT{})

// unpackArgSSTpm2bEccPoint transforms a sliced Go data structure into plain C format.
func unpackArgSSTpm2bEccPoint(x [][]Tpm2bEccPoint) (unpacked **C.TPM2B_ECC_POINT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpm2bEccPointMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPM2B_ECC_POINT)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpm2bEccPointMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPM2B_ECC_POINT)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPM2B_ECC_POINT)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPM2B_ECC_POINT)(h.Data)
	return
}

// packSSTpm2bEccPoint reads sliced Go data structure out from plain C format.
func packSSTpm2bEccPoint(v [][]Tpm2bEccPoint, ptr0 **C.TPM2B_ECC_POINT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPM2B_ECC_POINT)(unsafe.Pointer(ptr0)))[i0]
		hxff6a91e := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxff6a91e.Data = unsafe.Pointer(ptr1)
		hxff6a91e.Cap = 0x7fffffff
		// hxff6a91e.Len = ?
	}
}

// copyPTpm2bEccPointBytes copies the data from Go slice as *C.TPM2B_ECC_POINT.
func copyPTpm2bEccPointBytes(slice *sliceHeader) (*C.TPM2B_ECC_POINT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2bEccPointValue) * slice.Len,
		Cap:  int(sizeOfTpm2bEccPointValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2B_ECC_POINT)(mem0), allocs
}

// allocPTpmsAlgorithmDetailEccMemory allocates memory for type *C.TPMS_ALGORITHM_DETAIL_ECC in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpmsAlgorithmDetailEccMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpmsAlgorithmDetailEccValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpmsAlgorithmDetailEccValue = unsafe.Sizeof([1]*C.TPMS_ALGORITHM_DETAIL_ECC{})

// unpackArgSSTpmsAlgorithmDetailEcc transforms a sliced Go data structure into plain C format.
func unpackArgSSTpmsAlgorithmDetailEcc(x [][]TpmsAlgorithmDetailEcc) (unpacked **C.TPMS_ALGORITHM_DETAIL_ECC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpmsAlgorithmDetailEccMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPMS_ALGORITHM_DETAIL_ECC)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpmsAlgorithmDetailEccMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPMS_ALGORITHM_DETAIL_ECC)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPMS_ALGORITHM_DETAIL_ECC)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPMS_ALGORITHM_DETAIL_ECC)(h.Data)
	return
}

// packSSTpmsAlgorithmDetailEcc reads sliced Go data structure out from plain C format.
func packSSTpmsAlgorithmDetailEcc(v [][]TpmsAlgorithmDetailEcc, ptr0 **C.TPMS_ALGORITHM_DETAIL_ECC) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPMS_ALGORITHM_DETAIL_ECC)(unsafe.Pointer(ptr0)))[i0]
		hxfbb2d22 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxfbb2d22.Data = unsafe.Pointer(ptr1)
		hxfbb2d22.Cap = 0x7fffffff
		// hxfbb2d22.Len = ?
	}
}

// copyPTpm2bIvBytes copies the data from Go slice as *C.TPM2B_IV.
func copyPTpm2bIvBytes(slice *sliceHeader) (*C.TPM2B_IV, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2bIvValue) * slice.Len,
		Cap:  int(sizeOfTpm2bIvValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2B_IV)(mem0), allocs
}

// copyPTpm2bMaxBufferBytes copies the data from Go slice as *C.TPM2B_MAX_BUFFER.
func copyPTpm2bMaxBufferBytes(slice *sliceHeader) (*C.TPM2B_MAX_BUFFER, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2bMaxBufferValue) * slice.Len,
		Cap:  int(sizeOfTpm2bMaxBufferValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2B_MAX_BUFFER)(mem0), allocs
}

// allocPTpm2bIvMemory allocates memory for type *C.TPM2B_IV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpm2bIvMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpm2bIvValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpm2bIvValue = unsafe.Sizeof([1]*C.TPM2B_IV{})

// unpackArgSSTpm2bIv transforms a sliced Go data structure into plain C format.
func unpackArgSSTpm2bIv(x [][]Tpm2bIv) (unpacked **C.TPM2B_IV, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpm2bIvMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPM2B_IV)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpm2bIvMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPM2B_IV)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPM2B_IV)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPM2B_IV)(h.Data)
	return
}

// packSSTpm2bIv reads sliced Go data structure out from plain C format.
func packSSTpm2bIv(v [][]Tpm2bIv, ptr0 **C.TPM2B_IV) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPM2B_IV)(unsafe.Pointer(ptr0)))[i0]
		hxf13e50a := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf13e50a.Data = unsafe.Pointer(ptr1)
		hxf13e50a.Cap = 0x7fffffff
		// hxf13e50a.Len = ?
	}
}

// allocPTpmtTkHashcheckMemory allocates memory for type *C.TPMT_TK_HASHCHECK in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpmtTkHashcheckMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpmtTkHashcheckValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpmtTkHashcheckValue = unsafe.Sizeof([1]*C.TPMT_TK_HASHCHECK{})

// unpackArgSSTpmtTkHashcheck transforms a sliced Go data structure into plain C format.
func unpackArgSSTpmtTkHashcheck(x [][]TpmtTkHashcheck) (unpacked **C.TPMT_TK_HASHCHECK, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpmtTkHashcheckMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPMT_TK_HASHCHECK)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpmtTkHashcheckMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPMT_TK_HASHCHECK)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPMT_TK_HASHCHECK)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPMT_TK_HASHCHECK)(h.Data)
	return
}

// packSSTpmtTkHashcheck reads sliced Go data structure out from plain C format.
func packSSTpmtTkHashcheck(v [][]TpmtTkHashcheck, ptr0 **C.TPMT_TK_HASHCHECK) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPMT_TK_HASHCHECK)(unsafe.Pointer(ptr0)))[i0]
		hxf349858 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf349858.Data = unsafe.Pointer(ptr1)
		hxf349858.Cap = 0x7fffffff
		// hxf349858.Len = ?
	}
}

// copyPTpm2bSensitiveDataBytes copies the data from Go slice as *C.TPM2B_SENSITIVE_DATA.
func copyPTpm2bSensitiveDataBytes(slice *sliceHeader) (*C.TPM2B_SENSITIVE_DATA, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2bSensitiveDataValue) * slice.Len,
		Cap:  int(sizeOfTpm2bSensitiveDataValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2B_SENSITIVE_DATA)(mem0), allocs
}

// allocPTpmlDigestValuesMemory allocates memory for type *C.TPML_DIGEST_VALUES in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpmlDigestValuesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpmlDigestValuesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpmlDigestValuesValue = unsafe.Sizeof([1]*C.TPML_DIGEST_VALUES{})

// unpackArgSSTpmlDigestValues transforms a sliced Go data structure into plain C format.
func unpackArgSSTpmlDigestValues(x [][]TpmlDigestValues) (unpacked **C.TPML_DIGEST_VALUES, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpmlDigestValuesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPML_DIGEST_VALUES)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpmlDigestValuesMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPML_DIGEST_VALUES)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPML_DIGEST_VALUES)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPML_DIGEST_VALUES)(h.Data)
	return
}

// packSSTpmlDigestValues reads sliced Go data structure out from plain C format.
func packSSTpmlDigestValues(v [][]TpmlDigestValues, ptr0 **C.TPML_DIGEST_VALUES) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPML_DIGEST_VALUES)(unsafe.Pointer(ptr0)))[i0]
		hxf9cdd70 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf9cdd70.Data = unsafe.Pointer(ptr1)
		hxf9cdd70.Cap = 0x7fffffff
		// hxf9cdd70.Len = ?
	}
}

// copyPTpmtSigSchemeBytes copies the data from Go slice as *C.TPMT_SIG_SCHEME.
func copyPTpmtSigSchemeBytes(slice *sliceHeader) (*C.TPMT_SIG_SCHEME, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmtSigSchemeValue) * slice.Len,
		Cap:  int(sizeOfTpmtSigSchemeValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMT_SIG_SCHEME)(mem0), allocs
}

// allocPTpm2bAttestMemory allocates memory for type *C.TPM2B_ATTEST in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpm2bAttestMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpm2bAttestValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpm2bAttestValue = unsafe.Sizeof([1]*C.TPM2B_ATTEST{})

// unpackArgSSTpm2bAttest transforms a sliced Go data structure into plain C format.
func unpackArgSSTpm2bAttest(x [][]Tpm2bAttest) (unpacked **C.TPM2B_ATTEST, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpm2bAttestMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPM2B_ATTEST)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpm2bAttestMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPM2B_ATTEST)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPM2B_ATTEST)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPM2B_ATTEST)(h.Data)
	return
}

// packSSTpm2bAttest reads sliced Go data structure out from plain C format.
func packSSTpm2bAttest(v [][]Tpm2bAttest, ptr0 **C.TPM2B_ATTEST) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPM2B_ATTEST)(unsafe.Pointer(ptr0)))[i0]
		hxf6a06fa := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf6a06fa.Data = unsafe.Pointer(ptr1)
		hxf6a06fa.Cap = 0x7fffffff
		// hxf6a06fa.Len = ?
	}
}

// allocPTpmtSignatureMemory allocates memory for type *C.TPMT_SIGNATURE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpmtSignatureMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpmtSignatureValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpmtSignatureValue = unsafe.Sizeof([1]*C.TPMT_SIGNATURE{})

// unpackArgSSTpmtSignature transforms a sliced Go data structure into plain C format.
func unpackArgSSTpmtSignature(x [][]TpmtSignature) (unpacked **C.TPMT_SIGNATURE, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpmtSignatureMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPMT_SIGNATURE)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpmtSignatureMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPMT_SIGNATURE)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPMT_SIGNATURE)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPMT_SIGNATURE)(h.Data)
	return
}

// packSSTpmtSignature reads sliced Go data structure out from plain C format.
func packSSTpmtSignature(v [][]TpmtSignature, ptr0 **C.TPMT_SIGNATURE) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPMT_SIGNATURE)(unsafe.Pointer(ptr0)))[i0]
		hxf5ba44e := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf5ba44e.Data = unsafe.Pointer(ptr1)
		hxf5ba44e.Cap = 0x7fffffff
		// hxf5ba44e.Len = ?
	}
}

// copyPTpmtTkCreationBytes copies the data from Go slice as *C.TPMT_TK_CREATION.
func copyPTpmtTkCreationBytes(slice *sliceHeader) (*C.TPMT_TK_CREATION, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmtTkCreationValue) * slice.Len,
		Cap:  int(sizeOfTpmtTkCreationValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMT_TK_CREATION)(mem0), allocs
}

// copyPTpm2bEccParameterBytes copies the data from Go slice as *C.TPM2B_ECC_PARAMETER.
func copyPTpm2bEccParameterBytes(slice *sliceHeader) (*C.TPM2B_ECC_PARAMETER, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2bEccParameterValue) * slice.Len,
		Cap:  int(sizeOfTpm2bEccParameterValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2B_ECC_PARAMETER)(mem0), allocs
}

// copyPUint16Bytes copies the data from Go slice as *C.UINT16.
func copyPUint16Bytes(slice *sliceHeader) (*C.UINT16, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfUint16Value) * slice.Len,
		Cap:  int(sizeOfUint16Value) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.UINT16)(mem0), allocs
}

// allocUint16Memory allocates memory for type C.UINT16 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUint16Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUint16Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUint16Value = unsafe.Sizeof([1]C.UINT16{})

// copyPTpmtSignatureBytes copies the data from Go slice as *C.TPMT_SIGNATURE.
func copyPTpmtSignatureBytes(slice *sliceHeader) (*C.TPMT_SIGNATURE, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmtSignatureValue) * slice.Len,
		Cap:  int(sizeOfTpmtSignatureValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMT_SIGNATURE)(mem0), allocs
}

// allocPTpmtTkVerifiedMemory allocates memory for type *C.TPMT_TK_VERIFIED in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpmtTkVerifiedMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpmtTkVerifiedValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpmtTkVerifiedValue = unsafe.Sizeof([1]*C.TPMT_TK_VERIFIED{})

// unpackArgSSTpmtTkVerified transforms a sliced Go data structure into plain C format.
func unpackArgSSTpmtTkVerified(x [][]TpmtTkVerified) (unpacked **C.TPMT_TK_VERIFIED, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpmtTkVerifiedMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPMT_TK_VERIFIED)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpmtTkVerifiedMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPMT_TK_VERIFIED)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPMT_TK_VERIFIED)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPMT_TK_VERIFIED)(h.Data)
	return
}

// packSSTpmtTkVerified reads sliced Go data structure out from plain C format.
func packSSTpmtTkVerified(v [][]TpmtTkVerified, ptr0 **C.TPMT_TK_VERIFIED) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPMT_TK_VERIFIED)(unsafe.Pointer(ptr0)))[i0]
		hxf08e5b7 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf08e5b7.Data = unsafe.Pointer(ptr1)
		hxf08e5b7.Cap = 0x7fffffff
		// hxf08e5b7.Len = ?
	}
}

// copyPTpmtTkHashcheckBytes copies the data from Go slice as *C.TPMT_TK_HASHCHECK.
func copyPTpmtTkHashcheckBytes(slice *sliceHeader) (*C.TPMT_TK_HASHCHECK, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmtTkHashcheckValue) * slice.Len,
		Cap:  int(sizeOfTpmtTkHashcheckValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMT_TK_HASHCHECK)(mem0), allocs
}

// copyPTpmlCcBytes copies the data from Go slice as *C.TPML_CC.
func copyPTpmlCcBytes(slice *sliceHeader) (*C.TPML_CC, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmlCcValue) * slice.Len,
		Cap:  int(sizeOfTpmlCcValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPML_CC)(mem0), allocs
}

// copyPTpmlDigestValuesBytes copies the data from Go slice as *C.TPML_DIGEST_VALUES.
func copyPTpmlDigestValuesBytes(slice *sliceHeader) (*C.TPML_DIGEST_VALUES, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmlDigestValuesValue) * slice.Len,
		Cap:  int(sizeOfTpmlDigestValuesValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPML_DIGEST_VALUES)(mem0), allocs
}

// copyPTpm2bEventBytes copies the data from Go slice as *C.TPM2B_EVENT.
func copyPTpm2bEventBytes(slice *sliceHeader) (*C.TPM2B_EVENT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2bEventValue) * slice.Len,
		Cap:  int(sizeOfTpm2bEventValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2B_EVENT)(mem0), allocs
}

// copyPUint32Bytes copies the data from Go slice as *C.UINT32.
func copyPUint32Bytes(slice *sliceHeader) (*C.UINT32, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfUint32Value) * slice.Len,
		Cap:  int(sizeOfUint32Value) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.UINT32)(mem0), allocs
}

// allocUint32Memory allocates memory for type C.UINT32 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUint32Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUint32Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUint32Value = unsafe.Sizeof([1]C.UINT32{})

// allocPTpmlPcrSelectionMemory allocates memory for type *C.TPML_PCR_SELECTION in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpmlPcrSelectionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpmlPcrSelectionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpmlPcrSelectionValue = unsafe.Sizeof([1]*C.TPML_PCR_SELECTION{})

// unpackArgSSTpmlPcrSelection transforms a sliced Go data structure into plain C format.
func unpackArgSSTpmlPcrSelection(x [][]TpmlPcrSelection) (unpacked **C.TPML_PCR_SELECTION, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpmlPcrSelectionMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPML_PCR_SELECTION)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpmlPcrSelectionMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPML_PCR_SELECTION)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPML_PCR_SELECTION)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPML_PCR_SELECTION)(h.Data)
	return
}

// packSSTpmlPcrSelection reads sliced Go data structure out from plain C format.
func packSSTpmlPcrSelection(v [][]TpmlPcrSelection, ptr0 **C.TPML_PCR_SELECTION) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPML_PCR_SELECTION)(unsafe.Pointer(ptr0)))[i0]
		hxff268a1 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxff268a1.Data = unsafe.Pointer(ptr1)
		hxff268a1.Cap = 0x7fffffff
		// hxff268a1.Len = ?
	}
}

// allocPTpmlDigestMemory allocates memory for type *C.TPML_DIGEST in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpmlDigestMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpmlDigestValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpmlDigestValue = unsafe.Sizeof([1]*C.TPML_DIGEST{})

// unpackArgSSTpmlDigest transforms a sliced Go data structure into plain C format.
func unpackArgSSTpmlDigest(x [][]TpmlDigest) (unpacked **C.TPML_DIGEST, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpmlDigestMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPML_DIGEST)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpmlDigestMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPML_DIGEST)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPML_DIGEST)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPML_DIGEST)(h.Data)
	return
}

// packSSTpmlDigest reads sliced Go data structure out from plain C format.
func packSSTpmlDigest(v [][]TpmlDigest, ptr0 **C.TPML_DIGEST) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPML_DIGEST)(unsafe.Pointer(ptr0)))[i0]
		hxff5babc := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxff5babc.Data = unsafe.Pointer(ptr1)
		hxff5babc.Cap = 0x7fffffff
		// hxff5babc.Len = ?
	}
}

// copyPTpmiYesNoBytes copies the data from Go slice as *C.TPMI_YES_NO.
func copyPTpmiYesNoBytes(slice *sliceHeader) (*C.TPMI_YES_NO, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmiYesNoValue) * slice.Len,
		Cap:  int(sizeOfTpmiYesNoValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMI_YES_NO)(mem0), allocs
}

// allocTpmiYesNoMemory allocates memory for type C.TPMI_YES_NO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmiYesNoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmiYesNoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmiYesNoValue = unsafe.Sizeof([1]C.TPMI_YES_NO{})

// allocPTpm2bTimeoutMemory allocates memory for type *C.TPM2B_TIMEOUT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpm2bTimeoutMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpm2bTimeoutValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpm2bTimeoutValue = unsafe.Sizeof([1]*C.TPM2B_TIMEOUT{})

// allocTpm2bTimeoutMemory allocates memory for type C.TPM2B_TIMEOUT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bTimeoutMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bTimeoutValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bTimeoutValue = unsafe.Sizeof([1]C.TPM2B_TIMEOUT{})

// unpackArgSSTpm2bTimeout transforms a sliced Go data structure into plain C format.
func unpackArgSSTpm2bTimeout(x [][]Tpm2bTimeout) (unpacked **C.TPM2B_TIMEOUT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpm2bTimeoutMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPM2B_TIMEOUT)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpm2bTimeoutMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPM2B_TIMEOUT)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPM2B_TIMEOUT)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPM2B_TIMEOUT)(h.Data)
	return
}

// packSSTpm2bTimeout reads sliced Go data structure out from plain C format.
func packSSTpm2bTimeout(v [][]Tpm2bTimeout, ptr0 **C.TPM2B_TIMEOUT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPM2B_TIMEOUT)(unsafe.Pointer(ptr0)))[i0]
		hxf463f61 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf463f61.Data = unsafe.Pointer(ptr1)
		hxf463f61.Cap = 0x7fffffff
		// hxf463f61.Len = ?
	}
}

// allocPTpmtTkAuthMemory allocates memory for type *C.TPMT_TK_AUTH in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpmtTkAuthMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpmtTkAuthValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpmtTkAuthValue = unsafe.Sizeof([1]*C.TPMT_TK_AUTH{})

// unpackArgSSTpmtTkAuth transforms a sliced Go data structure into plain C format.
func unpackArgSSTpmtTkAuth(x [][]TpmtTkAuth) (unpacked **C.TPMT_TK_AUTH, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpmtTkAuthMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPMT_TK_AUTH)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpmtTkAuthMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPMT_TK_AUTH)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPMT_TK_AUTH)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPMT_TK_AUTH)(h.Data)
	return
}

// packSSTpmtTkAuth reads sliced Go data structure out from plain C format.
func packSSTpmtTkAuth(v [][]TpmtTkAuth, ptr0 **C.TPMT_TK_AUTH) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPMT_TK_AUTH)(unsafe.Pointer(ptr0)))[i0]
		hxf4a3cd3 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf4a3cd3.Data = unsafe.Pointer(ptr1)
		hxf4a3cd3.Cap = 0x7fffffff
		// hxf4a3cd3.Len = ?
	}
}

// copyPTpm2bTimeoutBytes copies the data from Go slice as *C.TPM2B_TIMEOUT.
func copyPTpm2bTimeoutBytes(slice *sliceHeader) (*C.TPM2B_TIMEOUT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2bTimeoutValue) * slice.Len,
		Cap:  int(sizeOfTpm2bTimeoutValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2B_TIMEOUT)(mem0), allocs
}

// copyPTpmtTkAuthBytes copies the data from Go slice as *C.TPMT_TK_AUTH.
func copyPTpmtTkAuthBytes(slice *sliceHeader) (*C.TPMT_TK_AUTH, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmtTkAuthValue) * slice.Len,
		Cap:  int(sizeOfTpmtTkAuthValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMT_TK_AUTH)(mem0), allocs
}

// copyPTpmlDigestBytes copies the data from Go slice as *C.TPML_DIGEST.
func copyPTpmlDigestBytes(slice *sliceHeader) (*C.TPML_DIGEST, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmlDigestValue) * slice.Len,
		Cap:  int(sizeOfTpmlDigestValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPML_DIGEST)(mem0), allocs
}

// copyPTpm2bOperandBytes copies the data from Go slice as *C.TPM2B_OPERAND.
func copyPTpm2bOperandBytes(slice *sliceHeader) (*C.TPM2B_OPERAND, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2bOperandValue) * slice.Len,
		Cap:  int(sizeOfTpm2bOperandValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2B_OPERAND)(mem0), allocs
}

// allocTpm2bOperandMemory allocates memory for type C.TPM2B_OPERAND in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bOperandMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bOperandValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bOperandValue = unsafe.Sizeof([1]C.TPM2B_OPERAND{})

// copyPTpmtTkVerifiedBytes copies the data from Go slice as *C.TPMT_TK_VERIFIED.
func copyPTpmtTkVerifiedBytes(slice *sliceHeader) (*C.TPMT_TK_VERIFIED, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmtTkVerifiedValue) * slice.Len,
		Cap:  int(sizeOfTpmtTkVerifiedValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMT_TK_VERIFIED)(mem0), allocs
}

// allocPTpmtHaMemory allocates memory for type *C.TPMT_HA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpmtHaMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpmtHaValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpmtHaValue = unsafe.Sizeof([1]*C.TPMT_HA{})

// unpackArgSSTpmtHa transforms a sliced Go data structure into plain C format.
func unpackArgSSTpmtHa(x [][]TpmtHa) (unpacked **C.TPMT_HA, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpmtHaMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPMT_HA)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpmtHaMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPMT_HA)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPMT_HA)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPMT_HA)(h.Data)
	return
}

// packSSTpmtHa reads sliced Go data structure out from plain C format.
func packSSTpmtHa(v [][]TpmtHa, ptr0 **C.TPMT_HA) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPMT_HA)(unsafe.Pointer(ptr0)))[i0]
		hxfe252d8 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxfe252d8.Data = unsafe.Pointer(ptr1)
		hxfe252d8.Cap = 0x7fffffff
		// hxfe252d8.Len = ?
	}
}

// allocPTpmsContextMemory allocates memory for type *C.TPMS_CONTEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpmsContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpmsContextValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpmsContextValue = unsafe.Sizeof([1]*C.TPMS_CONTEXT{})

// unpackArgSSTpmsContext transforms a sliced Go data structure into plain C format.
func unpackArgSSTpmsContext(x [][]TpmsContext) (unpacked **C.TPMS_CONTEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpmsContextMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPMS_CONTEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpmsContextMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPMS_CONTEXT)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPMS_CONTEXT)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPMS_CONTEXT)(h.Data)
	return
}

// packSSTpmsContext reads sliced Go data structure out from plain C format.
func packSSTpmsContext(v [][]TpmsContext, ptr0 **C.TPMS_CONTEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPMS_CONTEXT)(unsafe.Pointer(ptr0)))[i0]
		hxfc08a21 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxfc08a21.Data = unsafe.Pointer(ptr1)
		hxfc08a21.Cap = 0x7fffffff
		// hxfc08a21.Len = ?
	}
}

// copyPTpmsContextBytes copies the data from Go slice as *C.TPMS_CONTEXT.
func copyPTpmsContextBytes(slice *sliceHeader) (*C.TPMS_CONTEXT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsContextValue) * slice.Len,
		Cap:  int(sizeOfTpmsContextValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_CONTEXT)(mem0), allocs
}

// allocPTpmsTimeInfoMemory allocates memory for type *C.TPMS_TIME_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpmsTimeInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpmsTimeInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpmsTimeInfoValue = unsafe.Sizeof([1]*C.TPMS_TIME_INFO{})

// unpackArgSSTpmsTimeInfo transforms a sliced Go data structure into plain C format.
func unpackArgSSTpmsTimeInfo(x [][]TpmsTimeInfo) (unpacked **C.TPMS_TIME_INFO, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpmsTimeInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPMS_TIME_INFO)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpmsTimeInfoMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPMS_TIME_INFO)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPMS_TIME_INFO)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPMS_TIME_INFO)(h.Data)
	return
}

// packSSTpmsTimeInfo reads sliced Go data structure out from plain C format.
func packSSTpmsTimeInfo(v [][]TpmsTimeInfo, ptr0 **C.TPMS_TIME_INFO) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPMS_TIME_INFO)(unsafe.Pointer(ptr0)))[i0]
		hxf57c7f8 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf57c7f8.Data = unsafe.Pointer(ptr1)
		hxf57c7f8.Cap = 0x7fffffff
		// hxf57c7f8.Len = ?
	}
}

// allocPTpmsCapabilityDataMemory allocates memory for type *C.TPMS_CAPABILITY_DATA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpmsCapabilityDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpmsCapabilityDataValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpmsCapabilityDataValue = unsafe.Sizeof([1]*C.TPMS_CAPABILITY_DATA{})

// unpackArgSSTpmsCapabilityData transforms a sliced Go data structure into plain C format.
func unpackArgSSTpmsCapabilityData(x [][]TpmsCapabilityData) (unpacked **C.TPMS_CAPABILITY_DATA, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpmsCapabilityDataMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPMS_CAPABILITY_DATA)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpmsCapabilityDataMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPMS_CAPABILITY_DATA)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPMS_CAPABILITY_DATA)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPMS_CAPABILITY_DATA)(h.Data)
	return
}

// packSSTpmsCapabilityData reads sliced Go data structure out from plain C format.
func packSSTpmsCapabilityData(v [][]TpmsCapabilityData, ptr0 **C.TPMS_CAPABILITY_DATA) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPMS_CAPABILITY_DATA)(unsafe.Pointer(ptr0)))[i0]
		hxf6a3e01 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf6a3e01.Data = unsafe.Pointer(ptr1)
		hxf6a3e01.Cap = 0x7fffffff
		// hxf6a3e01.Len = ?
	}
}

// copyPTpmtPublicParmsBytes copies the data from Go slice as *C.TPMT_PUBLIC_PARMS.
func copyPTpmtPublicParmsBytes(slice *sliceHeader) (*C.TPMT_PUBLIC_PARMS, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmtPublicParmsValue) * slice.Len,
		Cap:  int(sizeOfTpmtPublicParmsValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMT_PUBLIC_PARMS)(mem0), allocs
}

// copyPTpm2bNvPublicBytes copies the data from Go slice as *C.TPM2B_NV_PUBLIC.
func copyPTpm2bNvPublicBytes(slice *sliceHeader) (*C.TPM2B_NV_PUBLIC, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2bNvPublicValue) * slice.Len,
		Cap:  int(sizeOfTpm2bNvPublicValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2B_NV_PUBLIC)(mem0), allocs
}

// allocPTpm2bNvPublicMemory allocates memory for type *C.TPM2B_NV_PUBLIC in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpm2bNvPublicMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpm2bNvPublicValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpm2bNvPublicValue = unsafe.Sizeof([1]*C.TPM2B_NV_PUBLIC{})

// unpackArgSSTpm2bNvPublic transforms a sliced Go data structure into plain C format.
func unpackArgSSTpm2bNvPublic(x [][]Tpm2bNvPublic) (unpacked **C.TPM2B_NV_PUBLIC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpm2bNvPublicMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPM2B_NV_PUBLIC)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpm2bNvPublicMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPM2B_NV_PUBLIC)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPM2B_NV_PUBLIC)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPM2B_NV_PUBLIC)(h.Data)
	return
}

// packSSTpm2bNvPublic reads sliced Go data structure out from plain C format.
func packSSTpm2bNvPublic(v [][]Tpm2bNvPublic, ptr0 **C.TPM2B_NV_PUBLIC) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPM2B_NV_PUBLIC)(unsafe.Pointer(ptr0)))[i0]
		hxf31b5a3 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf31b5a3.Data = unsafe.Pointer(ptr1)
		hxf31b5a3.Cap = 0x7fffffff
		// hxf31b5a3.Len = ?
	}
}

// copyPTpm2bMaxNvBufferBytes copies the data from Go slice as *C.TPM2B_MAX_NV_BUFFER.
func copyPTpm2bMaxNvBufferBytes(slice *sliceHeader) (*C.TPM2B_MAX_NV_BUFFER, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2bMaxNvBufferValue) * slice.Len,
		Cap:  int(sizeOfTpm2bMaxNvBufferValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2B_MAX_NV_BUFFER)(mem0), allocs
}

// allocPTpm2bMaxNvBufferMemory allocates memory for type *C.TPM2B_MAX_NV_BUFFER in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpm2bMaxNvBufferMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpm2bMaxNvBufferValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpm2bMaxNvBufferValue = unsafe.Sizeof([1]*C.TPM2B_MAX_NV_BUFFER{})

// unpackArgSSTpm2bMaxNvBuffer transforms a sliced Go data structure into plain C format.
func unpackArgSSTpm2bMaxNvBuffer(x [][]Tpm2bMaxNvBuffer) (unpacked **C.TPM2B_MAX_NV_BUFFER, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpm2bMaxNvBufferMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPM2B_MAX_NV_BUFFER)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpm2bMaxNvBufferMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPM2B_MAX_NV_BUFFER)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPM2B_MAX_NV_BUFFER)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPM2B_MAX_NV_BUFFER)(h.Data)
	return
}

// packSSTpm2bMaxNvBuffer reads sliced Go data structure out from plain C format.
func packSSTpm2bMaxNvBuffer(v [][]Tpm2bMaxNvBuffer, ptr0 **C.TPM2B_MAX_NV_BUFFER) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPM2B_MAX_NV_BUFFER)(unsafe.Pointer(ptr0)))[i0]
		hxf505be5 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf505be5.Data = unsafe.Pointer(ptr1)
		hxf505be5.Cap = 0x7fffffff
		// hxf505be5.Len = ?
	}
}

// copyPTss2SysContextBytes copies the data from Go slice as *C.TSS2_SYS_CONTEXT.
func copyPTss2SysContextBytes(slice *sliceHeader) (*C.TSS2_SYS_CONTEXT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTss2SysContextValue) * slice.Len,
		Cap:  int(sizeOfTss2SysContextValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TSS2_SYS_CONTEXT)(mem0), allocs
}

// copyPTss2lSysAuthCommandBytes copies the data from Go slice as *C.TSS2L_SYS_AUTH_COMMAND.
func copyPTss2lSysAuthCommandBytes(slice *sliceHeader) (*C.TSS2L_SYS_AUTH_COMMAND, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTss2lSysAuthCommandValue) * slice.Len,
		Cap:  int(sizeOfTss2lSysAuthCommandValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TSS2L_SYS_AUTH_COMMAND)(mem0), allocs
}

// copyPUint8Bytes copies the data from Go slice as *C.UINT8.
func copyPUint8Bytes(slice *sliceHeader) (*C.UINT8, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfUint8Value) * slice.Len,
		Cap:  int(sizeOfUint8Value) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.UINT8)(mem0), allocs
}

// allocUint8Memory allocates memory for type C.UINT8 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUint8Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUint8Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUint8Value = unsafe.Sizeof([1]C.UINT8{})

// copyPTss2lSysAuthResponseBytes copies the data from Go slice as *C.TSS2L_SYS_AUTH_RESPONSE.
func copyPTss2lSysAuthResponseBytes(slice *sliceHeader) (*C.TSS2L_SYS_AUTH_RESPONSE, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTss2lSysAuthResponseValue) * slice.Len,
		Cap:  int(sizeOfTss2lSysAuthResponseValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TSS2L_SYS_AUTH_RESPONSE)(mem0), allocs
}

// copyPTpmiShAuthSessionBytes copies the data from Go slice as *C.TPMI_SH_AUTH_SESSION.
func copyPTpmiShAuthSessionBytes(slice *sliceHeader) (*C.TPMI_SH_AUTH_SESSION, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmiShAuthSessionValue) * slice.Len,
		Cap:  int(sizeOfTpmiShAuthSessionValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMI_SH_AUTH_SESSION)(mem0), allocs
}

// allocTpmiShAuthSessionMemory allocates memory for type C.TPMI_SH_AUTH_SESSION in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmiShAuthSessionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmiShAuthSessionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmiShAuthSessionValue = unsafe.Sizeof([1]C.TPMI_SH_AUTH_SESSION{})

// copyPTpm2bCreationDataBytes copies the data from Go slice as *C.TPM2B_CREATION_DATA.
func copyPTpm2bCreationDataBytes(slice *sliceHeader) (*C.TPM2B_CREATION_DATA, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2bCreationDataValue) * slice.Len,
		Cap:  int(sizeOfTpm2bCreationDataValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2B_CREATION_DATA)(mem0), allocs
}

// copyPTpm2HandleBytes copies the data from Go slice as *C.TPM2_HANDLE.
func copyPTpm2HandleBytes(slice *sliceHeader) (*C.TPM2_HANDLE, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2HandleValue) * slice.Len,
		Cap:  int(sizeOfTpm2HandleValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2_HANDLE)(mem0), allocs
}

// allocTpm2HandleMemory allocates memory for type C.TPM2_HANDLE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2HandleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2HandleValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2HandleValue = unsafe.Sizeof([1]C.TPM2_HANDLE{})

// copyPTpmsAlgorithmDetailEccBytes copies the data from Go slice as *C.TPMS_ALGORITHM_DETAIL_ECC.
func copyPTpmsAlgorithmDetailEccBytes(slice *sliceHeader) (*C.TPMS_ALGORITHM_DETAIL_ECC, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsAlgorithmDetailEccValue) * slice.Len,
		Cap:  int(sizeOfTpmsAlgorithmDetailEccValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_ALGORITHM_DETAIL_ECC)(mem0), allocs
}

// copyPTpmiDhObjectBytes copies the data from Go slice as *C.TPMI_DH_OBJECT.
func copyPTpmiDhObjectBytes(slice *sliceHeader) (*C.TPMI_DH_OBJECT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmiDhObjectValue) * slice.Len,
		Cap:  int(sizeOfTpmiDhObjectValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMI_DH_OBJECT)(mem0), allocs
}

// allocTpmiDhObjectMemory allocates memory for type C.TPMI_DH_OBJECT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmiDhObjectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmiDhObjectValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmiDhObjectValue = unsafe.Sizeof([1]C.TPMI_DH_OBJECT{})

// copyPTpm2bAttestBytes copies the data from Go slice as *C.TPM2B_ATTEST.
func copyPTpm2bAttestBytes(slice *sliceHeader) (*C.TPM2B_ATTEST, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2bAttestValue) * slice.Len,
		Cap:  int(sizeOfTpm2bAttestValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2B_ATTEST)(mem0), allocs
}

// copyPTpmtHaBytes copies the data from Go slice as *C.TPMT_HA.
func copyPTpmtHaBytes(slice *sliceHeader) (*C.TPMT_HA, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmtHaValue) * slice.Len,
		Cap:  int(sizeOfTpmtHaValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMT_HA)(mem0), allocs
}

// copyPTpmiDhContextBytes copies the data from Go slice as *C.TPMI_DH_CONTEXT.
func copyPTpmiDhContextBytes(slice *sliceHeader) (*C.TPMI_DH_CONTEXT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmiDhContextValue) * slice.Len,
		Cap:  int(sizeOfTpmiDhContextValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMI_DH_CONTEXT)(mem0), allocs
}

// allocTpmiDhContextMemory allocates memory for type C.TPMI_DH_CONTEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmiDhContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmiDhContextValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmiDhContextValue = unsafe.Sizeof([1]C.TPMI_DH_CONTEXT{})

// copyPTpmsTimeInfoBytes copies the data from Go slice as *C.TPMS_TIME_INFO.
func copyPTpmsTimeInfoBytes(slice *sliceHeader) (*C.TPMS_TIME_INFO, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsTimeInfoValue) * slice.Len,
		Cap:  int(sizeOfTpmsTimeInfoValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_TIME_INFO)(mem0), allocs
}

// copyPTpmsCapabilityDataBytes copies the data from Go slice as *C.TPMS_CAPABILITY_DATA.
func copyPTpmsCapabilityDataBytes(slice *sliceHeader) (*C.TPMS_CAPABILITY_DATA, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsCapabilityDataValue) * slice.Len,
		Cap:  int(sizeOfTpmsCapabilityDataValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_CAPABILITY_DATA)(mem0), allocs
}

// copyPTpmlAcCapabilitiesBytes copies the data from Go slice as *C.TPML_AC_CAPABILITIES.
func copyPTpmlAcCapabilitiesBytes(slice *sliceHeader) (*C.TPML_AC_CAPABILITIES, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmlAcCapabilitiesValue) * slice.Len,
		Cap:  int(sizeOfTpmlAcCapabilitiesValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPML_AC_CAPABILITIES)(mem0), allocs
}

// copyPTpmsAcOutputBytes copies the data from Go slice as *C.TPMS_AC_OUTPUT.
func copyPTpmsAcOutputBytes(slice *sliceHeader) (*C.TPMS_AC_OUTPUT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsAcOutputValue) * slice.Len,
		Cap:  int(sizeOfTpmsAcOutputValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_AC_OUTPUT)(mem0), allocs
}

// copyPByteBytes copies the data from Go slice as *C.BYTE.
func copyPByteBytes(slice *sliceHeader) (*C.BYTE, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfByteValue) * slice.Len,
		Cap:  int(sizeOfByteValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.BYTE)(mem0), allocs
}

// allocByteMemory allocates memory for type C.BYTE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocByteMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfByteValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfByteValue = unsafe.Sizeof([1]C.BYTE{})

// copyPInt8Bytes copies the data from Go slice as *C.INT8.
func copyPInt8Bytes(slice *sliceHeader) (*C.INT8, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfInt8Value) * slice.Len,
		Cap:  int(sizeOfInt8Value) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.INT8)(mem0), allocs
}

// allocInt8Memory allocates memory for type C.INT8 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocInt8Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfInt8Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfInt8Value = unsafe.Sizeof([1]C.INT8{})

// copyPInt16Bytes copies the data from Go slice as *C.INT16.
func copyPInt16Bytes(slice *sliceHeader) (*C.INT16, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfInt16Value) * slice.Len,
		Cap:  int(sizeOfInt16Value) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.INT16)(mem0), allocs
}

// allocInt16Memory allocates memory for type C.INT16 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocInt16Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfInt16Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfInt16Value = unsafe.Sizeof([1]C.INT16{})

// copyPInt32Bytes copies the data from Go slice as *C.INT32.
func copyPInt32Bytes(slice *sliceHeader) (*C.INT32, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfInt32Value) * slice.Len,
		Cap:  int(sizeOfInt32Value) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.INT32)(mem0), allocs
}

// allocInt32Memory allocates memory for type C.INT32 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocInt32Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfInt32Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfInt32Value = unsafe.Sizeof([1]C.INT32{})

// copyPInt64Bytes copies the data from Go slice as *C.INT64.
func copyPInt64Bytes(slice *sliceHeader) (*C.INT64, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfInt64Value) * slice.Len,
		Cap:  int(sizeOfInt64Value) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.INT64)(mem0), allocs
}

// allocInt64Memory allocates memory for type C.INT64 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocInt64Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfInt64Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfInt64Value = unsafe.Sizeof([1]C.INT64{})

// copyPUint64Bytes copies the data from Go slice as *C.UINT64.
func copyPUint64Bytes(slice *sliceHeader) (*C.UINT64, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfUint64Value) * slice.Len,
		Cap:  int(sizeOfUint64Value) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.UINT64)(mem0), allocs
}

// allocUint64Memory allocates memory for type C.UINT64 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUint64Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUint64Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUint64Value = unsafe.Sizeof([1]C.UINT64{})

// copyPTpm2CcBytes copies the data from Go slice as *C.TPM2_CC.
func copyPTpm2CcBytes(slice *sliceHeader) (*C.TPM2_CC, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2CcValue) * slice.Len,
		Cap:  int(sizeOfTpm2CcValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2_CC)(mem0), allocs
}

// allocTpm2CcMemory allocates memory for type C.TPM2_CC in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2CcMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2CcValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2CcValue = unsafe.Sizeof([1]C.TPM2_CC{})

// copyPTpm2StBytes copies the data from Go slice as *C.TPM2_ST.
func copyPTpm2StBytes(slice *sliceHeader) (*C.TPM2_ST, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2StValue) * slice.Len,
		Cap:  int(sizeOfTpm2StValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2_ST)(mem0), allocs
}

// allocTpm2StMemory allocates memory for type C.TPM2_ST in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2StMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2StValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2StValue = unsafe.Sizeof([1]C.TPM2_ST{})

// copyPTpmaAlgorithmBytes copies the data from Go slice as *C.TPMA_ALGORITHM.
func copyPTpmaAlgorithmBytes(slice *sliceHeader) (*C.TPMA_ALGORITHM, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmaAlgorithmValue) * slice.Len,
		Cap:  int(sizeOfTpmaAlgorithmValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMA_ALGORITHM)(mem0), allocs
}

// allocTpmaAlgorithmMemory allocates memory for type C.TPMA_ALGORITHM in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmaAlgorithmMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmaAlgorithmValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmaAlgorithmValue = unsafe.Sizeof([1]C.TPMA_ALGORITHM{})

// copyPTpmaCcBytes copies the data from Go slice as *C.TPMA_CC.
func copyPTpmaCcBytes(slice *sliceHeader) (*C.TPMA_CC, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmaCcValue) * slice.Len,
		Cap:  int(sizeOfTpmaCcValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMA_CC)(mem0), allocs
}

// allocTpmaCcMemory allocates memory for type C.TPMA_CC in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmaCcMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmaCcValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmaCcValue = unsafe.Sizeof([1]C.TPMA_CC{})

// copyPTpmaLocalityBytes copies the data from Go slice as *C.TPMA_LOCALITY.
func copyPTpmaLocalityBytes(slice *sliceHeader) (*C.TPMA_LOCALITY, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmaLocalityValue) * slice.Len,
		Cap:  int(sizeOfTpmaLocalityValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMA_LOCALITY)(mem0), allocs
}

// allocTpmaLocalityMemory allocates memory for type C.TPMA_LOCALITY in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmaLocalityMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmaLocalityValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmaLocalityValue = unsafe.Sizeof([1]C.TPMA_LOCALITY{})

// copyPTpmaNvBytes copies the data from Go slice as *C.TPMA_NV.
func copyPTpmaNvBytes(slice *sliceHeader) (*C.TPMA_NV, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmaNvValue) * slice.Len,
		Cap:  int(sizeOfTpmaNvValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMA_NV)(mem0), allocs
}

// allocTpmaNvMemory allocates memory for type C.TPMA_NV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmaNvMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmaNvValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmaNvValue = unsafe.Sizeof([1]C.TPMA_NV{})

// copyPTpmaObjectBytes copies the data from Go slice as *C.TPMA_OBJECT.
func copyPTpmaObjectBytes(slice *sliceHeader) (*C.TPMA_OBJECT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmaObjectValue) * slice.Len,
		Cap:  int(sizeOfTpmaObjectValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMA_OBJECT)(mem0), allocs
}

// allocTpmaObjectMemory allocates memory for type C.TPMA_OBJECT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmaObjectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmaObjectValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmaObjectValue = unsafe.Sizeof([1]C.TPMA_OBJECT{})

// copyPTpmaPermanentBytes copies the data from Go slice as *C.TPMA_PERMANENT.
func copyPTpmaPermanentBytes(slice *sliceHeader) (*C.TPMA_PERMANENT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmaPermanentValue) * slice.Len,
		Cap:  int(sizeOfTpmaPermanentValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMA_PERMANENT)(mem0), allocs
}

// allocTpmaPermanentMemory allocates memory for type C.TPMA_PERMANENT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmaPermanentMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmaPermanentValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmaPermanentValue = unsafe.Sizeof([1]C.TPMA_PERMANENT{})

// copyPTpmaStartupClearBytes copies the data from Go slice as *C.TPMA_STARTUP_CLEAR.
func copyPTpmaStartupClearBytes(slice *sliceHeader) (*C.TPMA_STARTUP_CLEAR, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmaStartupClearValue) * slice.Len,
		Cap:  int(sizeOfTpmaStartupClearValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMA_STARTUP_CLEAR)(mem0), allocs
}

// allocTpmaStartupClearMemory allocates memory for type C.TPMA_STARTUP_CLEAR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmaStartupClearMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmaStartupClearValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmaStartupClearValue = unsafe.Sizeof([1]C.TPMA_STARTUP_CLEAR{})

// copyPTpm2bPrivateKeyRsaBytes copies the data from Go slice as *C.TPM2B_PRIVATE_KEY_RSA.
func copyPTpm2bPrivateKeyRsaBytes(slice *sliceHeader) (*C.TPM2B_PRIVATE_KEY_RSA, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2bPrivateKeyRsaValue) * slice.Len,
		Cap:  int(sizeOfTpm2bPrivateKeyRsaValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2B_PRIVATE_KEY_RSA)(mem0), allocs
}

// copyPTpm2bContextSensitiveBytes copies the data from Go slice as *C.TPM2B_CONTEXT_SENSITIVE.
func copyPTpm2bContextSensitiveBytes(slice *sliceHeader) (*C.TPM2B_CONTEXT_SENSITIVE, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2bContextSensitiveValue) * slice.Len,
		Cap:  int(sizeOfTpm2bContextSensitiveValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2B_CONTEXT_SENSITIVE)(mem0), allocs
}

// copyPTpm2bContextDataBytes copies the data from Go slice as *C.TPM2B_CONTEXT_DATA.
func copyPTpm2bContextDataBytes(slice *sliceHeader) (*C.TPM2B_CONTEXT_DATA, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2bContextDataValue) * slice.Len,
		Cap:  int(sizeOfTpm2bContextDataValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2B_CONTEXT_DATA)(mem0), allocs
}

// copyPTpm2bSymKeyBytes copies the data from Go slice as *C.TPM2B_SYM_KEY.
func copyPTpm2bSymKeyBytes(slice *sliceHeader) (*C.TPM2B_SYM_KEY, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2bSymKeyValue) * slice.Len,
		Cap:  int(sizeOfTpm2bSymKeyValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2B_SYM_KEY)(mem0), allocs
}

// copyPTpmsEccPointBytes copies the data from Go slice as *C.TPMS_ECC_POINT.
func copyPTpmsEccPointBytes(slice *sliceHeader) (*C.TPMS_ECC_POINT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsEccPointValue) * slice.Len,
		Cap:  int(sizeOfTpmsEccPointValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_ECC_POINT)(mem0), allocs
}

// copyPTpmsNvPublicBytes copies the data from Go slice as *C.TPMS_NV_PUBLIC.
func copyPTpmsNvPublicBytes(slice *sliceHeader) (*C.TPMS_NV_PUBLIC, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsNvPublicValue) * slice.Len,
		Cap:  int(sizeOfTpmsNvPublicValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_NV_PUBLIC)(mem0), allocs
}

// copyPTpmsAlgPropertyBytes copies the data from Go slice as *C.TPMS_ALG_PROPERTY.
func copyPTpmsAlgPropertyBytes(slice *sliceHeader) (*C.TPMS_ALG_PROPERTY, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsAlgPropertyValue) * slice.Len,
		Cap:  int(sizeOfTpmsAlgPropertyValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_ALG_PROPERTY)(mem0), allocs
}

// copyPTpmsAlgorithmDescriptionBytes copies the data from Go slice as *C.TPMS_ALGORITHM_DESCRIPTION.
func copyPTpmsAlgorithmDescriptionBytes(slice *sliceHeader) (*C.TPMS_ALGORITHM_DESCRIPTION, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsAlgorithmDescriptionValue) * slice.Len,
		Cap:  int(sizeOfTpmsAlgorithmDescriptionValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_ALGORITHM_DESCRIPTION)(mem0), allocs
}

// copyPTpmsTaggedPropertyBytes copies the data from Go slice as *C.TPMS_TAGGED_PROPERTY.
func copyPTpmsTaggedPropertyBytes(slice *sliceHeader) (*C.TPMS_TAGGED_PROPERTY, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsTaggedPropertyValue) * slice.Len,
		Cap:  int(sizeOfTpmsTaggedPropertyValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_TAGGED_PROPERTY)(mem0), allocs
}

// copyPTpmsTaggedPolicyBytes copies the data from Go slice as *C.TPMS_TAGGED_POLICY.
func copyPTpmsTaggedPolicyBytes(slice *sliceHeader) (*C.TPMS_TAGGED_POLICY, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsTaggedPolicyValue) * slice.Len,
		Cap:  int(sizeOfTpmsTaggedPolicyValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_TAGGED_POLICY)(mem0), allocs
}

// copyPTpmsClockInfoBytes copies the data from Go slice as *C.TPMS_CLOCK_INFO.
func copyPTpmsClockInfoBytes(slice *sliceHeader) (*C.TPMS_CLOCK_INFO, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsClockInfoValue) * slice.Len,
		Cap:  int(sizeOfTpmsClockInfoValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_CLOCK_INFO)(mem0), allocs
}

// copyPTpmsTimeAttestInfoBytes copies the data from Go slice as *C.TPMS_TIME_ATTEST_INFO.
func copyPTpmsTimeAttestInfoBytes(slice *sliceHeader) (*C.TPMS_TIME_ATTEST_INFO, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsTimeAttestInfoValue) * slice.Len,
		Cap:  int(sizeOfTpmsTimeAttestInfoValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_TIME_ATTEST_INFO)(mem0), allocs
}

// copyPTpmsCertifyInfoBytes copies the data from Go slice as *C.TPMS_CERTIFY_INFO.
func copyPTpmsCertifyInfoBytes(slice *sliceHeader) (*C.TPMS_CERTIFY_INFO, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsCertifyInfoValue) * slice.Len,
		Cap:  int(sizeOfTpmsCertifyInfoValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_CERTIFY_INFO)(mem0), allocs
}

// copyPTpmsCommandAuditInfoBytes copies the data from Go slice as *C.TPMS_COMMAND_AUDIT_INFO.
func copyPTpmsCommandAuditInfoBytes(slice *sliceHeader) (*C.TPMS_COMMAND_AUDIT_INFO, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsCommandAuditInfoValue) * slice.Len,
		Cap:  int(sizeOfTpmsCommandAuditInfoValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_COMMAND_AUDIT_INFO)(mem0), allocs
}

// copyPTpmsSessionAuditInfoBytes copies the data from Go slice as *C.TPMS_SESSION_AUDIT_INFO.
func copyPTpmsSessionAuditInfoBytes(slice *sliceHeader) (*C.TPMS_SESSION_AUDIT_INFO, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsSessionAuditInfoValue) * slice.Len,
		Cap:  int(sizeOfTpmsSessionAuditInfoValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_SESSION_AUDIT_INFO)(mem0), allocs
}

// copyPTpmsCreationInfoBytes copies the data from Go slice as *C.TPMS_CREATION_INFO.
func copyPTpmsCreationInfoBytes(slice *sliceHeader) (*C.TPMS_CREATION_INFO, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsCreationInfoValue) * slice.Len,
		Cap:  int(sizeOfTpmsCreationInfoValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_CREATION_INFO)(mem0), allocs
}

// copyPTpmsNvCertifyInfoBytes copies the data from Go slice as *C.TPMS_NV_CERTIFY_INFO.
func copyPTpmsNvCertifyInfoBytes(slice *sliceHeader) (*C.TPMS_NV_CERTIFY_INFO, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsNvCertifyInfoValue) * slice.Len,
		Cap:  int(sizeOfTpmsNvCertifyInfoValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_NV_CERTIFY_INFO)(mem0), allocs
}

// copyPTpmsAuthCommandBytes copies the data from Go slice as *C.TPMS_AUTH_COMMAND.
func copyPTpmsAuthCommandBytes(slice *sliceHeader) (*C.TPMS_AUTH_COMMAND, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsAuthCommandValue) * slice.Len,
		Cap:  int(sizeOfTpmsAuthCommandValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_AUTH_COMMAND)(mem0), allocs
}

// copyPTpmsAuthResponseBytes copies the data from Go slice as *C.TPMS_AUTH_RESPONSE.
func copyPTpmsAuthResponseBytes(slice *sliceHeader) (*C.TPMS_AUTH_RESPONSE, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsAuthResponseValue) * slice.Len,
		Cap:  int(sizeOfTpmsAuthResponseValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_AUTH_RESPONSE)(mem0), allocs
}

// copyPTpmsSensitiveCreateBytes copies the data from Go slice as *C.TPMS_SENSITIVE_CREATE.
func copyPTpmsSensitiveCreateBytes(slice *sliceHeader) (*C.TPMS_SENSITIVE_CREATE, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsSensitiveCreateValue) * slice.Len,
		Cap:  int(sizeOfTpmsSensitiveCreateValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_SENSITIVE_CREATE)(mem0), allocs
}

// copyPTpmsSchemeHashBytes copies the data from Go slice as *C.TPMS_SCHEME_HASH.
func copyPTpmsSchemeHashBytes(slice *sliceHeader) (*C.TPMS_SCHEME_HASH, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsSchemeHashValue) * slice.Len,
		Cap:  int(sizeOfTpmsSchemeHashValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_SCHEME_HASH)(mem0), allocs
}

// copyPTpmsSchemeEcdaaBytes copies the data from Go slice as *C.TPMS_SCHEME_ECDAA.
func copyPTpmsSchemeEcdaaBytes(slice *sliceHeader) (*C.TPMS_SCHEME_ECDAA, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsSchemeEcdaaValue) * slice.Len,
		Cap:  int(sizeOfTpmsSchemeEcdaaValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_SCHEME_ECDAA)(mem0), allocs
}

// copyPTpmsSchemeXorBytes copies the data from Go slice as *C.TPMS_SCHEME_XOR.
func copyPTpmsSchemeXorBytes(slice *sliceHeader) (*C.TPMS_SCHEME_XOR, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsSchemeXorValue) * slice.Len,
		Cap:  int(sizeOfTpmsSchemeXorValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_SCHEME_XOR)(mem0), allocs
}

// copyPTpmsSignatureRsaBytes copies the data from Go slice as *C.TPMS_SIGNATURE_RSA.
func copyPTpmsSignatureRsaBytes(slice *sliceHeader) (*C.TPMS_SIGNATURE_RSA, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsSignatureRsaValue) * slice.Len,
		Cap:  int(sizeOfTpmsSignatureRsaValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_SIGNATURE_RSA)(mem0), allocs
}

// copyPTpmsSignatureEccBytes copies the data from Go slice as *C.TPMS_SIGNATURE_ECC.
func copyPTpmsSignatureEccBytes(slice *sliceHeader) (*C.TPMS_SIGNATURE_ECC, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsSignatureEccValue) * slice.Len,
		Cap:  int(sizeOfTpmsSignatureEccValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_SIGNATURE_ECC)(mem0), allocs
}

// copyPTpmsNvPinCounterParametersBytes copies the data from Go slice as *C.TPMS_NV_PIN_COUNTER_PARAMETERS.
func copyPTpmsNvPinCounterParametersBytes(slice *sliceHeader) (*C.TPMS_NV_PIN_COUNTER_PARAMETERS, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsNvPinCounterParametersValue) * slice.Len,
		Cap:  int(sizeOfTpmsNvPinCounterParametersValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_NV_PIN_COUNTER_PARAMETERS)(mem0), allocs
}

// copyPTpmsContextDataBytes copies the data from Go slice as *C.TPMS_CONTEXT_DATA.
func copyPTpmsContextDataBytes(slice *sliceHeader) (*C.TPMS_CONTEXT_DATA, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsContextDataValue) * slice.Len,
		Cap:  int(sizeOfTpmsContextDataValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_CONTEXT_DATA)(mem0), allocs
}

// copyPTpmsPcrSelectBytes copies the data from Go slice as *C.TPMS_PCR_SELECT.
func copyPTpmsPcrSelectBytes(slice *sliceHeader) (*C.TPMS_PCR_SELECT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsPcrSelectValue) * slice.Len,
		Cap:  int(sizeOfTpmsPcrSelectValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_PCR_SELECT)(mem0), allocs
}

// copyPTpmsPcrSelectionBytes copies the data from Go slice as *C.TPMS_PCR_SELECTION.
func copyPTpmsPcrSelectionBytes(slice *sliceHeader) (*C.TPMS_PCR_SELECTION, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsPcrSelectionValue) * slice.Len,
		Cap:  int(sizeOfTpmsPcrSelectionValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_PCR_SELECTION)(mem0), allocs
}

// copyPTpmsTaggedPcrSelectBytes copies the data from Go slice as *C.TPMS_TAGGED_PCR_SELECT.
func copyPTpmsTaggedPcrSelectBytes(slice *sliceHeader) (*C.TPMS_TAGGED_PCR_SELECT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsTaggedPcrSelectValue) * slice.Len,
		Cap:  int(sizeOfTpmsTaggedPcrSelectValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_TAGGED_PCR_SELECT)(mem0), allocs
}

// copyPTpmsQuoteInfoBytes copies the data from Go slice as *C.TPMS_QUOTE_INFO.
func copyPTpmsQuoteInfoBytes(slice *sliceHeader) (*C.TPMS_QUOTE_INFO, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsQuoteInfoValue) * slice.Len,
		Cap:  int(sizeOfTpmsQuoteInfoValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_QUOTE_INFO)(mem0), allocs
}

// copyPTpmsCreationDataBytes copies the data from Go slice as *C.TPMS_CREATION_DATA.
func copyPTpmsCreationDataBytes(slice *sliceHeader) (*C.TPMS_CREATION_DATA, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsCreationDataValue) * slice.Len,
		Cap:  int(sizeOfTpmsCreationDataValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_CREATION_DATA)(mem0), allocs
}

// copyPTpmsEccParmsBytes copies the data from Go slice as *C.TPMS_ECC_PARMS.
func copyPTpmsEccParmsBytes(slice *sliceHeader) (*C.TPMS_ECC_PARMS, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsEccParmsValue) * slice.Len,
		Cap:  int(sizeOfTpmsEccParmsValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_ECC_PARMS)(mem0), allocs
}

// copyPTpmsAttestBytes copies the data from Go slice as *C.TPMS_ATTEST.
func copyPTpmsAttestBytes(slice *sliceHeader) (*C.TPMS_ATTEST, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsAttestValue) * slice.Len,
		Cap:  int(sizeOfTpmsAttestValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_ATTEST)(mem0), allocs
}

// copyPTpmsKeyedhashParmsBytes copies the data from Go slice as *C.TPMS_KEYEDHASH_PARMS.
func copyPTpmsKeyedhashParmsBytes(slice *sliceHeader) (*C.TPMS_KEYEDHASH_PARMS, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsKeyedhashParmsValue) * slice.Len,
		Cap:  int(sizeOfTpmsKeyedhashParmsValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_KEYEDHASH_PARMS)(mem0), allocs
}

// copyPTpmsRsaParmsBytes copies the data from Go slice as *C.TPMS_RSA_PARMS.
func copyPTpmsRsaParmsBytes(slice *sliceHeader) (*C.TPMS_RSA_PARMS, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsRsaParmsValue) * slice.Len,
		Cap:  int(sizeOfTpmsRsaParmsValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_RSA_PARMS)(mem0), allocs
}

// copyPTpmsSymcipherParmsBytes copies the data from Go slice as *C.TPMS_SYMCIPHER_PARMS.
func copyPTpmsSymcipherParmsBytes(slice *sliceHeader) (*C.TPMS_SYMCIPHER_PARMS, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsSymcipherParmsValue) * slice.Len,
		Cap:  int(sizeOfTpmsSymcipherParmsValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_SYMCIPHER_PARMS)(mem0), allocs
}

// copyPTpmsIdObjectBytes copies the data from Go slice as *C.TPMS_ID_OBJECT.
func copyPTpmsIdObjectBytes(slice *sliceHeader) (*C.TPMS_ID_OBJECT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsIdObjectValue) * slice.Len,
		Cap:  int(sizeOfTpmsIdObjectValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_ID_OBJECT)(mem0), allocs
}

// copyPTpmlCcaBytes copies the data from Go slice as *C.TPML_CCA.
func copyPTpmlCcaBytes(slice *sliceHeader) (*C.TPML_CCA, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmlCcaValue) * slice.Len,
		Cap:  int(sizeOfTpmlCcaValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPML_CCA)(mem0), allocs
}

// copyPTpmlHandleBytes copies the data from Go slice as *C.TPML_HANDLE.
func copyPTpmlHandleBytes(slice *sliceHeader) (*C.TPML_HANDLE, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmlHandleValue) * slice.Len,
		Cap:  int(sizeOfTpmlHandleValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPML_HANDLE)(mem0), allocs
}

// copyPTpmlAlgPropertyBytes copies the data from Go slice as *C.TPML_ALG_PROPERTY.
func copyPTpmlAlgPropertyBytes(slice *sliceHeader) (*C.TPML_ALG_PROPERTY, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmlAlgPropertyValue) * slice.Len,
		Cap:  int(sizeOfTpmlAlgPropertyValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPML_ALG_PROPERTY)(mem0), allocs
}

// copyPTpmlEccCurveBytes copies the data from Go slice as *C.TPML_ECC_CURVE.
func copyPTpmlEccCurveBytes(slice *sliceHeader) (*C.TPML_ECC_CURVE, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmlEccCurveValue) * slice.Len,
		Cap:  int(sizeOfTpmlEccCurveValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPML_ECC_CURVE)(mem0), allocs
}

// copyPTpmlTaggedPcrPropertyBytes copies the data from Go slice as *C.TPML_TAGGED_PCR_PROPERTY.
func copyPTpmlTaggedPcrPropertyBytes(slice *sliceHeader) (*C.TPML_TAGGED_PCR_PROPERTY, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmlTaggedPcrPropertyValue) * slice.Len,
		Cap:  int(sizeOfTpmlTaggedPcrPropertyValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPML_TAGGED_PCR_PROPERTY)(mem0), allocs
}

// copyPTpmlTaggedTpmPropertyBytes copies the data from Go slice as *C.TPML_TAGGED_TPM_PROPERTY.
func copyPTpmlTaggedTpmPropertyBytes(slice *sliceHeader) (*C.TPML_TAGGED_TPM_PROPERTY, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmlTaggedTpmPropertyValue) * slice.Len,
		Cap:  int(sizeOfTpmlTaggedTpmPropertyValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPML_TAGGED_TPM_PROPERTY)(mem0), allocs
}

// copyPTpmlIntelPttPropertyBytes copies the data from Go slice as *C.TPML_INTEL_PTT_PROPERTY.
func copyPTpmlIntelPttPropertyBytes(slice *sliceHeader) (*C.TPML_INTEL_PTT_PROPERTY, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmlIntelPttPropertyValue) * slice.Len,
		Cap:  int(sizeOfTpmlIntelPttPropertyValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPML_INTEL_PTT_PROPERTY)(mem0), allocs
}

// copyPTpmuHaBytes copies the data from Go slice as *C.TPMU_HA.
func copyPTpmuHaBytes(slice *sliceHeader) (*C.TPMU_HA, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmuHaValue) * slice.Len,
		Cap:  int(sizeOfTpmuHaValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMU_HA)(mem0), allocs
}

// allocTpmuHaMemory allocates memory for type C.TPMU_HA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmuHaMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmuHaValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmuHaValue = unsafe.Sizeof([1]C.TPMU_HA{})

// copyPTpmuCapabilitiesBytes copies the data from Go slice as *C.TPMU_CAPABILITIES.
func copyPTpmuCapabilitiesBytes(slice *sliceHeader) (*C.TPMU_CAPABILITIES, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmuCapabilitiesValue) * slice.Len,
		Cap:  int(sizeOfTpmuCapabilitiesValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMU_CAPABILITIES)(mem0), allocs
}

// allocTpmuCapabilitiesMemory allocates memory for type C.TPMU_CAPABILITIES in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmuCapabilitiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmuCapabilitiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmuCapabilitiesValue = unsafe.Sizeof([1]C.TPMU_CAPABILITIES{})

// copyPTpmuAttestBytes copies the data from Go slice as *C.TPMU_ATTEST.
func copyPTpmuAttestBytes(slice *sliceHeader) (*C.TPMU_ATTEST, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmuAttestValue) * slice.Len,
		Cap:  int(sizeOfTpmuAttestValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMU_ATTEST)(mem0), allocs
}

// allocTpmuAttestMemory allocates memory for type C.TPMU_ATTEST in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmuAttestMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmuAttestValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmuAttestValue = unsafe.Sizeof([1]C.TPMU_ATTEST{})

// copyPTpmuSymKeyBitsBytes copies the data from Go slice as *C.TPMU_SYM_KEY_BITS.
func copyPTpmuSymKeyBitsBytes(slice *sliceHeader) (*C.TPMU_SYM_KEY_BITS, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmuSymKeyBitsValue) * slice.Len,
		Cap:  int(sizeOfTpmuSymKeyBitsValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMU_SYM_KEY_BITS)(mem0), allocs
}

// allocTpmuSymKeyBitsMemory allocates memory for type C.TPMU_SYM_KEY_BITS in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmuSymKeyBitsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmuSymKeyBitsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmuSymKeyBitsValue = unsafe.Sizeof([1]C.TPMU_SYM_KEY_BITS{})

// copyPTpmuSymModeBytes copies the data from Go slice as *C.TPMU_SYM_MODE.
func copyPTpmuSymModeBytes(slice *sliceHeader) (*C.TPMU_SYM_MODE, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmuSymModeValue) * slice.Len,
		Cap:  int(sizeOfTpmuSymModeValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMU_SYM_MODE)(mem0), allocs
}

// allocTpmuSymModeMemory allocates memory for type C.TPMU_SYM_MODE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmuSymModeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmuSymModeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmuSymModeValue = unsafe.Sizeof([1]C.TPMU_SYM_MODE{})

// copyPTpmuSigSchemeBytes copies the data from Go slice as *C.TPMU_SIG_SCHEME.
func copyPTpmuSigSchemeBytes(slice *sliceHeader) (*C.TPMU_SIG_SCHEME, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmuSigSchemeValue) * slice.Len,
		Cap:  int(sizeOfTpmuSigSchemeValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMU_SIG_SCHEME)(mem0), allocs
}

// allocTpmuSigSchemeMemory allocates memory for type C.TPMU_SIG_SCHEME in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmuSigSchemeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmuSigSchemeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmuSigSchemeValue = unsafe.Sizeof([1]C.TPMU_SIG_SCHEME{})

// copyPTpmuKdfSchemeBytes copies the data from Go slice as *C.TPMU_KDF_SCHEME.
func copyPTpmuKdfSchemeBytes(slice *sliceHeader) (*C.TPMU_KDF_SCHEME, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmuKdfSchemeValue) * slice.Len,
		Cap:  int(sizeOfTpmuKdfSchemeValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMU_KDF_SCHEME)(mem0), allocs
}

// allocTpmuKdfSchemeMemory allocates memory for type C.TPMU_KDF_SCHEME in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmuKdfSchemeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmuKdfSchemeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmuKdfSchemeValue = unsafe.Sizeof([1]C.TPMU_KDF_SCHEME{})

// copyPTpmuAsymSchemeBytes copies the data from Go slice as *C.TPMU_ASYM_SCHEME.
func copyPTpmuAsymSchemeBytes(slice *sliceHeader) (*C.TPMU_ASYM_SCHEME, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmuAsymSchemeValue) * slice.Len,
		Cap:  int(sizeOfTpmuAsymSchemeValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMU_ASYM_SCHEME)(mem0), allocs
}

// allocTpmuAsymSchemeMemory allocates memory for type C.TPMU_ASYM_SCHEME in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmuAsymSchemeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmuAsymSchemeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmuAsymSchemeValue = unsafe.Sizeof([1]C.TPMU_ASYM_SCHEME{})

// copyPTpmuSchemeKeyedhashBytes copies the data from Go slice as *C.TPMU_SCHEME_KEYEDHASH.
func copyPTpmuSchemeKeyedhashBytes(slice *sliceHeader) (*C.TPMU_SCHEME_KEYEDHASH, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmuSchemeKeyedhashValue) * slice.Len,
		Cap:  int(sizeOfTpmuSchemeKeyedhashValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMU_SCHEME_KEYEDHASH)(mem0), allocs
}

// allocTpmuSchemeKeyedhashMemory allocates memory for type C.TPMU_SCHEME_KEYEDHASH in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmuSchemeKeyedhashMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmuSchemeKeyedhashValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmuSchemeKeyedhashValue = unsafe.Sizeof([1]C.TPMU_SCHEME_KEYEDHASH{})

// copyPTpmuSignatureBytes copies the data from Go slice as *C.TPMU_SIGNATURE.
func copyPTpmuSignatureBytes(slice *sliceHeader) (*C.TPMU_SIGNATURE, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmuSignatureValue) * slice.Len,
		Cap:  int(sizeOfTpmuSignatureValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMU_SIGNATURE)(mem0), allocs
}

// allocTpmuSignatureMemory allocates memory for type C.TPMU_SIGNATURE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmuSignatureMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmuSignatureValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmuSignatureValue = unsafe.Sizeof([1]C.TPMU_SIGNATURE{})

// copyPTpmuSensitiveCompositeBytes copies the data from Go slice as *C.TPMU_SENSITIVE_COMPOSITE.
func copyPTpmuSensitiveCompositeBytes(slice *sliceHeader) (*C.TPMU_SENSITIVE_COMPOSITE, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmuSensitiveCompositeValue) * slice.Len,
		Cap:  int(sizeOfTpmuSensitiveCompositeValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMU_SENSITIVE_COMPOSITE)(mem0), allocs
}

// allocTpmuSensitiveCompositeMemory allocates memory for type C.TPMU_SENSITIVE_COMPOSITE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmuSensitiveCompositeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmuSensitiveCompositeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmuSensitiveCompositeValue = unsafe.Sizeof([1]C.TPMU_SENSITIVE_COMPOSITE{})

// copyPTpmuPublicParmsBytes copies the data from Go slice as *C.TPMU_PUBLIC_PARMS.
func copyPTpmuPublicParmsBytes(slice *sliceHeader) (*C.TPMU_PUBLIC_PARMS, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmuPublicParmsValue) * slice.Len,
		Cap:  int(sizeOfTpmuPublicParmsValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMU_PUBLIC_PARMS)(mem0), allocs
}

// allocTpmuPublicParmsMemory allocates memory for type C.TPMU_PUBLIC_PARMS in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmuPublicParmsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmuPublicParmsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmuPublicParmsValue = unsafe.Sizeof([1]C.TPMU_PUBLIC_PARMS{})

// copyPTpmuPublicIdBytes copies the data from Go slice as *C.TPMU_PUBLIC_ID.
func copyPTpmuPublicIdBytes(slice *sliceHeader) (*C.TPMU_PUBLIC_ID, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmuPublicIdValue) * slice.Len,
		Cap:  int(sizeOfTpmuPublicIdValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMU_PUBLIC_ID)(mem0), allocs
}

// allocTpmuPublicIdMemory allocates memory for type C.TPMU_PUBLIC_ID in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmuPublicIdMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmuPublicIdValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmuPublicIdValue = unsafe.Sizeof([1]C.TPMU_PUBLIC_ID{})

// copyPTpmuNameBytes copies the data from Go slice as *C.TPMU_NAME.
func copyPTpmuNameBytes(slice *sliceHeader) (*C.TPMU_NAME, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmuNameValue) * slice.Len,
		Cap:  int(sizeOfTpmuNameValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMU_NAME)(mem0), allocs
}

// allocTpmuNameMemory allocates memory for type C.TPMU_NAME in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmuNameMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmuNameValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmuNameValue = unsafe.Sizeof([1]C.TPMU_NAME{})

// copyPTpmtKeyedhashSchemeBytes copies the data from Go slice as *C.TPMT_KEYEDHASH_SCHEME.
func copyPTpmtKeyedhashSchemeBytes(slice *sliceHeader) (*C.TPMT_KEYEDHASH_SCHEME, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmtKeyedhashSchemeValue) * slice.Len,
		Cap:  int(sizeOfTpmtKeyedhashSchemeValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMT_KEYEDHASH_SCHEME)(mem0), allocs
}

// copyPTpmtKdfSchemeBytes copies the data from Go slice as *C.TPMT_KDF_SCHEME.
func copyPTpmtKdfSchemeBytes(slice *sliceHeader) (*C.TPMT_KDF_SCHEME, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmtKdfSchemeValue) * slice.Len,
		Cap:  int(sizeOfTpmtKdfSchemeValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMT_KDF_SCHEME)(mem0), allocs
}

// copyPTpmtAsymSchemeBytes copies the data from Go slice as *C.TPMT_ASYM_SCHEME.
func copyPTpmtAsymSchemeBytes(slice *sliceHeader) (*C.TPMT_ASYM_SCHEME, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmtAsymSchemeValue) * slice.Len,
		Cap:  int(sizeOfTpmtAsymSchemeValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMT_ASYM_SCHEME)(mem0), allocs
}

// copyPTpmtRsaSchemeBytes copies the data from Go slice as *C.TPMT_RSA_SCHEME.
func copyPTpmtRsaSchemeBytes(slice *sliceHeader) (*C.TPMT_RSA_SCHEME, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmtRsaSchemeValue) * slice.Len,
		Cap:  int(sizeOfTpmtRsaSchemeValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMT_RSA_SCHEME)(mem0), allocs
}

// copyPTpmtEccSchemeBytes copies the data from Go slice as *C.TPMT_ECC_SCHEME.
func copyPTpmtEccSchemeBytes(slice *sliceHeader) (*C.TPMT_ECC_SCHEME, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmtEccSchemeValue) * slice.Len,
		Cap:  int(sizeOfTpmtEccSchemeValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMT_ECC_SCHEME)(mem0), allocs
}

// copyPTpmtSensitiveBytes copies the data from Go slice as *C.TPMT_SENSITIVE.
func copyPTpmtSensitiveBytes(slice *sliceHeader) (*C.TPMT_SENSITIVE, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmtSensitiveValue) * slice.Len,
		Cap:  int(sizeOfTpmtSensitiveValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMT_SENSITIVE)(mem0), allocs
}

// copyPTpmtPublicBytes copies the data from Go slice as *C.TPMT_PUBLIC.
func copyPTpmtPublicBytes(slice *sliceHeader) (*C.TPMT_PUBLIC, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmtPublicValue) * slice.Len,
		Cap:  int(sizeOfTpmtPublicValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMT_PUBLIC)(mem0), allocs
}

// copyPTpmiAlgHashBytes copies the data from Go slice as *C.TPMI_ALG_HASH.
func copyPTpmiAlgHashBytes(slice *sliceHeader) (*C.TPMI_ALG_HASH, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmiAlgHashValue) * slice.Len,
		Cap:  int(sizeOfTpmiAlgHashValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMI_ALG_HASH)(mem0), allocs
}

// allocTpmiAlgHashMemory allocates memory for type C.TPMI_ALG_HASH in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmiAlgHashMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmiAlgHashValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmiAlgHashValue = unsafe.Sizeof([1]C.TPMI_ALG_HASH{})

// copyPTpm2SeBytes copies the data from Go slice as *C.TPM2_SE.
func copyPTpm2SeBytes(slice *sliceHeader) (*C.TPM2_SE, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2SeValue) * slice.Len,
		Cap:  int(sizeOfTpm2SeValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2_SE)(mem0), allocs
}

// allocTpm2SeMemory allocates memory for type C.TPM2_SE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2SeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2SeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2SeValue = unsafe.Sizeof([1]C.TPM2_SE{})

// copyPTpm2NtBytes copies the data from Go slice as *C.TPM2_NT.
func copyPTpm2NtBytes(slice *sliceHeader) (*C.TPM2_NT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2NtValue) * slice.Len,
		Cap:  int(sizeOfTpm2NtValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2_NT)(mem0), allocs
}

// allocTpm2NtMemory allocates memory for type C.TPM2_NT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2NtMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2NtValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2NtValue = unsafe.Sizeof([1]C.TPM2_NT{})

// copyPTpmsEmptyBytes copies the data from Go slice as *C.TPMS_EMPTY.
func copyPTpmsEmptyBytes(slice *sliceHeader) (*C.TPMS_EMPTY, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsEmptyValue) * slice.Len,
		Cap:  int(sizeOfTpmsEmptyValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_EMPTY)(mem0), allocs
}

// copyPStructRandomDataBytes copies the data from Go slice as *C.struct_random_data.
func copyPStructRandomDataBytes(slice *sliceHeader) (*C.struct_random_data, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfStructRandomDataValue) * slice.Len,
		Cap:  int(sizeOfStructRandomDataValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.struct_random_data)(mem0), allocs
}

// copyPInt32TBytes copies the data from Go slice as *C.int32_t.
func copyPInt32TBytes(slice *sliceHeader) (*C.int32_t, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfInt32TValue) * slice.Len,
		Cap:  int(sizeOfInt32TValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.int32_t)(mem0), allocs
}

// allocInt32TMemory allocates memory for type C.int32_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocInt32TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfInt32TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfInt32TValue = unsafe.Sizeof([1]C.int32_t{})

// copyPUintBytes copies the data from Go slice as *C.uint.
func copyPUintBytes(slice *sliceHeader) (*C.uint, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfUintValue) * slice.Len,
		Cap:  int(sizeOfUintValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.uint)(mem0), allocs
}

// allocUintMemory allocates memory for type C.uint in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUintMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUintValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUintValue = unsafe.Sizeof([1]C.uint{})

// copyPStructDrand48DataBytes copies the data from Go slice as *C.struct_drand48_data.
func copyPStructDrand48DataBytes(slice *sliceHeader) (*C.struct_drand48_data, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfStructDrand48DataValue) * slice.Len,
		Cap:  int(sizeOfStructDrand48DataValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.struct_drand48_data)(mem0), allocs
}

// copyPDoubleBytes copies the data from Go slice as *C.double.
func copyPDoubleBytes(slice *sliceHeader) (*C.double, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfDoubleValue) * slice.Len,
		Cap:  int(sizeOfDoubleValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.double)(mem0), allocs
}

// allocDoubleMemory allocates memory for type C.double in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDoubleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDoubleValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDoubleValue = unsafe.Sizeof([1]C.double{})

// copyPLongBytes copies the data from Go slice as *C.long.
func copyPLongBytes(slice *sliceHeader) (*C.long, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfLongValue) * slice.Len,
		Cap:  int(sizeOfLongValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.long)(mem0), allocs
}

// allocLongMemory allocates memory for type C.long in C.
// The caller is responsible for freeing the this memory via C.free.
func allocLongMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfLongValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfLongValue = unsafe.Sizeof([1]C.long{})

// copyPUnsafePointerBytes copies the data from Go slice as *unsafe.Pointer.
func copyPUnsafePointerBytes(slice *sliceHeader) (*unsafe.Pointer, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfUnsafePointerValue) * slice.Len,
		Cap:  int(sizeOfUnsafePointerValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*unsafe.Pointer)(mem0), allocs
}

// allocUnsafePointerMemory allocates memory for type unsafe.Pointer in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUnsafePointerMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUnsafePointerValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUnsafePointerValue = unsafe.Sizeof([1]unsafe.Pointer{})

// copyPIntBytes copies the data from Go slice as *C.int.
func copyPIntBytes(slice *sliceHeader) (*C.int, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfIntValue) * slice.Len,
		Cap:  int(sizeOfIntValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.int)(mem0), allocs
}

// allocIntMemory allocates memory for type C.int in C.
// The caller is responsible for freeing the this memory via C.free.
func allocIntMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfIntValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfIntValue = unsafe.Sizeof([1]C.int{})

// copyPWcharTBytes copies the data from Go slice as *C.wchar_t.
func copyPWcharTBytes(slice *sliceHeader) (*C.wchar_t, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfWcharTValue) * slice.Len,
		Cap:  int(sizeOfWcharTValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.wchar_t)(mem0), allocs
}

// allocWcharTMemory allocates memory for type C.wchar_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocWcharTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfWcharTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfWcharTValue = unsafe.Sizeof([1]C.wchar_t{})

// allocPCharMemory allocates memory for type *C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPCharValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPCharValue = unsafe.Sizeof([1]*C.char{})

// unpackArgSSByte transforms a sliced Go data structure into plain C format.
func unpackArgSSByte(x [][]byte) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.char)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(h.Data)
	return
}

// packSSByte reads sliced Go data structure out from plain C format.
func packSSByte(v [][]byte, ptr0 **C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr0)))[i0]
		hxfac6ee5 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxfac6ee5.Data = unsafe.Pointer(ptr1)
		hxfac6ee5.Cap = 0x7fffffff
		// hxfac6ee5.Len = ?
	}
}

// allocPTss2TctiInfoMemory allocates memory for type *C.TSS2_TCTI_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTss2TctiInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTss2TctiInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTss2TctiInfoValue = unsafe.Sizeof([1]*C.TSS2_TCTI_INFO{})

// unpackArgSSTss2TctiInfo transforms a sliced Go data structure into plain C format.
func unpackArgSSTss2TctiInfo(x [][]Tss2TctiInfo) (unpacked **C.TSS2_TCTI_INFO, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTss2TctiInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TSS2_TCTI_INFO)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTss2TctiInfoMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TSS2_TCTI_INFO)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TSS2_TCTI_INFO)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TSS2_TCTI_INFO)(h.Data)
	return
}

// packSSTss2TctiInfo reads sliced Go data structure out from plain C format.
func packSSTss2TctiInfo(v [][]Tss2TctiInfo, ptr0 **C.TSS2_TCTI_INFO) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TSS2_TCTI_INFO)(unsafe.Pointer(ptr0)))[i0]
		hxf65874b := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf65874b.Data = unsafe.Pointer(ptr1)
		hxf65874b.Cap = 0x7fffffff
		// hxf65874b.Len = ?
	}
}

// copyP_GwcharTBytes copies the data from Go slice as *C.__gwchar_t.
func copyP_GwcharTBytes(slice *sliceHeader) (*C.__gwchar_t, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOf_GwcharTValue) * slice.Len,
		Cap:  int(sizeOf_GwcharTValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.__gwchar_t)(mem0), allocs
}

// alloc_GwcharTMemory allocates memory for type C.__gwchar_t in C.
// The caller is responsible for freeing the this memory via C.free.
func alloc_GwcharTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOf_GwcharTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOf_GwcharTValue = unsafe.Sizeof([1]C.__gwchar_t{})

// allocP_GwcharTMemory allocates memory for type *C.__gwchar_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocP_GwcharTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfP_GwcharTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfP_GwcharTValue = unsafe.Sizeof([1]*C.__gwchar_t{})

// unpackArgSSInt32 transforms a sliced Go data structure into plain C format.
func unpackArgSSInt32(x [][]int32) (unpacked **C.__gwchar_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocP_GwcharTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.__gwchar_t)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.__gwchar_t)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.__gwchar_t)(h.Data)
	return
}

// packSSInt32 reads sliced Go data structure out from plain C format.
func packSSInt32(v [][]int32, ptr0 **C.__gwchar_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.__gwchar_t)(unsafe.Pointer(ptr0)))[i0]
		hxfd898f3 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxfd898f3.Data = unsafe.Pointer(ptr1)
		hxfd898f3.Cap = 0x7fffffff
		// hxfd898f3.Len = ?
	}
}
