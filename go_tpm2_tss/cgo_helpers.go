// License: CC-0

// WARNING: This file has automatically been generated on Sat, 17 Apr 2021 22:05:09 IST.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package go_tpm2_tss

/*
#cgo pkg-config: tss2-tcti-mssim tss2-tcti-device tss2-mu tss2-tctildr tss2-rc tss2-sys tss2-esys
#cgo CFLAGS: -I ../c/include
#include "tss2/tss2_common.h"
#include "tss2/tss2_esys.h"
#include "tss2/tss2_mu.h"
#include "tss2/tss2_rc.h"
#include "tss2/tss2_sys.h"
#include "tss2/tss2_tcti_device.h"
#include "tss2/tss2_tcti.h"
#include "tss2/tss2_tctildr.h"
#include "tss2/tss2_tcti_mssim.h"
#include "tss2/tss2_tcti_tbs.h"
#include "tss2/tss2_tpm2_types.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocTss2AbiVersionMemory allocates memory for type C.TSS2_ABI_VERSION in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTss2AbiVersionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTss2AbiVersionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTss2AbiVersionValue = unsafe.Sizeof([1]C.TSS2_ABI_VERSION{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Tss2AbiVersion) Ref() *C.TSS2_ABI_VERSION {
	if x == nil {
		return nil
	}
	return x.ref731c8581
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Tss2AbiVersion) Free() {
	if x != nil && x.allocs731c8581 != nil {
		x.allocs731c8581.(*cgoAllocMap).Free()
		x.ref731c8581 = nil
	}
}

// NewTss2AbiVersionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTss2AbiVersionRef(ref unsafe.Pointer) *Tss2AbiVersion {
	if ref == nil {
		return nil
	}
	obj := new(Tss2AbiVersion)
	obj.ref731c8581 = (*C.TSS2_ABI_VERSION)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Tss2AbiVersion) PassRef() (*C.TSS2_ABI_VERSION, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref731c8581 != nil {
		return x.ref731c8581, nil
	}
	mem731c8581 := allocTss2AbiVersionMemory(1)
	ref731c8581 := (*C.TSS2_ABI_VERSION)(mem731c8581)
	allocs731c8581 := new(cgoAllocMap)
	allocs731c8581.Add(mem731c8581)

	var ctssCreator_allocs *cgoAllocMap
	ref731c8581.tssCreator, ctssCreator_allocs = (C.uint32_t)(x.Tsscreator), cgoAllocsUnknown
	allocs731c8581.Borrow(ctssCreator_allocs)

	var ctssFamily_allocs *cgoAllocMap
	ref731c8581.tssFamily, ctssFamily_allocs = (C.uint32_t)(x.Tssfamily), cgoAllocsUnknown
	allocs731c8581.Borrow(ctssFamily_allocs)

	var ctssLevel_allocs *cgoAllocMap
	ref731c8581.tssLevel, ctssLevel_allocs = (C.uint32_t)(x.Tsslevel), cgoAllocsUnknown
	allocs731c8581.Borrow(ctssLevel_allocs)

	var ctssVersion_allocs *cgoAllocMap
	ref731c8581.tssVersion, ctssVersion_allocs = (C.uint32_t)(x.Tssversion), cgoAllocsUnknown
	allocs731c8581.Borrow(ctssVersion_allocs)

	x.ref731c8581 = ref731c8581
	x.allocs731c8581 = allocs731c8581
	return ref731c8581, allocs731c8581

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Tss2AbiVersion) PassValue() (C.TSS2_ABI_VERSION, *cgoAllocMap) {
	if x.ref731c8581 != nil {
		return *x.ref731c8581, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Tss2AbiVersion) Deref() {
	if x.ref731c8581 == nil {
		return
	}
	x.Tsscreator = (Uint32T)(x.ref731c8581.tssCreator)
	x.Tssfamily = (Uint32T)(x.ref731c8581.tssFamily)
	x.Tsslevel = (Uint32T)(x.ref731c8581.tssLevel)
	x.Tssversion = (Uint32T)(x.ref731c8581.tssVersion)
}

// Ref returns a reference to C object as it is.
func (x *EsysContext) Ref() *C.ESYS_CONTEXT {
	if x == nil {
		return nil
	}
	return (*C.ESYS_CONTEXT)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *EsysContext) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewEsysContextRef converts the C object reference into a raw struct reference without wrapping.
func NewEsysContextRef(ref unsafe.Pointer) *EsysContext {
	return (*EsysContext)(ref)
}

// NewEsysContext allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewEsysContext() *EsysContext {
	return (*EsysContext)(allocEsysContextMemory(1))
}

// allocEsysContextMemory allocates memory for type C.ESYS_CONTEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocEsysContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfEsysContextValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfEsysContextValue = unsafe.Sizeof([1]C.ESYS_CONTEXT{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *EsysContext) PassRef() *C.ESYS_CONTEXT {
	if x == nil {
		x = (*EsysContext)(allocEsysContextMemory(1))
	}
	return (*C.ESYS_CONTEXT)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tss2TctiContext) Ref() *C.TSS2_TCTI_CONTEXT {
	if x == nil {
		return nil
	}
	return (*C.TSS2_TCTI_CONTEXT)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tss2TctiContext) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTss2TctiContextRef converts the C object reference into a raw struct reference without wrapping.
func NewTss2TctiContextRef(ref unsafe.Pointer) *Tss2TctiContext {
	return (*Tss2TctiContext)(ref)
}

// NewTss2TctiContext allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTss2TctiContext() *Tss2TctiContext {
	return (*Tss2TctiContext)(allocTss2TctiContextMemory(1))
}

// allocTss2TctiContextMemory allocates memory for type C.TSS2_TCTI_CONTEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTss2TctiContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTss2TctiContextValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTss2TctiContextValue = unsafe.Sizeof([1]C.TSS2_TCTI_CONTEXT{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tss2TctiContext) PassRef() *C.TSS2_TCTI_CONTEXT {
	if x == nil {
		x = (*Tss2TctiContext)(allocTss2TctiContextMemory(1))
	}
	return (*C.TSS2_TCTI_CONTEXT)(unsafe.Pointer(x))
}

func (x Tss2TctiTransmitFcn) PassRef() (ref *C.TSS2_TCTI_TRANSMIT_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiTransmitFcn3FB81C0DFunc == nil {
		tss2TctiTransmitFcn3FB81C0DFunc = x
	}
	return (*C.TSS2_TCTI_TRANSMIT_FCN)(C.TSS2_TCTI_TRANSMIT_FCN_3fb81c0d), nil
}

func (x Tss2TctiTransmitFcn) PassValue() (ref C.TSS2_TCTI_TRANSMIT_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiTransmitFcn3FB81C0DFunc == nil {
		tss2TctiTransmitFcn3FB81C0DFunc = x
	}
	return (C.TSS2_TCTI_TRANSMIT_FCN)(C.TSS2_TCTI_TRANSMIT_FCN_3fb81c0d), nil
}

func NewTss2TctiTransmitFcnRef(ref unsafe.Pointer) *Tss2TctiTransmitFcn {
	return (*Tss2TctiTransmitFcn)(ref)
}

//export tss2TctiTransmitFcn3FB81C0D
func tss2TctiTransmitFcn3FB81C0D(ctcticontext *C.TSS2_TCTI_CONTEXT, csize C.size_t, ccommand *C.uint8_t) C.TSS2_RC {
	if tss2TctiTransmitFcn3FB81C0DFunc != nil {
		tcticontext3fb81c0d := (*Tss2TctiContext)(unsafe.Pointer(ctcticontext))
		size3fb81c0d := (SizeT)(csize)
		command3fb81c0d := (*Uint8T)(unsafe.Pointer(ccommand))
		ret3fb81c0d := tss2TctiTransmitFcn3FB81C0DFunc(tcticontext3fb81c0d, size3fb81c0d, command3fb81c0d)
		ret, _ := (C.TSS2_RC)(ret3fb81c0d), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var tss2TctiTransmitFcn3FB81C0DFunc Tss2TctiTransmitFcn

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

func (x Tss2TctiReceiveFcn) PassRef() (ref *C.TSS2_TCTI_RECEIVE_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiReceiveFcnF4548F13Func == nil {
		tss2TctiReceiveFcnF4548F13Func = x
	}
	return (*C.TSS2_TCTI_RECEIVE_FCN)(C.TSS2_TCTI_RECEIVE_FCN_f4548f13), nil
}

func (x Tss2TctiReceiveFcn) PassValue() (ref C.TSS2_TCTI_RECEIVE_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiReceiveFcnF4548F13Func == nil {
		tss2TctiReceiveFcnF4548F13Func = x
	}
	return (C.TSS2_TCTI_RECEIVE_FCN)(C.TSS2_TCTI_RECEIVE_FCN_f4548f13), nil
}

func NewTss2TctiReceiveFcnRef(ref unsafe.Pointer) *Tss2TctiReceiveFcn {
	return (*Tss2TctiReceiveFcn)(ref)
}

//export tss2TctiReceiveFcnF4548F13
func tss2TctiReceiveFcnF4548F13(ctcticontext *C.TSS2_TCTI_CONTEXT, csize *C.size_t, cresponse *C.uint8_t, ctimeout C.int32_t) C.TSS2_RC {
	if tss2TctiReceiveFcnF4548F13Func != nil {
		tcticontextf4548f13 := (*Tss2TctiContext)(unsafe.Pointer(ctcticontext))
		var sizef4548f13 []SizeT
		hxfc4425b := (*sliceHeader)(unsafe.Pointer(&sizef4548f13))
		hxfc4425b.Data = unsafe.Pointer(csize)
		hxfc4425b.Cap = 0x7fffffff
		// hxfc4425b.Len = ?

		responsef4548f13 := (*Uint8T)(unsafe.Pointer(cresponse))
		timeoutf4548f13 := (Int32T)(ctimeout)
		retf4548f13 := tss2TctiReceiveFcnF4548F13Func(tcticontextf4548f13, sizef4548f13, responsef4548f13, timeoutf4548f13)
		ret, _ := (C.TSS2_RC)(retf4548f13), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var tss2TctiReceiveFcnF4548F13Func Tss2TctiReceiveFcn

func (x Tss2TctiFinalizeFcn) PassRef() (ref *C.TSS2_TCTI_FINALIZE_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiFinalizeFcnF5E8712EFunc == nil {
		tss2TctiFinalizeFcnF5E8712EFunc = x
	}
	return (*C.TSS2_TCTI_FINALIZE_FCN)(C.TSS2_TCTI_FINALIZE_FCN_f5e8712e), nil
}

func (x Tss2TctiFinalizeFcn) PassValue() (ref C.TSS2_TCTI_FINALIZE_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiFinalizeFcnF5E8712EFunc == nil {
		tss2TctiFinalizeFcnF5E8712EFunc = x
	}
	return (C.TSS2_TCTI_FINALIZE_FCN)(C.TSS2_TCTI_FINALIZE_FCN_f5e8712e), nil
}

func NewTss2TctiFinalizeFcnRef(ref unsafe.Pointer) *Tss2TctiFinalizeFcn {
	return (*Tss2TctiFinalizeFcn)(ref)
}

//export tss2TctiFinalizeFcnF5E8712E
func tss2TctiFinalizeFcnF5E8712E(ctcticontext *C.TSS2_TCTI_CONTEXT) {
	if tss2TctiFinalizeFcnF5E8712EFunc != nil {
		tcticontextf5e8712e := (*Tss2TctiContext)(unsafe.Pointer(ctcticontext))
		tss2TctiFinalizeFcnF5E8712EFunc(tcticontextf5e8712e)
		return
	}
	panic("callback func has not been set (race?)")
}

var tss2TctiFinalizeFcnF5E8712EFunc Tss2TctiFinalizeFcn

func (x Tss2TctiCancelFcn) PassRef() (ref *C.TSS2_TCTI_CANCEL_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiCancelFcn900241EBFunc == nil {
		tss2TctiCancelFcn900241EBFunc = x
	}
	return (*C.TSS2_TCTI_CANCEL_FCN)(C.TSS2_TCTI_CANCEL_FCN_900241eb), nil
}

func (x Tss2TctiCancelFcn) PassValue() (ref C.TSS2_TCTI_CANCEL_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiCancelFcn900241EBFunc == nil {
		tss2TctiCancelFcn900241EBFunc = x
	}
	return (C.TSS2_TCTI_CANCEL_FCN)(C.TSS2_TCTI_CANCEL_FCN_900241eb), nil
}

func NewTss2TctiCancelFcnRef(ref unsafe.Pointer) *Tss2TctiCancelFcn {
	return (*Tss2TctiCancelFcn)(ref)
}

//export tss2TctiCancelFcn900241EB
func tss2TctiCancelFcn900241EB(ctcticontext *C.TSS2_TCTI_CONTEXT) C.TSS2_RC {
	if tss2TctiCancelFcn900241EBFunc != nil {
		tcticontext900241eb := (*Tss2TctiContext)(unsafe.Pointer(ctcticontext))
		ret900241eb := tss2TctiCancelFcn900241EBFunc(tcticontext900241eb)
		ret, _ := (C.TSS2_RC)(ret900241eb), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var tss2TctiCancelFcn900241EBFunc Tss2TctiCancelFcn

func (x Tss2TctiGetPollHandlesFcn) PassRef() (ref *C.TSS2_TCTI_GET_POLL_HANDLES_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiGetPollHandlesFcnD9753DA9Func == nil {
		tss2TctiGetPollHandlesFcnD9753DA9Func = x
	}
	return (*C.TSS2_TCTI_GET_POLL_HANDLES_FCN)(C.TSS2_TCTI_GET_POLL_HANDLES_FCN_d9753da9), nil
}

func (x Tss2TctiGetPollHandlesFcn) PassValue() (ref C.TSS2_TCTI_GET_POLL_HANDLES_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiGetPollHandlesFcnD9753DA9Func == nil {
		tss2TctiGetPollHandlesFcnD9753DA9Func = x
	}
	return (C.TSS2_TCTI_GET_POLL_HANDLES_FCN)(C.TSS2_TCTI_GET_POLL_HANDLES_FCN_d9753da9), nil
}

func NewTss2TctiGetPollHandlesFcnRef(ref unsafe.Pointer) *Tss2TctiGetPollHandlesFcn {
	return (*Tss2TctiGetPollHandlesFcn)(ref)
}

//export tss2TctiGetPollHandlesFcnD9753DA9
func tss2TctiGetPollHandlesFcnD9753DA9(ctcticontext *C.TSS2_TCTI_CONTEXT, chandles *C.TSS2_TCTI_POLL_HANDLE, cnumHandles *C.size_t) C.TSS2_RC {
	if tss2TctiGetPollHandlesFcnD9753DA9Func != nil {
		tcticontextd9753da9 := (*Tss2TctiContext)(unsafe.Pointer(ctcticontext))
		handlesd9753da9 := (*Tss2TctiPollHandle)(unsafe.Pointer(chandles))
		numHandlesd9753da9 := (*SizeT)(unsafe.Pointer(cnumHandles))
		retd9753da9 := tss2TctiGetPollHandlesFcnD9753DA9Func(tcticontextd9753da9, handlesd9753da9, numHandlesd9753da9)
		ret, _ := (C.TSS2_RC)(retd9753da9), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var tss2TctiGetPollHandlesFcnD9753DA9Func Tss2TctiGetPollHandlesFcn

func (x Tss2TctiSetLocalityFcn) PassRef() (ref *C.TSS2_TCTI_SET_LOCALITY_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiSetLocalityFcn47C1ECDAFunc == nil {
		tss2TctiSetLocalityFcn47C1ECDAFunc = x
	}
	return (*C.TSS2_TCTI_SET_LOCALITY_FCN)(C.TSS2_TCTI_SET_LOCALITY_FCN_47c1ecda), nil
}

func (x Tss2TctiSetLocalityFcn) PassValue() (ref C.TSS2_TCTI_SET_LOCALITY_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiSetLocalityFcn47C1ECDAFunc == nil {
		tss2TctiSetLocalityFcn47C1ECDAFunc = x
	}
	return (C.TSS2_TCTI_SET_LOCALITY_FCN)(C.TSS2_TCTI_SET_LOCALITY_FCN_47c1ecda), nil
}

func NewTss2TctiSetLocalityFcnRef(ref unsafe.Pointer) *Tss2TctiSetLocalityFcn {
	return (*Tss2TctiSetLocalityFcn)(ref)
}

//export tss2TctiSetLocalityFcn47C1ECDA
func tss2TctiSetLocalityFcn47C1ECDA(ctcticontext *C.TSS2_TCTI_CONTEXT, clocality C.uint8_t) C.TSS2_RC {
	if tss2TctiSetLocalityFcn47C1ECDAFunc != nil {
		tcticontext47c1ecda := (*Tss2TctiContext)(unsafe.Pointer(ctcticontext))
		locality47c1ecda := (Uint8T)(clocality)
		ret47c1ecda := tss2TctiSetLocalityFcn47C1ECDAFunc(tcticontext47c1ecda, locality47c1ecda)
		ret, _ := (C.TSS2_RC)(ret47c1ecda), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var tss2TctiSetLocalityFcn47C1ECDAFunc Tss2TctiSetLocalityFcn

func (x Tss2TctiMakeStickyFcn) PassRef() (ref *C.TSS2_TCTI_MAKE_STICKY_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiMakeStickyFcnDE2406FCFunc == nil {
		tss2TctiMakeStickyFcnDE2406FCFunc = x
	}
	return (*C.TSS2_TCTI_MAKE_STICKY_FCN)(C.TSS2_TCTI_MAKE_STICKY_FCN_de2406fc), nil
}

func (x Tss2TctiMakeStickyFcn) PassValue() (ref C.TSS2_TCTI_MAKE_STICKY_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiMakeStickyFcnDE2406FCFunc == nil {
		tss2TctiMakeStickyFcnDE2406FCFunc = x
	}
	return (C.TSS2_TCTI_MAKE_STICKY_FCN)(C.TSS2_TCTI_MAKE_STICKY_FCN_de2406fc), nil
}

func NewTss2TctiMakeStickyFcnRef(ref unsafe.Pointer) *Tss2TctiMakeStickyFcn {
	return (*Tss2TctiMakeStickyFcn)(ref)
}

//export tss2TctiMakeStickyFcnDE2406FC
func tss2TctiMakeStickyFcnDE2406FC(ctcticontext *C.TSS2_TCTI_CONTEXT, chandle *C.TPM2_HANDLE, csticky C.uint8_t) C.TSS2_RC {
	if tss2TctiMakeStickyFcnDE2406FCFunc != nil {
		tcticontextde2406fc := (*Tss2TctiContext)(unsafe.Pointer(ctcticontext))
		var handlede2406fc []Tpm2Handle
		hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&handlede2406fc))
		hxf95e7c8.Data = unsafe.Pointer(chandle)
		hxf95e7c8.Cap = 0x7fffffff
		// hxf95e7c8.Len = ?

		stickyde2406fc := (Uint8T)(csticky)
		retde2406fc := tss2TctiMakeStickyFcnDE2406FCFunc(tcticontextde2406fc, handlede2406fc, stickyde2406fc)
		ret, _ := (C.TSS2_RC)(retde2406fc), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var tss2TctiMakeStickyFcnDE2406FCFunc Tss2TctiMakeStickyFcn

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}

func (x Tss2TctiInitFunc) PassRef() (ref *C.TSS2_TCTI_INIT_FUNC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiInitFuncA5EFFE61Func == nil {
		tss2TctiInitFuncA5EFFE61Func = x
	}
	return (*C.TSS2_TCTI_INIT_FUNC)(C.TSS2_TCTI_INIT_FUNC_a5effe61), nil
}

func (x Tss2TctiInitFunc) PassValue() (ref C.TSS2_TCTI_INIT_FUNC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiInitFuncA5EFFE61Func == nil {
		tss2TctiInitFuncA5EFFE61Func = x
	}
	return (C.TSS2_TCTI_INIT_FUNC)(C.TSS2_TCTI_INIT_FUNC_a5effe61), nil
}

func NewTss2TctiInitFuncRef(ref unsafe.Pointer) *Tss2TctiInitFunc {
	return (*Tss2TctiInitFunc)(ref)
}

//export tss2TctiInitFuncA5EFFE61
func tss2TctiInitFuncA5EFFE61(ctcticontext *C.TSS2_TCTI_CONTEXT, csize *C.size_t, cconfig *C.char) C.TSS2_RC {
	if tss2TctiInitFuncA5EFFE61Func != nil {
		tcticontexta5effe61 := (*Tss2TctiContext)(unsafe.Pointer(ctcticontext))
		var sizea5effe61 []uint32
		hxff2234b := (*sliceHeader)(unsafe.Pointer(&sizea5effe61))
		hxff2234b.Data = unsafe.Pointer(csize)
		hxff2234b.Cap = 0x7fffffff
		// hxff2234b.Len = ?

		configa5effe61 := packPCharString(cconfig)
		reta5effe61 := tss2TctiInitFuncA5EFFE61Func(tcticontexta5effe61, sizea5effe61, configa5effe61)
		ret, _ := (C.TSS2_RC)(reta5effe61), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var tss2TctiInitFuncA5EFFE61Func Tss2TctiInitFunc

// allocTss2TctiContextCommonV1Memory allocates memory for type C.TSS2_TCTI_CONTEXT_COMMON_V1 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTss2TctiContextCommonV1Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTss2TctiContextCommonV1Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTss2TctiContextCommonV1Value = unsafe.Sizeof([1]C.TSS2_TCTI_CONTEXT_COMMON_V1{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Tss2TctiContextCommonV1) Ref() *C.TSS2_TCTI_CONTEXT_COMMON_V1 {
	if x == nil {
		return nil
	}
	return x.ref6a31a31a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Tss2TctiContextCommonV1) Free() {
	if x != nil && x.allocs6a31a31a != nil {
		x.allocs6a31a31a.(*cgoAllocMap).Free()
		x.ref6a31a31a = nil
	}
}

// NewTss2TctiContextCommonV1Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTss2TctiContextCommonV1Ref(ref unsafe.Pointer) *Tss2TctiContextCommonV1 {
	if ref == nil {
		return nil
	}
	obj := new(Tss2TctiContextCommonV1)
	obj.ref6a31a31a = (*C.TSS2_TCTI_CONTEXT_COMMON_V1)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Tss2TctiContextCommonV1) PassRef() (*C.TSS2_TCTI_CONTEXT_COMMON_V1, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6a31a31a != nil {
		return x.ref6a31a31a, nil
	}
	mem6a31a31a := allocTss2TctiContextCommonV1Memory(1)
	ref6a31a31a := (*C.TSS2_TCTI_CONTEXT_COMMON_V1)(mem6a31a31a)
	allocs6a31a31a := new(cgoAllocMap)
	allocs6a31a31a.Add(mem6a31a31a)

	var cmagic_allocs *cgoAllocMap
	ref6a31a31a.magic, cmagic_allocs = (C.uint64_t)(x.Magic), cgoAllocsUnknown
	allocs6a31a31a.Borrow(cmagic_allocs)

	var cversion_allocs *cgoAllocMap
	ref6a31a31a.version, cversion_allocs = (C.uint32_t)(x.Version), cgoAllocsUnknown
	allocs6a31a31a.Borrow(cversion_allocs)

	var ctransmit_allocs *cgoAllocMap
	ref6a31a31a.transmit, ctransmit_allocs = x.Transmit.PassValue()
	allocs6a31a31a.Borrow(ctransmit_allocs)

	var creceive_allocs *cgoAllocMap
	ref6a31a31a.receive, creceive_allocs = x.Receive.PassValue()
	allocs6a31a31a.Borrow(creceive_allocs)

	var cfinalize_allocs *cgoAllocMap
	ref6a31a31a.finalize, cfinalize_allocs = x.Finalize.PassValue()
	allocs6a31a31a.Borrow(cfinalize_allocs)

	var ccancel_allocs *cgoAllocMap
	ref6a31a31a.cancel, ccancel_allocs = x.Cancel.PassValue()
	allocs6a31a31a.Borrow(ccancel_allocs)

	var cgetPollHandles_allocs *cgoAllocMap
	ref6a31a31a.getPollHandles, cgetPollHandles_allocs = x.Getpollhandles.PassValue()
	allocs6a31a31a.Borrow(cgetPollHandles_allocs)

	var csetLocality_allocs *cgoAllocMap
	ref6a31a31a.setLocality, csetLocality_allocs = x.Setlocality.PassValue()
	allocs6a31a31a.Borrow(csetLocality_allocs)

	x.ref6a31a31a = ref6a31a31a
	x.allocs6a31a31a = allocs6a31a31a
	return ref6a31a31a, allocs6a31a31a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Tss2TctiContextCommonV1) PassValue() (C.TSS2_TCTI_CONTEXT_COMMON_V1, *cgoAllocMap) {
	if x.ref6a31a31a != nil {
		return *x.ref6a31a31a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Tss2TctiContextCommonV1) Deref() {
	if x.ref6a31a31a == nil {
		return
	}
	x.Magic = (Uint64T)(x.ref6a31a31a.magic)
	x.Version = (Uint32T)(x.ref6a31a31a.version)
	x.Transmit = *NewTss2TctiTransmitFcnRef(unsafe.Pointer(&x.ref6a31a31a.transmit))
	x.Receive = *NewTss2TctiReceiveFcnRef(unsafe.Pointer(&x.ref6a31a31a.receive))
	x.Finalize = *NewTss2TctiFinalizeFcnRef(unsafe.Pointer(&x.ref6a31a31a.finalize))
	x.Cancel = *NewTss2TctiCancelFcnRef(unsafe.Pointer(&x.ref6a31a31a.cancel))
	x.Getpollhandles = *NewTss2TctiGetPollHandlesFcnRef(unsafe.Pointer(&x.ref6a31a31a.getPollHandles))
	x.Setlocality = *NewTss2TctiSetLocalityFcnRef(unsafe.Pointer(&x.ref6a31a31a.setLocality))
}

// allocTss2TctiContextCommonV2Memory allocates memory for type C.TSS2_TCTI_CONTEXT_COMMON_V2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTss2TctiContextCommonV2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTss2TctiContextCommonV2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTss2TctiContextCommonV2Value = unsafe.Sizeof([1]C.TSS2_TCTI_CONTEXT_COMMON_V2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Tss2TctiContextCommonV2) Ref() *C.TSS2_TCTI_CONTEXT_COMMON_V2 {
	if x == nil {
		return nil
	}
	return x.reff338f2a0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Tss2TctiContextCommonV2) Free() {
	if x != nil && x.allocsf338f2a0 != nil {
		x.allocsf338f2a0.(*cgoAllocMap).Free()
		x.reff338f2a0 = nil
	}
}

// NewTss2TctiContextCommonV2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTss2TctiContextCommonV2Ref(ref unsafe.Pointer) *Tss2TctiContextCommonV2 {
	if ref == nil {
		return nil
	}
	obj := new(Tss2TctiContextCommonV2)
	obj.reff338f2a0 = (*C.TSS2_TCTI_CONTEXT_COMMON_V2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Tss2TctiContextCommonV2) PassRef() (*C.TSS2_TCTI_CONTEXT_COMMON_V2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff338f2a0 != nil {
		return x.reff338f2a0, nil
	}
	memf338f2a0 := allocTss2TctiContextCommonV2Memory(1)
	reff338f2a0 := (*C.TSS2_TCTI_CONTEXT_COMMON_V2)(memf338f2a0)
	allocsf338f2a0 := new(cgoAllocMap)
	allocsf338f2a0.Add(memf338f2a0)

	var cv1_allocs *cgoAllocMap
	reff338f2a0.v1, cv1_allocs = x.V1.PassValue()
	allocsf338f2a0.Borrow(cv1_allocs)

	var cmakeSticky_allocs *cgoAllocMap
	reff338f2a0.makeSticky, cmakeSticky_allocs = x.Makesticky.PassValue()
	allocsf338f2a0.Borrow(cmakeSticky_allocs)

	x.reff338f2a0 = reff338f2a0
	x.allocsf338f2a0 = allocsf338f2a0
	return reff338f2a0, allocsf338f2a0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Tss2TctiContextCommonV2) PassValue() (C.TSS2_TCTI_CONTEXT_COMMON_V2, *cgoAllocMap) {
	if x.reff338f2a0 != nil {
		return *x.reff338f2a0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Tss2TctiContextCommonV2) Deref() {
	if x.reff338f2a0 == nil {
		return
	}
	x.V1 = *NewTss2TctiContextCommonV1Ref(unsafe.Pointer(&x.reff338f2a0.v1))
	x.Makesticky = *NewTss2TctiMakeStickyFcnRef(unsafe.Pointer(&x.reff338f2a0.makeSticky))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Tss2TctiContextCommonCurrent) Ref() *C.TSS2_TCTI_CONTEXT_COMMON_V2 {
	if x == nil {
		return nil
	}
	return x.reff338f2a0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Tss2TctiContextCommonCurrent) Free() {
	if x != nil && x.allocsf338f2a0 != nil {
		x.allocsf338f2a0.(*cgoAllocMap).Free()
		x.reff338f2a0 = nil
	}
}

// NewTss2TctiContextCommonCurrentRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTss2TctiContextCommonCurrentRef(ref unsafe.Pointer) *Tss2TctiContextCommonCurrent {
	if ref == nil {
		return nil
	}
	obj := new(Tss2TctiContextCommonCurrent)
	obj.reff338f2a0 = (*C.TSS2_TCTI_CONTEXT_COMMON_V2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Tss2TctiContextCommonCurrent) PassRef() (*C.TSS2_TCTI_CONTEXT_COMMON_V2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff338f2a0 != nil {
		return x.reff338f2a0, nil
	}
	memf338f2a0 := allocTss2TctiContextCommonV2Memory(1)
	reff338f2a0 := (*C.TSS2_TCTI_CONTEXT_COMMON_V2)(memf338f2a0)
	allocsf338f2a0 := new(cgoAllocMap)
	allocsf338f2a0.Add(memf338f2a0)

	var cv1_allocs *cgoAllocMap
	reff338f2a0.v1, cv1_allocs = x.V1.PassValue()
	allocsf338f2a0.Borrow(cv1_allocs)

	var cmakeSticky_allocs *cgoAllocMap
	reff338f2a0.makeSticky, cmakeSticky_allocs = x.Makesticky.PassValue()
	allocsf338f2a0.Borrow(cmakeSticky_allocs)

	x.reff338f2a0 = reff338f2a0
	x.allocsf338f2a0 = allocsf338f2a0
	return reff338f2a0, allocsf338f2a0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Tss2TctiContextCommonCurrent) PassValue() (C.TSS2_TCTI_CONTEXT_COMMON_V2, *cgoAllocMap) {
	if x.reff338f2a0 != nil {
		return *x.reff338f2a0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Tss2TctiContextCommonCurrent) Deref() {
	if x.reff338f2a0 == nil {
		return
	}
	x.V1 = *NewTss2TctiContextCommonV1Ref(unsafe.Pointer(&x.reff338f2a0.v1))
	x.Makesticky = *NewTss2TctiMakeStickyFcnRef(unsafe.Pointer(&x.reff338f2a0.makeSticky))
}

// Ref returns a reference to C object as it is.
func (x *Tss2TctiInfo) Ref() *C.TSS2_TCTI_INFO {
	if x == nil {
		return nil
	}
	return (*C.TSS2_TCTI_INFO)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tss2TctiInfo) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTss2TctiInfoRef converts the C object reference into a raw struct reference without wrapping.
func NewTss2TctiInfoRef(ref unsafe.Pointer) *Tss2TctiInfo {
	return (*Tss2TctiInfo)(ref)
}

// NewTss2TctiInfo allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTss2TctiInfo() *Tss2TctiInfo {
	return (*Tss2TctiInfo)(allocTss2TctiInfoMemory(1))
}

// allocTss2TctiInfoMemory allocates memory for type C.TSS2_TCTI_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTss2TctiInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTss2TctiInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTss2TctiInfoValue = unsafe.Sizeof([1]C.TSS2_TCTI_INFO{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tss2TctiInfo) PassRef() *C.TSS2_TCTI_INFO {
	if x == nil {
		x = (*Tss2TctiInfo)(allocTss2TctiInfoMemory(1))
	}
	return (*C.TSS2_TCTI_INFO)(unsafe.Pointer(x))
}

// copyPTss2TctiInfoBytes copies the data from Go slice as *C.TSS2_TCTI_INFO.
func copyPTss2TctiInfoBytes(slice *sliceHeader) (*C.TSS2_TCTI_INFO, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTss2TctiInfoValue) * slice.Len,
		Cap:  int(sizeOfTss2TctiInfoValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TSS2_TCTI_INFO)(mem0), allocs
}

func (x Tss2TctiInfoFunc) PassRef() (ref *C.TSS2_TCTI_INFO_FUNC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiInfoFunc3AB67CD0Func == nil {
		tss2TctiInfoFunc3AB67CD0Func = x
	}
	return (*C.TSS2_TCTI_INFO_FUNC)(C.TSS2_TCTI_INFO_FUNC_3ab67cd0), nil
}

func (x Tss2TctiInfoFunc) PassValue() (ref C.TSS2_TCTI_INFO_FUNC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiInfoFunc3AB67CD0Func == nil {
		tss2TctiInfoFunc3AB67CD0Func = x
	}
	return (C.TSS2_TCTI_INFO_FUNC)(C.TSS2_TCTI_INFO_FUNC_3ab67cd0), nil
}

func NewTss2TctiInfoFuncRef(ref unsafe.Pointer) *Tss2TctiInfoFunc {
	return (*Tss2TctiInfoFunc)(ref)
}

//export tss2TctiInfoFunc3AB67CD0
func tss2TctiInfoFunc3AB67CD0() *C.TSS2_TCTI_INFO {
	if tss2TctiInfoFunc3AB67CD0Func != nil {
		ret3ab67cd0 := tss2TctiInfoFunc3AB67CD0Func()
		ret, _ := copyPTss2TctiInfoBytes((*sliceHeader)(unsafe.Pointer(&ret3ab67cd0)))
		return ret
	}
	panic("callback func has not been set (race?)")
}

var tss2TctiInfoFunc3AB67CD0Func Tss2TctiInfoFunc

// Ref returns a reference to C object as it is.
func (x *TpmsEmpty) Ref() *C.TPMS_EMPTY {
	if x == nil {
		return nil
	}
	return (*C.TPMS_EMPTY)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsEmpty) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsEmptyRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsEmptyRef(ref unsafe.Pointer) *TpmsEmpty {
	return (*TpmsEmpty)(ref)
}

// NewTpmsEmpty allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsEmpty() *TpmsEmpty {
	return (*TpmsEmpty)(allocTpmsEmptyMemory(1))
}

// allocTpmsEmptyMemory allocates memory for type C.TPMS_EMPTY in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsEmptyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsEmptyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsEmptyValue = unsafe.Sizeof([1]C.TPMS_EMPTY{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsEmpty) PassRef() *C.TPMS_EMPTY {
	if x == nil {
		x = (*TpmsEmpty)(allocTpmsEmptyMemory(1))
	}
	return (*C.TPMS_EMPTY)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsAlgorithmDescription) Ref() *C.TPMS_ALGORITHM_DESCRIPTION {
	if x == nil {
		return nil
	}
	return (*C.TPMS_ALGORITHM_DESCRIPTION)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsAlgorithmDescription) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsAlgorithmDescriptionRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsAlgorithmDescriptionRef(ref unsafe.Pointer) *TpmsAlgorithmDescription {
	return (*TpmsAlgorithmDescription)(ref)
}

// NewTpmsAlgorithmDescription allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsAlgorithmDescription() *TpmsAlgorithmDescription {
	return (*TpmsAlgorithmDescription)(allocTpmsAlgorithmDescriptionMemory(1))
}

// allocTpmsAlgorithmDescriptionMemory allocates memory for type C.TPMS_ALGORITHM_DESCRIPTION in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsAlgorithmDescriptionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsAlgorithmDescriptionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsAlgorithmDescriptionValue = unsafe.Sizeof([1]C.TPMS_ALGORITHM_DESCRIPTION{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsAlgorithmDescription) PassRef() *C.TPMS_ALGORITHM_DESCRIPTION {
	if x == nil {
		x = (*TpmsAlgorithmDescription)(allocTpmsAlgorithmDescriptionMemory(1))
	}
	return (*C.TPMS_ALGORITHM_DESCRIPTION)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmtHa) Ref() *C.TPMT_HA {
	if x == nil {
		return nil
	}
	return (*C.TPMT_HA)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmtHa) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmtHaRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmtHaRef(ref unsafe.Pointer) *TpmtHa {
	return (*TpmtHa)(ref)
}

// NewTpmtHa allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmtHa() *TpmtHa {
	return (*TpmtHa)(allocTpmtHaMemory(1))
}

// allocTpmtHaMemory allocates memory for type C.TPMT_HA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtHaMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtHaValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtHaValue = unsafe.Sizeof([1]C.TPMT_HA{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmtHa) PassRef() *C.TPMT_HA {
	if x == nil {
		x = (*TpmtHa)(allocTpmtHaMemory(1))
	}
	return (*C.TPMT_HA)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bDigest) Ref() *C.TPM2B_DIGEST {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_DIGEST)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bDigest) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bDigestRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bDigestRef(ref unsafe.Pointer) *Tpm2bDigest {
	return (*Tpm2bDigest)(ref)
}

// NewTpm2bDigest allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bDigest() *Tpm2bDigest {
	return (*Tpm2bDigest)(allocTpm2bDigestMemory(1))
}

// allocTpm2bDigestMemory allocates memory for type C.TPM2B_DIGEST in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bDigestMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bDigestValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bDigestValue = unsafe.Sizeof([1]C.TPM2B_DIGEST{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bDigest) PassRef() *C.TPM2B_DIGEST {
	if x == nil {
		x = (*Tpm2bDigest)(allocTpm2bDigestMemory(1))
	}
	return (*C.TPM2B_DIGEST)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bData) Ref() *C.TPM2B_DATA {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_DATA)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bData) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bDataRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bDataRef(ref unsafe.Pointer) *Tpm2bData {
	return (*Tpm2bData)(ref)
}

// NewTpm2bData allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bData() *Tpm2bData {
	return (*Tpm2bData)(allocTpm2bDataMemory(1))
}

// allocTpm2bDataMemory allocates memory for type C.TPM2B_DATA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bDataValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bDataValue = unsafe.Sizeof([1]C.TPM2B_DATA{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bData) PassRef() *C.TPM2B_DATA {
	if x == nil {
		x = (*Tpm2bData)(allocTpm2bDataMemory(1))
	}
	return (*C.TPM2B_DATA)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bNonce) Ref() *C.TPM2B_DIGEST {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_DIGEST)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bNonce) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bNonceRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bNonceRef(ref unsafe.Pointer) *Tpm2bNonce {
	return (*Tpm2bNonce)(ref)
}

// NewTpm2bNonce allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bNonce() *Tpm2bNonce {
	return (*Tpm2bNonce)(allocTpm2bDigestMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bNonce) PassRef() *C.TPM2B_DIGEST {
	if x == nil {
		x = (*Tpm2bNonce)(allocTpm2bDigestMemory(1))
	}
	return (*C.TPM2B_DIGEST)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bAuth) Ref() *C.TPM2B_DIGEST {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_DIGEST)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bAuth) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bAuthRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bAuthRef(ref unsafe.Pointer) *Tpm2bAuth {
	return (*Tpm2bAuth)(ref)
}

// NewTpm2bAuth allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bAuth() *Tpm2bAuth {
	return (*Tpm2bAuth)(allocTpm2bDigestMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bAuth) PassRef() *C.TPM2B_DIGEST {
	if x == nil {
		x = (*Tpm2bAuth)(allocTpm2bDigestMemory(1))
	}
	return (*C.TPM2B_DIGEST)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bOperand) Ref() *C.TPM2B_DIGEST {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_DIGEST)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bOperand) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bOperandRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bOperandRef(ref unsafe.Pointer) *Tpm2bOperand {
	return (*Tpm2bOperand)(ref)
}

// NewTpm2bOperand allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bOperand() *Tpm2bOperand {
	return (*Tpm2bOperand)(allocTpm2bDigestMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bOperand) PassRef() *C.TPM2B_DIGEST {
	if x == nil {
		x = (*Tpm2bOperand)(allocTpm2bDigestMemory(1))
	}
	return (*C.TPM2B_DIGEST)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bEvent) Ref() *C.TPM2B_EVENT {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_EVENT)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bEvent) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bEventRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bEventRef(ref unsafe.Pointer) *Tpm2bEvent {
	return (*Tpm2bEvent)(ref)
}

// NewTpm2bEvent allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bEvent() *Tpm2bEvent {
	return (*Tpm2bEvent)(allocTpm2bEventMemory(1))
}

// allocTpm2bEventMemory allocates memory for type C.TPM2B_EVENT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bEventMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bEventValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bEventValue = unsafe.Sizeof([1]C.TPM2B_EVENT{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bEvent) PassRef() *C.TPM2B_EVENT {
	if x == nil {
		x = (*Tpm2bEvent)(allocTpm2bEventMemory(1))
	}
	return (*C.TPM2B_EVENT)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bMaxBuffer) Ref() *C.TPM2B_MAX_BUFFER {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_MAX_BUFFER)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bMaxBuffer) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bMaxBufferRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bMaxBufferRef(ref unsafe.Pointer) *Tpm2bMaxBuffer {
	return (*Tpm2bMaxBuffer)(ref)
}

// NewTpm2bMaxBuffer allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bMaxBuffer() *Tpm2bMaxBuffer {
	return (*Tpm2bMaxBuffer)(allocTpm2bMaxBufferMemory(1))
}

// allocTpm2bMaxBufferMemory allocates memory for type C.TPM2B_MAX_BUFFER in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bMaxBufferMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bMaxBufferValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bMaxBufferValue = unsafe.Sizeof([1]C.TPM2B_MAX_BUFFER{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bMaxBuffer) PassRef() *C.TPM2B_MAX_BUFFER {
	if x == nil {
		x = (*Tpm2bMaxBuffer)(allocTpm2bMaxBufferMemory(1))
	}
	return (*C.TPM2B_MAX_BUFFER)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bMaxNvBuffer) Ref() *C.TPM2B_MAX_NV_BUFFER {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_MAX_NV_BUFFER)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bMaxNvBuffer) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bMaxNvBufferRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bMaxNvBufferRef(ref unsafe.Pointer) *Tpm2bMaxNvBuffer {
	return (*Tpm2bMaxNvBuffer)(ref)
}

// NewTpm2bMaxNvBuffer allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bMaxNvBuffer() *Tpm2bMaxNvBuffer {
	return (*Tpm2bMaxNvBuffer)(allocTpm2bMaxNvBufferMemory(1))
}

// allocTpm2bMaxNvBufferMemory allocates memory for type C.TPM2B_MAX_NV_BUFFER in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bMaxNvBufferMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bMaxNvBufferValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bMaxNvBufferValue = unsafe.Sizeof([1]C.TPM2B_MAX_NV_BUFFER{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bMaxNvBuffer) PassRef() *C.TPM2B_MAX_NV_BUFFER {
	if x == nil {
		x = (*Tpm2bMaxNvBuffer)(allocTpm2bMaxNvBufferMemory(1))
	}
	return (*C.TPM2B_MAX_NV_BUFFER)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bTimeout) Ref() *C.TPM2B_DIGEST {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_DIGEST)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bTimeout) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bTimeoutRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bTimeoutRef(ref unsafe.Pointer) *Tpm2bTimeout {
	return (*Tpm2bTimeout)(ref)
}

// NewTpm2bTimeout allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bTimeout() *Tpm2bTimeout {
	return (*Tpm2bTimeout)(allocTpm2bDigestMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bTimeout) PassRef() *C.TPM2B_DIGEST {
	if x == nil {
		x = (*Tpm2bTimeout)(allocTpm2bDigestMemory(1))
	}
	return (*C.TPM2B_DIGEST)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bIv) Ref() *C.TPM2B_IV {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_IV)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bIv) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bIvRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bIvRef(ref unsafe.Pointer) *Tpm2bIv {
	return (*Tpm2bIv)(ref)
}

// NewTpm2bIv allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bIv() *Tpm2bIv {
	return (*Tpm2bIv)(allocTpm2bIvMemory(1))
}

// allocTpm2bIvMemory allocates memory for type C.TPM2B_IV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bIvMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bIvValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bIvValue = unsafe.Sizeof([1]C.TPM2B_IV{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bIv) PassRef() *C.TPM2B_IV {
	if x == nil {
		x = (*Tpm2bIv)(allocTpm2bIvMemory(1))
	}
	return (*C.TPM2B_IV)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bName) Ref() *C.TPM2B_NAME {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_NAME)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bName) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bNameRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bNameRef(ref unsafe.Pointer) *Tpm2bName {
	return (*Tpm2bName)(ref)
}

// NewTpm2bName allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bName() *Tpm2bName {
	return (*Tpm2bName)(allocTpm2bNameMemory(1))
}

// allocTpm2bNameMemory allocates memory for type C.TPM2B_NAME in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bNameMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bNameValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bNameValue = unsafe.Sizeof([1]C.TPM2B_NAME{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bName) PassRef() *C.TPM2B_NAME {
	if x == nil {
		x = (*Tpm2bName)(allocTpm2bNameMemory(1))
	}
	return (*C.TPM2B_NAME)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsPcrSelect) Ref() *C.TPMS_PCR_SELECT {
	if x == nil {
		return nil
	}
	return (*C.TPMS_PCR_SELECT)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsPcrSelect) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsPcrSelectRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsPcrSelectRef(ref unsafe.Pointer) *TpmsPcrSelect {
	return (*TpmsPcrSelect)(ref)
}

// NewTpmsPcrSelect allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsPcrSelect() *TpmsPcrSelect {
	return (*TpmsPcrSelect)(allocTpmsPcrSelectMemory(1))
}

// allocTpmsPcrSelectMemory allocates memory for type C.TPMS_PCR_SELECT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsPcrSelectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsPcrSelectValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsPcrSelectValue = unsafe.Sizeof([1]C.TPMS_PCR_SELECT{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsPcrSelect) PassRef() *C.TPMS_PCR_SELECT {
	if x == nil {
		x = (*TpmsPcrSelect)(allocTpmsPcrSelectMemory(1))
	}
	return (*C.TPMS_PCR_SELECT)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsPcrSelection) Ref() *C.TPMS_PCR_SELECTION {
	if x == nil {
		return nil
	}
	return (*C.TPMS_PCR_SELECTION)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsPcrSelection) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsPcrSelectionRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsPcrSelectionRef(ref unsafe.Pointer) *TpmsPcrSelection {
	return (*TpmsPcrSelection)(ref)
}

// NewTpmsPcrSelection allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsPcrSelection() *TpmsPcrSelection {
	return (*TpmsPcrSelection)(allocTpmsPcrSelectionMemory(1))
}

// allocTpmsPcrSelectionMemory allocates memory for type C.TPMS_PCR_SELECTION in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsPcrSelectionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsPcrSelectionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsPcrSelectionValue = unsafe.Sizeof([1]C.TPMS_PCR_SELECTION{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsPcrSelection) PassRef() *C.TPMS_PCR_SELECTION {
	if x == nil {
		x = (*TpmsPcrSelection)(allocTpmsPcrSelectionMemory(1))
	}
	return (*C.TPMS_PCR_SELECTION)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmtTkCreation) Ref() *C.TPMT_TK_CREATION {
	if x == nil {
		return nil
	}
	return (*C.TPMT_TK_CREATION)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmtTkCreation) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmtTkCreationRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmtTkCreationRef(ref unsafe.Pointer) *TpmtTkCreation {
	return (*TpmtTkCreation)(ref)
}

// NewTpmtTkCreation allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmtTkCreation() *TpmtTkCreation {
	return (*TpmtTkCreation)(allocTpmtTkCreationMemory(1))
}

// allocTpmtTkCreationMemory allocates memory for type C.TPMT_TK_CREATION in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtTkCreationMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtTkCreationValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtTkCreationValue = unsafe.Sizeof([1]C.TPMT_TK_CREATION{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmtTkCreation) PassRef() *C.TPMT_TK_CREATION {
	if x == nil {
		x = (*TpmtTkCreation)(allocTpmtTkCreationMemory(1))
	}
	return (*C.TPMT_TK_CREATION)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmtTkVerified) Ref() *C.TPMT_TK_VERIFIED {
	if x == nil {
		return nil
	}
	return (*C.TPMT_TK_VERIFIED)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmtTkVerified) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmtTkVerifiedRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmtTkVerifiedRef(ref unsafe.Pointer) *TpmtTkVerified {
	return (*TpmtTkVerified)(ref)
}

// NewTpmtTkVerified allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmtTkVerified() *TpmtTkVerified {
	return (*TpmtTkVerified)(allocTpmtTkVerifiedMemory(1))
}

// allocTpmtTkVerifiedMemory allocates memory for type C.TPMT_TK_VERIFIED in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtTkVerifiedMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtTkVerifiedValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtTkVerifiedValue = unsafe.Sizeof([1]C.TPMT_TK_VERIFIED{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmtTkVerified) PassRef() *C.TPMT_TK_VERIFIED {
	if x == nil {
		x = (*TpmtTkVerified)(allocTpmtTkVerifiedMemory(1))
	}
	return (*C.TPMT_TK_VERIFIED)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmtTkAuth) Ref() *C.TPMT_TK_AUTH {
	if x == nil {
		return nil
	}
	return (*C.TPMT_TK_AUTH)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmtTkAuth) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmtTkAuthRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmtTkAuthRef(ref unsafe.Pointer) *TpmtTkAuth {
	return (*TpmtTkAuth)(ref)
}

// NewTpmtTkAuth allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmtTkAuth() *TpmtTkAuth {
	return (*TpmtTkAuth)(allocTpmtTkAuthMemory(1))
}

// allocTpmtTkAuthMemory allocates memory for type C.TPMT_TK_AUTH in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtTkAuthMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtTkAuthValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtTkAuthValue = unsafe.Sizeof([1]C.TPMT_TK_AUTH{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmtTkAuth) PassRef() *C.TPMT_TK_AUTH {
	if x == nil {
		x = (*TpmtTkAuth)(allocTpmtTkAuthMemory(1))
	}
	return (*C.TPMT_TK_AUTH)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmtTkHashcheck) Ref() *C.TPMT_TK_HASHCHECK {
	if x == nil {
		return nil
	}
	return (*C.TPMT_TK_HASHCHECK)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmtTkHashcheck) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmtTkHashcheckRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmtTkHashcheckRef(ref unsafe.Pointer) *TpmtTkHashcheck {
	return (*TpmtTkHashcheck)(ref)
}

// NewTpmtTkHashcheck allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmtTkHashcheck() *TpmtTkHashcheck {
	return (*TpmtTkHashcheck)(allocTpmtTkHashcheckMemory(1))
}

// allocTpmtTkHashcheckMemory allocates memory for type C.TPMT_TK_HASHCHECK in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtTkHashcheckMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtTkHashcheckValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtTkHashcheckValue = unsafe.Sizeof([1]C.TPMT_TK_HASHCHECK{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmtTkHashcheck) PassRef() *C.TPMT_TK_HASHCHECK {
	if x == nil {
		x = (*TpmtTkHashcheck)(allocTpmtTkHashcheckMemory(1))
	}
	return (*C.TPMT_TK_HASHCHECK)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsAlgProperty) Ref() *C.TPMS_ALG_PROPERTY {
	if x == nil {
		return nil
	}
	return (*C.TPMS_ALG_PROPERTY)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsAlgProperty) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsAlgPropertyRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsAlgPropertyRef(ref unsafe.Pointer) *TpmsAlgProperty {
	return (*TpmsAlgProperty)(ref)
}

// NewTpmsAlgProperty allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsAlgProperty() *TpmsAlgProperty {
	return (*TpmsAlgProperty)(allocTpmsAlgPropertyMemory(1))
}

// allocTpmsAlgPropertyMemory allocates memory for type C.TPMS_ALG_PROPERTY in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsAlgPropertyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsAlgPropertyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsAlgPropertyValue = unsafe.Sizeof([1]C.TPMS_ALG_PROPERTY{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsAlgProperty) PassRef() *C.TPMS_ALG_PROPERTY {
	if x == nil {
		x = (*TpmsAlgProperty)(allocTpmsAlgPropertyMemory(1))
	}
	return (*C.TPMS_ALG_PROPERTY)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsTaggedProperty) Ref() *C.TPMS_TAGGED_PROPERTY {
	if x == nil {
		return nil
	}
	return (*C.TPMS_TAGGED_PROPERTY)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsTaggedProperty) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsTaggedPropertyRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsTaggedPropertyRef(ref unsafe.Pointer) *TpmsTaggedProperty {
	return (*TpmsTaggedProperty)(ref)
}

// NewTpmsTaggedProperty allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsTaggedProperty() *TpmsTaggedProperty {
	return (*TpmsTaggedProperty)(allocTpmsTaggedPropertyMemory(1))
}

// allocTpmsTaggedPropertyMemory allocates memory for type C.TPMS_TAGGED_PROPERTY in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsTaggedPropertyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsTaggedPropertyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsTaggedPropertyValue = unsafe.Sizeof([1]C.TPMS_TAGGED_PROPERTY{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsTaggedProperty) PassRef() *C.TPMS_TAGGED_PROPERTY {
	if x == nil {
		x = (*TpmsTaggedProperty)(allocTpmsTaggedPropertyMemory(1))
	}
	return (*C.TPMS_TAGGED_PROPERTY)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsTaggedPcrSelect) Ref() *C.TPMS_TAGGED_PCR_SELECT {
	if x == nil {
		return nil
	}
	return (*C.TPMS_TAGGED_PCR_SELECT)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsTaggedPcrSelect) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsTaggedPcrSelectRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsTaggedPcrSelectRef(ref unsafe.Pointer) *TpmsTaggedPcrSelect {
	return (*TpmsTaggedPcrSelect)(ref)
}

// NewTpmsTaggedPcrSelect allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsTaggedPcrSelect() *TpmsTaggedPcrSelect {
	return (*TpmsTaggedPcrSelect)(allocTpmsTaggedPcrSelectMemory(1))
}

// allocTpmsTaggedPcrSelectMemory allocates memory for type C.TPMS_TAGGED_PCR_SELECT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsTaggedPcrSelectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsTaggedPcrSelectValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsTaggedPcrSelectValue = unsafe.Sizeof([1]C.TPMS_TAGGED_PCR_SELECT{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsTaggedPcrSelect) PassRef() *C.TPMS_TAGGED_PCR_SELECT {
	if x == nil {
		x = (*TpmsTaggedPcrSelect)(allocTpmsTaggedPcrSelectMemory(1))
	}
	return (*C.TPMS_TAGGED_PCR_SELECT)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsTaggedPolicy) Ref() *C.TPMS_TAGGED_POLICY {
	if x == nil {
		return nil
	}
	return (*C.TPMS_TAGGED_POLICY)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsTaggedPolicy) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsTaggedPolicyRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsTaggedPolicyRef(ref unsafe.Pointer) *TpmsTaggedPolicy {
	return (*TpmsTaggedPolicy)(ref)
}

// NewTpmsTaggedPolicy allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsTaggedPolicy() *TpmsTaggedPolicy {
	return (*TpmsTaggedPolicy)(allocTpmsTaggedPolicyMemory(1))
}

// allocTpmsTaggedPolicyMemory allocates memory for type C.TPMS_TAGGED_POLICY in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsTaggedPolicyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsTaggedPolicyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsTaggedPolicyValue = unsafe.Sizeof([1]C.TPMS_TAGGED_POLICY{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsTaggedPolicy) PassRef() *C.TPMS_TAGGED_POLICY {
	if x == nil {
		x = (*TpmsTaggedPolicy)(allocTpmsTaggedPolicyMemory(1))
	}
	return (*C.TPMS_TAGGED_POLICY)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmlCc) Ref() *C.TPML_CC {
	if x == nil {
		return nil
	}
	return (*C.TPML_CC)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmlCc) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmlCcRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmlCcRef(ref unsafe.Pointer) *TpmlCc {
	return (*TpmlCc)(ref)
}

// NewTpmlCc allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmlCc() *TpmlCc {
	return (*TpmlCc)(allocTpmlCcMemory(1))
}

// allocTpmlCcMemory allocates memory for type C.TPML_CC in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmlCcMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmlCcValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmlCcValue = unsafe.Sizeof([1]C.TPML_CC{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmlCc) PassRef() *C.TPML_CC {
	if x == nil {
		x = (*TpmlCc)(allocTpmlCcMemory(1))
	}
	return (*C.TPML_CC)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmlCca) Ref() *C.TPML_CCA {
	if x == nil {
		return nil
	}
	return (*C.TPML_CCA)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmlCca) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmlCcaRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmlCcaRef(ref unsafe.Pointer) *TpmlCca {
	return (*TpmlCca)(ref)
}

// NewTpmlCca allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmlCca() *TpmlCca {
	return (*TpmlCca)(allocTpmlCcaMemory(1))
}

// allocTpmlCcaMemory allocates memory for type C.TPML_CCA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmlCcaMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmlCcaValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmlCcaValue = unsafe.Sizeof([1]C.TPML_CCA{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmlCca) PassRef() *C.TPML_CCA {
	if x == nil {
		x = (*TpmlCca)(allocTpmlCcaMemory(1))
	}
	return (*C.TPML_CCA)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmlAlg) Ref() *C.TPML_ALG {
	if x == nil {
		return nil
	}
	return (*C.TPML_ALG)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmlAlg) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmlAlgRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmlAlgRef(ref unsafe.Pointer) *TpmlAlg {
	return (*TpmlAlg)(ref)
}

// NewTpmlAlg allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmlAlg() *TpmlAlg {
	return (*TpmlAlg)(allocTpmlAlgMemory(1))
}

// allocTpmlAlgMemory allocates memory for type C.TPML_ALG in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmlAlgMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmlAlgValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmlAlgValue = unsafe.Sizeof([1]C.TPML_ALG{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmlAlg) PassRef() *C.TPML_ALG {
	if x == nil {
		x = (*TpmlAlg)(allocTpmlAlgMemory(1))
	}
	return (*C.TPML_ALG)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmlHandle) Ref() *C.TPML_HANDLE {
	if x == nil {
		return nil
	}
	return (*C.TPML_HANDLE)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmlHandle) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmlHandleRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmlHandleRef(ref unsafe.Pointer) *TpmlHandle {
	return (*TpmlHandle)(ref)
}

// NewTpmlHandle allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmlHandle() *TpmlHandle {
	return (*TpmlHandle)(allocTpmlHandleMemory(1))
}

// allocTpmlHandleMemory allocates memory for type C.TPML_HANDLE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmlHandleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmlHandleValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmlHandleValue = unsafe.Sizeof([1]C.TPML_HANDLE{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmlHandle) PassRef() *C.TPML_HANDLE {
	if x == nil {
		x = (*TpmlHandle)(allocTpmlHandleMemory(1))
	}
	return (*C.TPML_HANDLE)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmlDigest) Ref() *C.TPML_DIGEST {
	if x == nil {
		return nil
	}
	return (*C.TPML_DIGEST)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmlDigest) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmlDigestRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmlDigestRef(ref unsafe.Pointer) *TpmlDigest {
	return (*TpmlDigest)(ref)
}

// NewTpmlDigest allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmlDigest() *TpmlDigest {
	return (*TpmlDigest)(allocTpmlDigestMemory(1))
}

// allocTpmlDigestMemory allocates memory for type C.TPML_DIGEST in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmlDigestMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmlDigestValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmlDigestValue = unsafe.Sizeof([1]C.TPML_DIGEST{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmlDigest) PassRef() *C.TPML_DIGEST {
	if x == nil {
		x = (*TpmlDigest)(allocTpmlDigestMemory(1))
	}
	return (*C.TPML_DIGEST)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmlDigestValues) Ref() *C.TPML_DIGEST_VALUES {
	if x == nil {
		return nil
	}
	return (*C.TPML_DIGEST_VALUES)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmlDigestValues) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmlDigestValuesRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmlDigestValuesRef(ref unsafe.Pointer) *TpmlDigestValues {
	return (*TpmlDigestValues)(ref)
}

// NewTpmlDigestValues allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmlDigestValues() *TpmlDigestValues {
	return (*TpmlDigestValues)(allocTpmlDigestValuesMemory(1))
}

// allocTpmlDigestValuesMemory allocates memory for type C.TPML_DIGEST_VALUES in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmlDigestValuesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmlDigestValuesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmlDigestValuesValue = unsafe.Sizeof([1]C.TPML_DIGEST_VALUES{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmlDigestValues) PassRef() *C.TPML_DIGEST_VALUES {
	if x == nil {
		x = (*TpmlDigestValues)(allocTpmlDigestValuesMemory(1))
	}
	return (*C.TPML_DIGEST_VALUES)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmlPcrSelection) Ref() *C.TPML_PCR_SELECTION {
	if x == nil {
		return nil
	}
	return (*C.TPML_PCR_SELECTION)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmlPcrSelection) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmlPcrSelectionRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmlPcrSelectionRef(ref unsafe.Pointer) *TpmlPcrSelection {
	return (*TpmlPcrSelection)(ref)
}

// NewTpmlPcrSelection allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmlPcrSelection() *TpmlPcrSelection {
	return (*TpmlPcrSelection)(allocTpmlPcrSelectionMemory(1))
}

// allocTpmlPcrSelectionMemory allocates memory for type C.TPML_PCR_SELECTION in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmlPcrSelectionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmlPcrSelectionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmlPcrSelectionValue = unsafe.Sizeof([1]C.TPML_PCR_SELECTION{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmlPcrSelection) PassRef() *C.TPML_PCR_SELECTION {
	if x == nil {
		x = (*TpmlPcrSelection)(allocTpmlPcrSelectionMemory(1))
	}
	return (*C.TPML_PCR_SELECTION)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmlAlgProperty) Ref() *C.TPML_ALG_PROPERTY {
	if x == nil {
		return nil
	}
	return (*C.TPML_ALG_PROPERTY)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmlAlgProperty) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmlAlgPropertyRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmlAlgPropertyRef(ref unsafe.Pointer) *TpmlAlgProperty {
	return (*TpmlAlgProperty)(ref)
}

// NewTpmlAlgProperty allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmlAlgProperty() *TpmlAlgProperty {
	return (*TpmlAlgProperty)(allocTpmlAlgPropertyMemory(1))
}

// allocTpmlAlgPropertyMemory allocates memory for type C.TPML_ALG_PROPERTY in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmlAlgPropertyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmlAlgPropertyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmlAlgPropertyValue = unsafe.Sizeof([1]C.TPML_ALG_PROPERTY{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmlAlgProperty) PassRef() *C.TPML_ALG_PROPERTY {
	if x == nil {
		x = (*TpmlAlgProperty)(allocTpmlAlgPropertyMemory(1))
	}
	return (*C.TPML_ALG_PROPERTY)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmlTaggedTpmProperty) Ref() *C.TPML_TAGGED_TPM_PROPERTY {
	if x == nil {
		return nil
	}
	return (*C.TPML_TAGGED_TPM_PROPERTY)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmlTaggedTpmProperty) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmlTaggedTpmPropertyRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmlTaggedTpmPropertyRef(ref unsafe.Pointer) *TpmlTaggedTpmProperty {
	return (*TpmlTaggedTpmProperty)(ref)
}

// NewTpmlTaggedTpmProperty allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmlTaggedTpmProperty() *TpmlTaggedTpmProperty {
	return (*TpmlTaggedTpmProperty)(allocTpmlTaggedTpmPropertyMemory(1))
}

// allocTpmlTaggedTpmPropertyMemory allocates memory for type C.TPML_TAGGED_TPM_PROPERTY in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmlTaggedTpmPropertyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmlTaggedTpmPropertyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmlTaggedTpmPropertyValue = unsafe.Sizeof([1]C.TPML_TAGGED_TPM_PROPERTY{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmlTaggedTpmProperty) PassRef() *C.TPML_TAGGED_TPM_PROPERTY {
	if x == nil {
		x = (*TpmlTaggedTpmProperty)(allocTpmlTaggedTpmPropertyMemory(1))
	}
	return (*C.TPML_TAGGED_TPM_PROPERTY)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmlTaggedPcrProperty) Ref() *C.TPML_TAGGED_PCR_PROPERTY {
	if x == nil {
		return nil
	}
	return (*C.TPML_TAGGED_PCR_PROPERTY)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmlTaggedPcrProperty) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmlTaggedPcrPropertyRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmlTaggedPcrPropertyRef(ref unsafe.Pointer) *TpmlTaggedPcrProperty {
	return (*TpmlTaggedPcrProperty)(ref)
}

// NewTpmlTaggedPcrProperty allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmlTaggedPcrProperty() *TpmlTaggedPcrProperty {
	return (*TpmlTaggedPcrProperty)(allocTpmlTaggedPcrPropertyMemory(1))
}

// allocTpmlTaggedPcrPropertyMemory allocates memory for type C.TPML_TAGGED_PCR_PROPERTY in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmlTaggedPcrPropertyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmlTaggedPcrPropertyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmlTaggedPcrPropertyValue = unsafe.Sizeof([1]C.TPML_TAGGED_PCR_PROPERTY{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmlTaggedPcrProperty) PassRef() *C.TPML_TAGGED_PCR_PROPERTY {
	if x == nil {
		x = (*TpmlTaggedPcrProperty)(allocTpmlTaggedPcrPropertyMemory(1))
	}
	return (*C.TPML_TAGGED_PCR_PROPERTY)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmlEccCurve) Ref() *C.TPML_ECC_CURVE {
	if x == nil {
		return nil
	}
	return (*C.TPML_ECC_CURVE)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmlEccCurve) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmlEccCurveRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmlEccCurveRef(ref unsafe.Pointer) *TpmlEccCurve {
	return (*TpmlEccCurve)(ref)
}

// NewTpmlEccCurve allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmlEccCurve() *TpmlEccCurve {
	return (*TpmlEccCurve)(allocTpmlEccCurveMemory(1))
}

// allocTpmlEccCurveMemory allocates memory for type C.TPML_ECC_CURVE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmlEccCurveMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmlEccCurveValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmlEccCurveValue = unsafe.Sizeof([1]C.TPML_ECC_CURVE{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmlEccCurve) PassRef() *C.TPML_ECC_CURVE {
	if x == nil {
		x = (*TpmlEccCurve)(allocTpmlEccCurveMemory(1))
	}
	return (*C.TPML_ECC_CURVE)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmlIntelPttProperty) Ref() *C.TPML_INTEL_PTT_PROPERTY {
	if x == nil {
		return nil
	}
	return (*C.TPML_INTEL_PTT_PROPERTY)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmlIntelPttProperty) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmlIntelPttPropertyRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmlIntelPttPropertyRef(ref unsafe.Pointer) *TpmlIntelPttProperty {
	return (*TpmlIntelPttProperty)(ref)
}

// NewTpmlIntelPttProperty allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmlIntelPttProperty() *TpmlIntelPttProperty {
	return (*TpmlIntelPttProperty)(allocTpmlIntelPttPropertyMemory(1))
}

// allocTpmlIntelPttPropertyMemory allocates memory for type C.TPML_INTEL_PTT_PROPERTY in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmlIntelPttPropertyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmlIntelPttPropertyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmlIntelPttPropertyValue = unsafe.Sizeof([1]C.TPML_INTEL_PTT_PROPERTY{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmlIntelPttProperty) PassRef() *C.TPML_INTEL_PTT_PROPERTY {
	if x == nil {
		x = (*TpmlIntelPttProperty)(allocTpmlIntelPttPropertyMemory(1))
	}
	return (*C.TPML_INTEL_PTT_PROPERTY)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsCapabilityData) Ref() *C.TPMS_CAPABILITY_DATA {
	if x == nil {
		return nil
	}
	return (*C.TPMS_CAPABILITY_DATA)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsCapabilityData) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsCapabilityDataRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsCapabilityDataRef(ref unsafe.Pointer) *TpmsCapabilityData {
	return (*TpmsCapabilityData)(ref)
}

// NewTpmsCapabilityData allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsCapabilityData() *TpmsCapabilityData {
	return (*TpmsCapabilityData)(allocTpmsCapabilityDataMemory(1))
}

// allocTpmsCapabilityDataMemory allocates memory for type C.TPMS_CAPABILITY_DATA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsCapabilityDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsCapabilityDataValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsCapabilityDataValue = unsafe.Sizeof([1]C.TPMS_CAPABILITY_DATA{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsCapabilityData) PassRef() *C.TPMS_CAPABILITY_DATA {
	if x == nil {
		x = (*TpmsCapabilityData)(allocTpmsCapabilityDataMemory(1))
	}
	return (*C.TPMS_CAPABILITY_DATA)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsClockInfo) Ref() *C.TPMS_CLOCK_INFO {
	if x == nil {
		return nil
	}
	return (*C.TPMS_CLOCK_INFO)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsClockInfo) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsClockInfoRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsClockInfoRef(ref unsafe.Pointer) *TpmsClockInfo {
	return (*TpmsClockInfo)(ref)
}

// NewTpmsClockInfo allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsClockInfo() *TpmsClockInfo {
	return (*TpmsClockInfo)(allocTpmsClockInfoMemory(1))
}

// allocTpmsClockInfoMemory allocates memory for type C.TPMS_CLOCK_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsClockInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsClockInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsClockInfoValue = unsafe.Sizeof([1]C.TPMS_CLOCK_INFO{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsClockInfo) PassRef() *C.TPMS_CLOCK_INFO {
	if x == nil {
		x = (*TpmsClockInfo)(allocTpmsClockInfoMemory(1))
	}
	return (*C.TPMS_CLOCK_INFO)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsTimeInfo) Ref() *C.TPMS_TIME_INFO {
	if x == nil {
		return nil
	}
	return (*C.TPMS_TIME_INFO)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsTimeInfo) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsTimeInfoRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsTimeInfoRef(ref unsafe.Pointer) *TpmsTimeInfo {
	return (*TpmsTimeInfo)(ref)
}

// NewTpmsTimeInfo allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsTimeInfo() *TpmsTimeInfo {
	return (*TpmsTimeInfo)(allocTpmsTimeInfoMemory(1))
}

// allocTpmsTimeInfoMemory allocates memory for type C.TPMS_TIME_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsTimeInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsTimeInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsTimeInfoValue = unsafe.Sizeof([1]C.TPMS_TIME_INFO{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsTimeInfo) PassRef() *C.TPMS_TIME_INFO {
	if x == nil {
		x = (*TpmsTimeInfo)(allocTpmsTimeInfoMemory(1))
	}
	return (*C.TPMS_TIME_INFO)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsTimeAttestInfo) Ref() *C.TPMS_TIME_ATTEST_INFO {
	if x == nil {
		return nil
	}
	return (*C.TPMS_TIME_ATTEST_INFO)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsTimeAttestInfo) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsTimeAttestInfoRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsTimeAttestInfoRef(ref unsafe.Pointer) *TpmsTimeAttestInfo {
	return (*TpmsTimeAttestInfo)(ref)
}

// NewTpmsTimeAttestInfo allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsTimeAttestInfo() *TpmsTimeAttestInfo {
	return (*TpmsTimeAttestInfo)(allocTpmsTimeAttestInfoMemory(1))
}

// allocTpmsTimeAttestInfoMemory allocates memory for type C.TPMS_TIME_ATTEST_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsTimeAttestInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsTimeAttestInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsTimeAttestInfoValue = unsafe.Sizeof([1]C.TPMS_TIME_ATTEST_INFO{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsTimeAttestInfo) PassRef() *C.TPMS_TIME_ATTEST_INFO {
	if x == nil {
		x = (*TpmsTimeAttestInfo)(allocTpmsTimeAttestInfoMemory(1))
	}
	return (*C.TPMS_TIME_ATTEST_INFO)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsCertifyInfo) Ref() *C.TPMS_CERTIFY_INFO {
	if x == nil {
		return nil
	}
	return (*C.TPMS_CERTIFY_INFO)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsCertifyInfo) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsCertifyInfoRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsCertifyInfoRef(ref unsafe.Pointer) *TpmsCertifyInfo {
	return (*TpmsCertifyInfo)(ref)
}

// NewTpmsCertifyInfo allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsCertifyInfo() *TpmsCertifyInfo {
	return (*TpmsCertifyInfo)(allocTpmsCertifyInfoMemory(1))
}

// allocTpmsCertifyInfoMemory allocates memory for type C.TPMS_CERTIFY_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsCertifyInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsCertifyInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsCertifyInfoValue = unsafe.Sizeof([1]C.TPMS_CERTIFY_INFO{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsCertifyInfo) PassRef() *C.TPMS_CERTIFY_INFO {
	if x == nil {
		x = (*TpmsCertifyInfo)(allocTpmsCertifyInfoMemory(1))
	}
	return (*C.TPMS_CERTIFY_INFO)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsQuoteInfo) Ref() *C.TPMS_QUOTE_INFO {
	if x == nil {
		return nil
	}
	return (*C.TPMS_QUOTE_INFO)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsQuoteInfo) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsQuoteInfoRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsQuoteInfoRef(ref unsafe.Pointer) *TpmsQuoteInfo {
	return (*TpmsQuoteInfo)(ref)
}

// NewTpmsQuoteInfo allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsQuoteInfo() *TpmsQuoteInfo {
	return (*TpmsQuoteInfo)(allocTpmsQuoteInfoMemory(1))
}

// allocTpmsQuoteInfoMemory allocates memory for type C.TPMS_QUOTE_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsQuoteInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsQuoteInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsQuoteInfoValue = unsafe.Sizeof([1]C.TPMS_QUOTE_INFO{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsQuoteInfo) PassRef() *C.TPMS_QUOTE_INFO {
	if x == nil {
		x = (*TpmsQuoteInfo)(allocTpmsQuoteInfoMemory(1))
	}
	return (*C.TPMS_QUOTE_INFO)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsCommandAuditInfo) Ref() *C.TPMS_COMMAND_AUDIT_INFO {
	if x == nil {
		return nil
	}
	return (*C.TPMS_COMMAND_AUDIT_INFO)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsCommandAuditInfo) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsCommandAuditInfoRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsCommandAuditInfoRef(ref unsafe.Pointer) *TpmsCommandAuditInfo {
	return (*TpmsCommandAuditInfo)(ref)
}

// NewTpmsCommandAuditInfo allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsCommandAuditInfo() *TpmsCommandAuditInfo {
	return (*TpmsCommandAuditInfo)(allocTpmsCommandAuditInfoMemory(1))
}

// allocTpmsCommandAuditInfoMemory allocates memory for type C.TPMS_COMMAND_AUDIT_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsCommandAuditInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsCommandAuditInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsCommandAuditInfoValue = unsafe.Sizeof([1]C.TPMS_COMMAND_AUDIT_INFO{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsCommandAuditInfo) PassRef() *C.TPMS_COMMAND_AUDIT_INFO {
	if x == nil {
		x = (*TpmsCommandAuditInfo)(allocTpmsCommandAuditInfoMemory(1))
	}
	return (*C.TPMS_COMMAND_AUDIT_INFO)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSessionAuditInfo) Ref() *C.TPMS_SESSION_AUDIT_INFO {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SESSION_AUDIT_INFO)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSessionAuditInfo) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSessionAuditInfoRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSessionAuditInfoRef(ref unsafe.Pointer) *TpmsSessionAuditInfo {
	return (*TpmsSessionAuditInfo)(ref)
}

// NewTpmsSessionAuditInfo allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSessionAuditInfo() *TpmsSessionAuditInfo {
	return (*TpmsSessionAuditInfo)(allocTpmsSessionAuditInfoMemory(1))
}

// allocTpmsSessionAuditInfoMemory allocates memory for type C.TPMS_SESSION_AUDIT_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsSessionAuditInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsSessionAuditInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsSessionAuditInfoValue = unsafe.Sizeof([1]C.TPMS_SESSION_AUDIT_INFO{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSessionAuditInfo) PassRef() *C.TPMS_SESSION_AUDIT_INFO {
	if x == nil {
		x = (*TpmsSessionAuditInfo)(allocTpmsSessionAuditInfoMemory(1))
	}
	return (*C.TPMS_SESSION_AUDIT_INFO)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsCreationInfo) Ref() *C.TPMS_CREATION_INFO {
	if x == nil {
		return nil
	}
	return (*C.TPMS_CREATION_INFO)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsCreationInfo) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsCreationInfoRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsCreationInfoRef(ref unsafe.Pointer) *TpmsCreationInfo {
	return (*TpmsCreationInfo)(ref)
}

// NewTpmsCreationInfo allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsCreationInfo() *TpmsCreationInfo {
	return (*TpmsCreationInfo)(allocTpmsCreationInfoMemory(1))
}

// allocTpmsCreationInfoMemory allocates memory for type C.TPMS_CREATION_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsCreationInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsCreationInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsCreationInfoValue = unsafe.Sizeof([1]C.TPMS_CREATION_INFO{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsCreationInfo) PassRef() *C.TPMS_CREATION_INFO {
	if x == nil {
		x = (*TpmsCreationInfo)(allocTpmsCreationInfoMemory(1))
	}
	return (*C.TPMS_CREATION_INFO)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsNvCertifyInfo) Ref() *C.TPMS_NV_CERTIFY_INFO {
	if x == nil {
		return nil
	}
	return (*C.TPMS_NV_CERTIFY_INFO)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsNvCertifyInfo) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsNvCertifyInfoRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsNvCertifyInfoRef(ref unsafe.Pointer) *TpmsNvCertifyInfo {
	return (*TpmsNvCertifyInfo)(ref)
}

// NewTpmsNvCertifyInfo allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsNvCertifyInfo() *TpmsNvCertifyInfo {
	return (*TpmsNvCertifyInfo)(allocTpmsNvCertifyInfoMemory(1))
}

// allocTpmsNvCertifyInfoMemory allocates memory for type C.TPMS_NV_CERTIFY_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsNvCertifyInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsNvCertifyInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsNvCertifyInfoValue = unsafe.Sizeof([1]C.TPMS_NV_CERTIFY_INFO{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsNvCertifyInfo) PassRef() *C.TPMS_NV_CERTIFY_INFO {
	if x == nil {
		x = (*TpmsNvCertifyInfo)(allocTpmsNvCertifyInfoMemory(1))
	}
	return (*C.TPMS_NV_CERTIFY_INFO)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsAttest) Ref() *C.TPMS_ATTEST {
	if x == nil {
		return nil
	}
	return (*C.TPMS_ATTEST)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsAttest) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsAttestRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsAttestRef(ref unsafe.Pointer) *TpmsAttest {
	return (*TpmsAttest)(ref)
}

// NewTpmsAttest allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsAttest() *TpmsAttest {
	return (*TpmsAttest)(allocTpmsAttestMemory(1))
}

// allocTpmsAttestMemory allocates memory for type C.TPMS_ATTEST in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsAttestMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsAttestValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsAttestValue = unsafe.Sizeof([1]C.TPMS_ATTEST{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsAttest) PassRef() *C.TPMS_ATTEST {
	if x == nil {
		x = (*TpmsAttest)(allocTpmsAttestMemory(1))
	}
	return (*C.TPMS_ATTEST)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bAttest) Ref() *C.TPM2B_ATTEST {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_ATTEST)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bAttest) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bAttestRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bAttestRef(ref unsafe.Pointer) *Tpm2bAttest {
	return (*Tpm2bAttest)(ref)
}

// NewTpm2bAttest allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bAttest() *Tpm2bAttest {
	return (*Tpm2bAttest)(allocTpm2bAttestMemory(1))
}

// allocTpm2bAttestMemory allocates memory for type C.TPM2B_ATTEST in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bAttestMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bAttestValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bAttestValue = unsafe.Sizeof([1]C.TPM2B_ATTEST{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bAttest) PassRef() *C.TPM2B_ATTEST {
	if x == nil {
		x = (*Tpm2bAttest)(allocTpm2bAttestMemory(1))
	}
	return (*C.TPM2B_ATTEST)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsAuthCommand) Ref() *C.TPMS_AUTH_COMMAND {
	if x == nil {
		return nil
	}
	return (*C.TPMS_AUTH_COMMAND)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsAuthCommand) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsAuthCommandRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsAuthCommandRef(ref unsafe.Pointer) *TpmsAuthCommand {
	return (*TpmsAuthCommand)(ref)
}

// NewTpmsAuthCommand allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsAuthCommand() *TpmsAuthCommand {
	return (*TpmsAuthCommand)(allocTpmsAuthCommandMemory(1))
}

// allocTpmsAuthCommandMemory allocates memory for type C.TPMS_AUTH_COMMAND in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsAuthCommandMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsAuthCommandValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsAuthCommandValue = unsafe.Sizeof([1]C.TPMS_AUTH_COMMAND{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsAuthCommand) PassRef() *C.TPMS_AUTH_COMMAND {
	if x == nil {
		x = (*TpmsAuthCommand)(allocTpmsAuthCommandMemory(1))
	}
	return (*C.TPMS_AUTH_COMMAND)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsAuthResponse) Ref() *C.TPMS_AUTH_RESPONSE {
	if x == nil {
		return nil
	}
	return (*C.TPMS_AUTH_RESPONSE)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsAuthResponse) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsAuthResponseRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsAuthResponseRef(ref unsafe.Pointer) *TpmsAuthResponse {
	return (*TpmsAuthResponse)(ref)
}

// NewTpmsAuthResponse allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsAuthResponse() *TpmsAuthResponse {
	return (*TpmsAuthResponse)(allocTpmsAuthResponseMemory(1))
}

// allocTpmsAuthResponseMemory allocates memory for type C.TPMS_AUTH_RESPONSE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsAuthResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsAuthResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsAuthResponseValue = unsafe.Sizeof([1]C.TPMS_AUTH_RESPONSE{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsAuthResponse) PassRef() *C.TPMS_AUTH_RESPONSE {
	if x == nil {
		x = (*TpmsAuthResponse)(allocTpmsAuthResponseMemory(1))
	}
	return (*C.TPMS_AUTH_RESPONSE)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmtSymDef) Ref() *C.TPMT_SYM_DEF {
	if x == nil {
		return nil
	}
	return (*C.TPMT_SYM_DEF)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmtSymDef) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmtSymDefRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmtSymDefRef(ref unsafe.Pointer) *TpmtSymDef {
	return (*TpmtSymDef)(ref)
}

// NewTpmtSymDef allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmtSymDef() *TpmtSymDef {
	return (*TpmtSymDef)(allocTpmtSymDefMemory(1))
}

// allocTpmtSymDefMemory allocates memory for type C.TPMT_SYM_DEF in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtSymDefMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtSymDefValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtSymDefValue = unsafe.Sizeof([1]C.TPMT_SYM_DEF{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmtSymDef) PassRef() *C.TPMT_SYM_DEF {
	if x == nil {
		x = (*TpmtSymDef)(allocTpmtSymDefMemory(1))
	}
	return (*C.TPMT_SYM_DEF)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmtSymDefObject) Ref() *C.TPMT_SYM_DEF_OBJECT {
	if x == nil {
		return nil
	}
	return (*C.TPMT_SYM_DEF_OBJECT)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmtSymDefObject) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmtSymDefObjectRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmtSymDefObjectRef(ref unsafe.Pointer) *TpmtSymDefObject {
	return (*TpmtSymDefObject)(ref)
}

// NewTpmtSymDefObject allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmtSymDefObject() *TpmtSymDefObject {
	return (*TpmtSymDefObject)(allocTpmtSymDefObjectMemory(1))
}

// allocTpmtSymDefObjectMemory allocates memory for type C.TPMT_SYM_DEF_OBJECT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtSymDefObjectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtSymDefObjectValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtSymDefObjectValue = unsafe.Sizeof([1]C.TPMT_SYM_DEF_OBJECT{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmtSymDefObject) PassRef() *C.TPMT_SYM_DEF_OBJECT {
	if x == nil {
		x = (*TpmtSymDefObject)(allocTpmtSymDefObjectMemory(1))
	}
	return (*C.TPMT_SYM_DEF_OBJECT)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bSymKey) Ref() *C.TPM2B_SYM_KEY {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_SYM_KEY)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bSymKey) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bSymKeyRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bSymKeyRef(ref unsafe.Pointer) *Tpm2bSymKey {
	return (*Tpm2bSymKey)(ref)
}

// NewTpm2bSymKey allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bSymKey() *Tpm2bSymKey {
	return (*Tpm2bSymKey)(allocTpm2bSymKeyMemory(1))
}

// allocTpm2bSymKeyMemory allocates memory for type C.TPM2B_SYM_KEY in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bSymKeyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bSymKeyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bSymKeyValue = unsafe.Sizeof([1]C.TPM2B_SYM_KEY{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bSymKey) PassRef() *C.TPM2B_SYM_KEY {
	if x == nil {
		x = (*Tpm2bSymKey)(allocTpm2bSymKeyMemory(1))
	}
	return (*C.TPM2B_SYM_KEY)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSymcipherParms) Ref() *C.TPMS_SYMCIPHER_PARMS {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SYMCIPHER_PARMS)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSymcipherParms) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSymcipherParmsRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSymcipherParmsRef(ref unsafe.Pointer) *TpmsSymcipherParms {
	return (*TpmsSymcipherParms)(ref)
}

// NewTpmsSymcipherParms allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSymcipherParms() *TpmsSymcipherParms {
	return (*TpmsSymcipherParms)(allocTpmsSymcipherParmsMemory(1))
}

// allocTpmsSymcipherParmsMemory allocates memory for type C.TPMS_SYMCIPHER_PARMS in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsSymcipherParmsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsSymcipherParmsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsSymcipherParmsValue = unsafe.Sizeof([1]C.TPMS_SYMCIPHER_PARMS{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSymcipherParms) PassRef() *C.TPMS_SYMCIPHER_PARMS {
	if x == nil {
		x = (*TpmsSymcipherParms)(allocTpmsSymcipherParmsMemory(1))
	}
	return (*C.TPMS_SYMCIPHER_PARMS)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bSensitiveData) Ref() *C.TPM2B_SENSITIVE_DATA {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_SENSITIVE_DATA)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bSensitiveData) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bSensitiveDataRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bSensitiveDataRef(ref unsafe.Pointer) *Tpm2bSensitiveData {
	return (*Tpm2bSensitiveData)(ref)
}

// NewTpm2bSensitiveData allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bSensitiveData() *Tpm2bSensitiveData {
	return (*Tpm2bSensitiveData)(allocTpm2bSensitiveDataMemory(1))
}

// allocTpm2bSensitiveDataMemory allocates memory for type C.TPM2B_SENSITIVE_DATA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bSensitiveDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bSensitiveDataValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bSensitiveDataValue = unsafe.Sizeof([1]C.TPM2B_SENSITIVE_DATA{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bSensitiveData) PassRef() *C.TPM2B_SENSITIVE_DATA {
	if x == nil {
		x = (*Tpm2bSensitiveData)(allocTpm2bSensitiveDataMemory(1))
	}
	return (*C.TPM2B_SENSITIVE_DATA)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSensitiveCreate) Ref() *C.TPMS_SENSITIVE_CREATE {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SENSITIVE_CREATE)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSensitiveCreate) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSensitiveCreateRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSensitiveCreateRef(ref unsafe.Pointer) *TpmsSensitiveCreate {
	return (*TpmsSensitiveCreate)(ref)
}

// NewTpmsSensitiveCreate allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSensitiveCreate() *TpmsSensitiveCreate {
	return (*TpmsSensitiveCreate)(allocTpmsSensitiveCreateMemory(1))
}

// allocTpmsSensitiveCreateMemory allocates memory for type C.TPMS_SENSITIVE_CREATE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsSensitiveCreateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsSensitiveCreateValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsSensitiveCreateValue = unsafe.Sizeof([1]C.TPMS_SENSITIVE_CREATE{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSensitiveCreate) PassRef() *C.TPMS_SENSITIVE_CREATE {
	if x == nil {
		x = (*TpmsSensitiveCreate)(allocTpmsSensitiveCreateMemory(1))
	}
	return (*C.TPMS_SENSITIVE_CREATE)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bSensitiveCreate) Ref() *C.TPM2B_SENSITIVE_CREATE {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_SENSITIVE_CREATE)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bSensitiveCreate) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bSensitiveCreateRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bSensitiveCreateRef(ref unsafe.Pointer) *Tpm2bSensitiveCreate {
	return (*Tpm2bSensitiveCreate)(ref)
}

// NewTpm2bSensitiveCreate allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bSensitiveCreate() *Tpm2bSensitiveCreate {
	return (*Tpm2bSensitiveCreate)(allocTpm2bSensitiveCreateMemory(1))
}

// allocTpm2bSensitiveCreateMemory allocates memory for type C.TPM2B_SENSITIVE_CREATE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bSensitiveCreateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bSensitiveCreateValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bSensitiveCreateValue = unsafe.Sizeof([1]C.TPM2B_SENSITIVE_CREATE{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bSensitiveCreate) PassRef() *C.TPM2B_SENSITIVE_CREATE {
	if x == nil {
		x = (*Tpm2bSensitiveCreate)(allocTpm2bSensitiveCreateMemory(1))
	}
	return (*C.TPM2B_SENSITIVE_CREATE)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSchemeHash) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSchemeHash) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSchemeHashRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSchemeHashRef(ref unsafe.Pointer) *TpmsSchemeHash {
	return (*TpmsSchemeHash)(ref)
}

// NewTpmsSchemeHash allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSchemeHash() *TpmsSchemeHash {
	return (*TpmsSchemeHash)(allocTpmsSchemeHashMemory(1))
}

// allocTpmsSchemeHashMemory allocates memory for type C.TPMS_SCHEME_HASH in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsSchemeHashMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsSchemeHashValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsSchemeHashValue = unsafe.Sizeof([1]C.TPMS_SCHEME_HASH{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSchemeHash) PassRef() *C.TPMS_SCHEME_HASH {
	if x == nil {
		x = (*TpmsSchemeHash)(allocTpmsSchemeHashMemory(1))
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSchemeEcdaa) Ref() *C.TPMS_SCHEME_ECDAA {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SCHEME_ECDAA)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSchemeEcdaa) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSchemeEcdaaRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSchemeEcdaaRef(ref unsafe.Pointer) *TpmsSchemeEcdaa {
	return (*TpmsSchemeEcdaa)(ref)
}

// NewTpmsSchemeEcdaa allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSchemeEcdaa() *TpmsSchemeEcdaa {
	return (*TpmsSchemeEcdaa)(allocTpmsSchemeEcdaaMemory(1))
}

// allocTpmsSchemeEcdaaMemory allocates memory for type C.TPMS_SCHEME_ECDAA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsSchemeEcdaaMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsSchemeEcdaaValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsSchemeEcdaaValue = unsafe.Sizeof([1]C.TPMS_SCHEME_ECDAA{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSchemeEcdaa) PassRef() *C.TPMS_SCHEME_ECDAA {
	if x == nil {
		x = (*TpmsSchemeEcdaa)(allocTpmsSchemeEcdaaMemory(1))
	}
	return (*C.TPMS_SCHEME_ECDAA)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSchemeHmac) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSchemeHmac) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSchemeHmacRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSchemeHmacRef(ref unsafe.Pointer) *TpmsSchemeHmac {
	return (*TpmsSchemeHmac)(ref)
}

// NewTpmsSchemeHmac allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSchemeHmac() *TpmsSchemeHmac {
	return (*TpmsSchemeHmac)(allocTpmsSchemeHashMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSchemeHmac) PassRef() *C.TPMS_SCHEME_HASH {
	if x == nil {
		x = (*TpmsSchemeHmac)(allocTpmsSchemeHashMemory(1))
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSchemeXor) Ref() *C.TPMS_SCHEME_XOR {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SCHEME_XOR)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSchemeXor) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSchemeXorRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSchemeXorRef(ref unsafe.Pointer) *TpmsSchemeXor {
	return (*TpmsSchemeXor)(ref)
}

// NewTpmsSchemeXor allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSchemeXor() *TpmsSchemeXor {
	return (*TpmsSchemeXor)(allocTpmsSchemeXorMemory(1))
}

// allocTpmsSchemeXorMemory allocates memory for type C.TPMS_SCHEME_XOR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsSchemeXorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsSchemeXorValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsSchemeXorValue = unsafe.Sizeof([1]C.TPMS_SCHEME_XOR{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSchemeXor) PassRef() *C.TPMS_SCHEME_XOR {
	if x == nil {
		x = (*TpmsSchemeXor)(allocTpmsSchemeXorMemory(1))
	}
	return (*C.TPMS_SCHEME_XOR)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmtKeyedhashScheme) Ref() *C.TPMT_KEYEDHASH_SCHEME {
	if x == nil {
		return nil
	}
	return (*C.TPMT_KEYEDHASH_SCHEME)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmtKeyedhashScheme) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmtKeyedhashSchemeRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmtKeyedhashSchemeRef(ref unsafe.Pointer) *TpmtKeyedhashScheme {
	return (*TpmtKeyedhashScheme)(ref)
}

// NewTpmtKeyedhashScheme allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmtKeyedhashScheme() *TpmtKeyedhashScheme {
	return (*TpmtKeyedhashScheme)(allocTpmtKeyedhashSchemeMemory(1))
}

// allocTpmtKeyedhashSchemeMemory allocates memory for type C.TPMT_KEYEDHASH_SCHEME in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtKeyedhashSchemeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtKeyedhashSchemeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtKeyedhashSchemeValue = unsafe.Sizeof([1]C.TPMT_KEYEDHASH_SCHEME{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmtKeyedhashScheme) PassRef() *C.TPMT_KEYEDHASH_SCHEME {
	if x == nil {
		x = (*TpmtKeyedhashScheme)(allocTpmtKeyedhashSchemeMemory(1))
	}
	return (*C.TPMT_KEYEDHASH_SCHEME)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSigSchemeRsassa) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSigSchemeRsassa) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSigSchemeRsassaRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSigSchemeRsassaRef(ref unsafe.Pointer) *TpmsSigSchemeRsassa {
	return (*TpmsSigSchemeRsassa)(ref)
}

// NewTpmsSigSchemeRsassa allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSigSchemeRsassa() *TpmsSigSchemeRsassa {
	return (*TpmsSigSchemeRsassa)(allocTpmsSchemeHashMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSigSchemeRsassa) PassRef() *C.TPMS_SCHEME_HASH {
	if x == nil {
		x = (*TpmsSigSchemeRsassa)(allocTpmsSchemeHashMemory(1))
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSigSchemeRsapss) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSigSchemeRsapss) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSigSchemeRsapssRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSigSchemeRsapssRef(ref unsafe.Pointer) *TpmsSigSchemeRsapss {
	return (*TpmsSigSchemeRsapss)(ref)
}

// NewTpmsSigSchemeRsapss allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSigSchemeRsapss() *TpmsSigSchemeRsapss {
	return (*TpmsSigSchemeRsapss)(allocTpmsSchemeHashMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSigSchemeRsapss) PassRef() *C.TPMS_SCHEME_HASH {
	if x == nil {
		x = (*TpmsSigSchemeRsapss)(allocTpmsSchemeHashMemory(1))
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSigSchemeEcdsa) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSigSchemeEcdsa) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSigSchemeEcdsaRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSigSchemeEcdsaRef(ref unsafe.Pointer) *TpmsSigSchemeEcdsa {
	return (*TpmsSigSchemeEcdsa)(ref)
}

// NewTpmsSigSchemeEcdsa allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSigSchemeEcdsa() *TpmsSigSchemeEcdsa {
	return (*TpmsSigSchemeEcdsa)(allocTpmsSchemeHashMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSigSchemeEcdsa) PassRef() *C.TPMS_SCHEME_HASH {
	if x == nil {
		x = (*TpmsSigSchemeEcdsa)(allocTpmsSchemeHashMemory(1))
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSigSchemeSm2) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSigSchemeSm2) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSigSchemeSm2Ref converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSigSchemeSm2Ref(ref unsafe.Pointer) *TpmsSigSchemeSm2 {
	return (*TpmsSigSchemeSm2)(ref)
}

// NewTpmsSigSchemeSm2 allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSigSchemeSm2() *TpmsSigSchemeSm2 {
	return (*TpmsSigSchemeSm2)(allocTpmsSchemeHashMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSigSchemeSm2) PassRef() *C.TPMS_SCHEME_HASH {
	if x == nil {
		x = (*TpmsSigSchemeSm2)(allocTpmsSchemeHashMemory(1))
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSigSchemeEcschnorr) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSigSchemeEcschnorr) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSigSchemeEcschnorrRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSigSchemeEcschnorrRef(ref unsafe.Pointer) *TpmsSigSchemeEcschnorr {
	return (*TpmsSigSchemeEcschnorr)(ref)
}

// NewTpmsSigSchemeEcschnorr allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSigSchemeEcschnorr() *TpmsSigSchemeEcschnorr {
	return (*TpmsSigSchemeEcschnorr)(allocTpmsSchemeHashMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSigSchemeEcschnorr) PassRef() *C.TPMS_SCHEME_HASH {
	if x == nil {
		x = (*TpmsSigSchemeEcschnorr)(allocTpmsSchemeHashMemory(1))
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSigSchemeEcdaa) Ref() *C.TPMS_SCHEME_ECDAA {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SCHEME_ECDAA)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSigSchemeEcdaa) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSigSchemeEcdaaRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSigSchemeEcdaaRef(ref unsafe.Pointer) *TpmsSigSchemeEcdaa {
	return (*TpmsSigSchemeEcdaa)(ref)
}

// NewTpmsSigSchemeEcdaa allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSigSchemeEcdaa() *TpmsSigSchemeEcdaa {
	return (*TpmsSigSchemeEcdaa)(allocTpmsSchemeEcdaaMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSigSchemeEcdaa) PassRef() *C.TPMS_SCHEME_ECDAA {
	if x == nil {
		x = (*TpmsSigSchemeEcdaa)(allocTpmsSchemeEcdaaMemory(1))
	}
	return (*C.TPMS_SCHEME_ECDAA)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmtSigScheme) Ref() *C.TPMT_SIG_SCHEME {
	if x == nil {
		return nil
	}
	return (*C.TPMT_SIG_SCHEME)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmtSigScheme) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmtSigSchemeRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmtSigSchemeRef(ref unsafe.Pointer) *TpmtSigScheme {
	return (*TpmtSigScheme)(ref)
}

// NewTpmtSigScheme allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmtSigScheme() *TpmtSigScheme {
	return (*TpmtSigScheme)(allocTpmtSigSchemeMemory(1))
}

// allocTpmtSigSchemeMemory allocates memory for type C.TPMT_SIG_SCHEME in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtSigSchemeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtSigSchemeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtSigSchemeValue = unsafe.Sizeof([1]C.TPMT_SIG_SCHEME{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmtSigScheme) PassRef() *C.TPMT_SIG_SCHEME {
	if x == nil {
		x = (*TpmtSigScheme)(allocTpmtSigSchemeMemory(1))
	}
	return (*C.TPMT_SIG_SCHEME)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsEncSchemeOaep) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsEncSchemeOaep) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsEncSchemeOaepRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsEncSchemeOaepRef(ref unsafe.Pointer) *TpmsEncSchemeOaep {
	return (*TpmsEncSchemeOaep)(ref)
}

// NewTpmsEncSchemeOaep allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsEncSchemeOaep() *TpmsEncSchemeOaep {
	return (*TpmsEncSchemeOaep)(allocTpmsSchemeHashMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsEncSchemeOaep) PassRef() *C.TPMS_SCHEME_HASH {
	if x == nil {
		x = (*TpmsEncSchemeOaep)(allocTpmsSchemeHashMemory(1))
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsEncSchemeRsaes) Ref() *C.TPMS_EMPTY {
	if x == nil {
		return nil
	}
	return (*C.TPMS_EMPTY)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsEncSchemeRsaes) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsEncSchemeRsaesRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsEncSchemeRsaesRef(ref unsafe.Pointer) *TpmsEncSchemeRsaes {
	return (*TpmsEncSchemeRsaes)(ref)
}

// NewTpmsEncSchemeRsaes allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsEncSchemeRsaes() *TpmsEncSchemeRsaes {
	return (*TpmsEncSchemeRsaes)(allocTpmsEmptyMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsEncSchemeRsaes) PassRef() *C.TPMS_EMPTY {
	if x == nil {
		x = (*TpmsEncSchemeRsaes)(allocTpmsEmptyMemory(1))
	}
	return (*C.TPMS_EMPTY)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsKeySchemeEcdh) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsKeySchemeEcdh) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsKeySchemeEcdhRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsKeySchemeEcdhRef(ref unsafe.Pointer) *TpmsKeySchemeEcdh {
	return (*TpmsKeySchemeEcdh)(ref)
}

// NewTpmsKeySchemeEcdh allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsKeySchemeEcdh() *TpmsKeySchemeEcdh {
	return (*TpmsKeySchemeEcdh)(allocTpmsSchemeHashMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsKeySchemeEcdh) PassRef() *C.TPMS_SCHEME_HASH {
	if x == nil {
		x = (*TpmsKeySchemeEcdh)(allocTpmsSchemeHashMemory(1))
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsKeySchemeEcmqv) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsKeySchemeEcmqv) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsKeySchemeEcmqvRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsKeySchemeEcmqvRef(ref unsafe.Pointer) *TpmsKeySchemeEcmqv {
	return (*TpmsKeySchemeEcmqv)(ref)
}

// NewTpmsKeySchemeEcmqv allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsKeySchemeEcmqv() *TpmsKeySchemeEcmqv {
	return (*TpmsKeySchemeEcmqv)(allocTpmsSchemeHashMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsKeySchemeEcmqv) PassRef() *C.TPMS_SCHEME_HASH {
	if x == nil {
		x = (*TpmsKeySchemeEcmqv)(allocTpmsSchemeHashMemory(1))
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSchemeMgf1) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSchemeMgf1) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSchemeMgf1Ref converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSchemeMgf1Ref(ref unsafe.Pointer) *TpmsSchemeMgf1 {
	return (*TpmsSchemeMgf1)(ref)
}

// NewTpmsSchemeMgf1 allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSchemeMgf1() *TpmsSchemeMgf1 {
	return (*TpmsSchemeMgf1)(allocTpmsSchemeHashMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSchemeMgf1) PassRef() *C.TPMS_SCHEME_HASH {
	if x == nil {
		x = (*TpmsSchemeMgf1)(allocTpmsSchemeHashMemory(1))
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSchemeKdf1Sp80056a) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSchemeKdf1Sp80056a) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSchemeKdf1Sp80056aRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSchemeKdf1Sp80056aRef(ref unsafe.Pointer) *TpmsSchemeKdf1Sp80056a {
	return (*TpmsSchemeKdf1Sp80056a)(ref)
}

// NewTpmsSchemeKdf1Sp80056a allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSchemeKdf1Sp80056a() *TpmsSchemeKdf1Sp80056a {
	return (*TpmsSchemeKdf1Sp80056a)(allocTpmsSchemeHashMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSchemeKdf1Sp80056a) PassRef() *C.TPMS_SCHEME_HASH {
	if x == nil {
		x = (*TpmsSchemeKdf1Sp80056a)(allocTpmsSchemeHashMemory(1))
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSchemeKdf2) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSchemeKdf2) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSchemeKdf2Ref converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSchemeKdf2Ref(ref unsafe.Pointer) *TpmsSchemeKdf2 {
	return (*TpmsSchemeKdf2)(ref)
}

// NewTpmsSchemeKdf2 allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSchemeKdf2() *TpmsSchemeKdf2 {
	return (*TpmsSchemeKdf2)(allocTpmsSchemeHashMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSchemeKdf2) PassRef() *C.TPMS_SCHEME_HASH {
	if x == nil {
		x = (*TpmsSchemeKdf2)(allocTpmsSchemeHashMemory(1))
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSchemeKdf1Sp800108) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSchemeKdf1Sp800108) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSchemeKdf1Sp800108Ref converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSchemeKdf1Sp800108Ref(ref unsafe.Pointer) *TpmsSchemeKdf1Sp800108 {
	return (*TpmsSchemeKdf1Sp800108)(ref)
}

// NewTpmsSchemeKdf1Sp800108 allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSchemeKdf1Sp800108() *TpmsSchemeKdf1Sp800108 {
	return (*TpmsSchemeKdf1Sp800108)(allocTpmsSchemeHashMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSchemeKdf1Sp800108) PassRef() *C.TPMS_SCHEME_HASH {
	if x == nil {
		x = (*TpmsSchemeKdf1Sp800108)(allocTpmsSchemeHashMemory(1))
	}
	return (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmtKdfScheme) Ref() *C.TPMT_KDF_SCHEME {
	if x == nil {
		return nil
	}
	return (*C.TPMT_KDF_SCHEME)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmtKdfScheme) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmtKdfSchemeRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmtKdfSchemeRef(ref unsafe.Pointer) *TpmtKdfScheme {
	return (*TpmtKdfScheme)(ref)
}

// NewTpmtKdfScheme allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmtKdfScheme() *TpmtKdfScheme {
	return (*TpmtKdfScheme)(allocTpmtKdfSchemeMemory(1))
}

// allocTpmtKdfSchemeMemory allocates memory for type C.TPMT_KDF_SCHEME in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtKdfSchemeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtKdfSchemeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtKdfSchemeValue = unsafe.Sizeof([1]C.TPMT_KDF_SCHEME{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmtKdfScheme) PassRef() *C.TPMT_KDF_SCHEME {
	if x == nil {
		x = (*TpmtKdfScheme)(allocTpmtKdfSchemeMemory(1))
	}
	return (*C.TPMT_KDF_SCHEME)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmtAsymScheme) Ref() *C.TPMT_ASYM_SCHEME {
	if x == nil {
		return nil
	}
	return (*C.TPMT_ASYM_SCHEME)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmtAsymScheme) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmtAsymSchemeRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmtAsymSchemeRef(ref unsafe.Pointer) *TpmtAsymScheme {
	return (*TpmtAsymScheme)(ref)
}

// NewTpmtAsymScheme allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmtAsymScheme() *TpmtAsymScheme {
	return (*TpmtAsymScheme)(allocTpmtAsymSchemeMemory(1))
}

// allocTpmtAsymSchemeMemory allocates memory for type C.TPMT_ASYM_SCHEME in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtAsymSchemeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtAsymSchemeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtAsymSchemeValue = unsafe.Sizeof([1]C.TPMT_ASYM_SCHEME{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmtAsymScheme) PassRef() *C.TPMT_ASYM_SCHEME {
	if x == nil {
		x = (*TpmtAsymScheme)(allocTpmtAsymSchemeMemory(1))
	}
	return (*C.TPMT_ASYM_SCHEME)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmtRsaScheme) Ref() *C.TPMT_RSA_SCHEME {
	if x == nil {
		return nil
	}
	return (*C.TPMT_RSA_SCHEME)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmtRsaScheme) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmtRsaSchemeRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmtRsaSchemeRef(ref unsafe.Pointer) *TpmtRsaScheme {
	return (*TpmtRsaScheme)(ref)
}

// NewTpmtRsaScheme allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmtRsaScheme() *TpmtRsaScheme {
	return (*TpmtRsaScheme)(allocTpmtRsaSchemeMemory(1))
}

// allocTpmtRsaSchemeMemory allocates memory for type C.TPMT_RSA_SCHEME in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtRsaSchemeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtRsaSchemeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtRsaSchemeValue = unsafe.Sizeof([1]C.TPMT_RSA_SCHEME{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmtRsaScheme) PassRef() *C.TPMT_RSA_SCHEME {
	if x == nil {
		x = (*TpmtRsaScheme)(allocTpmtRsaSchemeMemory(1))
	}
	return (*C.TPMT_RSA_SCHEME)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmtRsaDecrypt) Ref() *C.TPMT_RSA_DECRYPT {
	if x == nil {
		return nil
	}
	return (*C.TPMT_RSA_DECRYPT)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmtRsaDecrypt) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmtRsaDecryptRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmtRsaDecryptRef(ref unsafe.Pointer) *TpmtRsaDecrypt {
	return (*TpmtRsaDecrypt)(ref)
}

// NewTpmtRsaDecrypt allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmtRsaDecrypt() *TpmtRsaDecrypt {
	return (*TpmtRsaDecrypt)(allocTpmtRsaDecryptMemory(1))
}

// allocTpmtRsaDecryptMemory allocates memory for type C.TPMT_RSA_DECRYPT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtRsaDecryptMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtRsaDecryptValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtRsaDecryptValue = unsafe.Sizeof([1]C.TPMT_RSA_DECRYPT{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmtRsaDecrypt) PassRef() *C.TPMT_RSA_DECRYPT {
	if x == nil {
		x = (*TpmtRsaDecrypt)(allocTpmtRsaDecryptMemory(1))
	}
	return (*C.TPMT_RSA_DECRYPT)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bPublicKeyRsa) Ref() *C.TPM2B_PUBLIC_KEY_RSA {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_PUBLIC_KEY_RSA)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bPublicKeyRsa) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bPublicKeyRsaRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bPublicKeyRsaRef(ref unsafe.Pointer) *Tpm2bPublicKeyRsa {
	return (*Tpm2bPublicKeyRsa)(ref)
}

// NewTpm2bPublicKeyRsa allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bPublicKeyRsa() *Tpm2bPublicKeyRsa {
	return (*Tpm2bPublicKeyRsa)(allocTpm2bPublicKeyRsaMemory(1))
}

// allocTpm2bPublicKeyRsaMemory allocates memory for type C.TPM2B_PUBLIC_KEY_RSA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bPublicKeyRsaMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bPublicKeyRsaValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bPublicKeyRsaValue = unsafe.Sizeof([1]C.TPM2B_PUBLIC_KEY_RSA{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bPublicKeyRsa) PassRef() *C.TPM2B_PUBLIC_KEY_RSA {
	if x == nil {
		x = (*Tpm2bPublicKeyRsa)(allocTpm2bPublicKeyRsaMemory(1))
	}
	return (*C.TPM2B_PUBLIC_KEY_RSA)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bPrivateKeyRsa) Ref() *C.TPM2B_PRIVATE_KEY_RSA {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_PRIVATE_KEY_RSA)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bPrivateKeyRsa) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bPrivateKeyRsaRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bPrivateKeyRsaRef(ref unsafe.Pointer) *Tpm2bPrivateKeyRsa {
	return (*Tpm2bPrivateKeyRsa)(ref)
}

// NewTpm2bPrivateKeyRsa allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bPrivateKeyRsa() *Tpm2bPrivateKeyRsa {
	return (*Tpm2bPrivateKeyRsa)(allocTpm2bPrivateKeyRsaMemory(1))
}

// allocTpm2bPrivateKeyRsaMemory allocates memory for type C.TPM2B_PRIVATE_KEY_RSA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bPrivateKeyRsaMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bPrivateKeyRsaValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bPrivateKeyRsaValue = unsafe.Sizeof([1]C.TPM2B_PRIVATE_KEY_RSA{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bPrivateKeyRsa) PassRef() *C.TPM2B_PRIVATE_KEY_RSA {
	if x == nil {
		x = (*Tpm2bPrivateKeyRsa)(allocTpm2bPrivateKeyRsaMemory(1))
	}
	return (*C.TPM2B_PRIVATE_KEY_RSA)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bEccParameter) Ref() *C.TPM2B_ECC_PARAMETER {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_ECC_PARAMETER)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bEccParameter) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bEccParameterRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bEccParameterRef(ref unsafe.Pointer) *Tpm2bEccParameter {
	return (*Tpm2bEccParameter)(ref)
}

// NewTpm2bEccParameter allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bEccParameter() *Tpm2bEccParameter {
	return (*Tpm2bEccParameter)(allocTpm2bEccParameterMemory(1))
}

// allocTpm2bEccParameterMemory allocates memory for type C.TPM2B_ECC_PARAMETER in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bEccParameterMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bEccParameterValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bEccParameterValue = unsafe.Sizeof([1]C.TPM2B_ECC_PARAMETER{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bEccParameter) PassRef() *C.TPM2B_ECC_PARAMETER {
	if x == nil {
		x = (*Tpm2bEccParameter)(allocTpm2bEccParameterMemory(1))
	}
	return (*C.TPM2B_ECC_PARAMETER)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsEccPoint) Ref() *C.TPMS_ECC_POINT {
	if x == nil {
		return nil
	}
	return (*C.TPMS_ECC_POINT)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsEccPoint) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsEccPointRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsEccPointRef(ref unsafe.Pointer) *TpmsEccPoint {
	return (*TpmsEccPoint)(ref)
}

// NewTpmsEccPoint allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsEccPoint() *TpmsEccPoint {
	return (*TpmsEccPoint)(allocTpmsEccPointMemory(1))
}

// allocTpmsEccPointMemory allocates memory for type C.TPMS_ECC_POINT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsEccPointMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsEccPointValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsEccPointValue = unsafe.Sizeof([1]C.TPMS_ECC_POINT{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsEccPoint) PassRef() *C.TPMS_ECC_POINT {
	if x == nil {
		x = (*TpmsEccPoint)(allocTpmsEccPointMemory(1))
	}
	return (*C.TPMS_ECC_POINT)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bEccPoint) Ref() *C.TPM2B_ECC_POINT {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_ECC_POINT)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bEccPoint) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bEccPointRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bEccPointRef(ref unsafe.Pointer) *Tpm2bEccPoint {
	return (*Tpm2bEccPoint)(ref)
}

// NewTpm2bEccPoint allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bEccPoint() *Tpm2bEccPoint {
	return (*Tpm2bEccPoint)(allocTpm2bEccPointMemory(1))
}

// allocTpm2bEccPointMemory allocates memory for type C.TPM2B_ECC_POINT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bEccPointMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bEccPointValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bEccPointValue = unsafe.Sizeof([1]C.TPM2B_ECC_POINT{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bEccPoint) PassRef() *C.TPM2B_ECC_POINT {
	if x == nil {
		x = (*Tpm2bEccPoint)(allocTpm2bEccPointMemory(1))
	}
	return (*C.TPM2B_ECC_POINT)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmtEccScheme) Ref() *C.TPMT_ECC_SCHEME {
	if x == nil {
		return nil
	}
	return (*C.TPMT_ECC_SCHEME)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmtEccScheme) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmtEccSchemeRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmtEccSchemeRef(ref unsafe.Pointer) *TpmtEccScheme {
	return (*TpmtEccScheme)(ref)
}

// NewTpmtEccScheme allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmtEccScheme() *TpmtEccScheme {
	return (*TpmtEccScheme)(allocTpmtEccSchemeMemory(1))
}

// allocTpmtEccSchemeMemory allocates memory for type C.TPMT_ECC_SCHEME in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtEccSchemeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtEccSchemeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtEccSchemeValue = unsafe.Sizeof([1]C.TPMT_ECC_SCHEME{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmtEccScheme) PassRef() *C.TPMT_ECC_SCHEME {
	if x == nil {
		x = (*TpmtEccScheme)(allocTpmtEccSchemeMemory(1))
	}
	return (*C.TPMT_ECC_SCHEME)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsAlgorithmDetailEcc) Ref() *C.TPMS_ALGORITHM_DETAIL_ECC {
	if x == nil {
		return nil
	}
	return (*C.TPMS_ALGORITHM_DETAIL_ECC)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsAlgorithmDetailEcc) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsAlgorithmDetailEccRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsAlgorithmDetailEccRef(ref unsafe.Pointer) *TpmsAlgorithmDetailEcc {
	return (*TpmsAlgorithmDetailEcc)(ref)
}

// NewTpmsAlgorithmDetailEcc allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsAlgorithmDetailEcc() *TpmsAlgorithmDetailEcc {
	return (*TpmsAlgorithmDetailEcc)(allocTpmsAlgorithmDetailEccMemory(1))
}

// allocTpmsAlgorithmDetailEccMemory allocates memory for type C.TPMS_ALGORITHM_DETAIL_ECC in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsAlgorithmDetailEccMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsAlgorithmDetailEccValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsAlgorithmDetailEccValue = unsafe.Sizeof([1]C.TPMS_ALGORITHM_DETAIL_ECC{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsAlgorithmDetailEcc) PassRef() *C.TPMS_ALGORITHM_DETAIL_ECC {
	if x == nil {
		x = (*TpmsAlgorithmDetailEcc)(allocTpmsAlgorithmDetailEccMemory(1))
	}
	return (*C.TPMS_ALGORITHM_DETAIL_ECC)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSignatureRsa) Ref() *C.TPMS_SIGNATURE_RSA {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SIGNATURE_RSA)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSignatureRsa) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSignatureRsaRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSignatureRsaRef(ref unsafe.Pointer) *TpmsSignatureRsa {
	return (*TpmsSignatureRsa)(ref)
}

// NewTpmsSignatureRsa allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSignatureRsa() *TpmsSignatureRsa {
	return (*TpmsSignatureRsa)(allocTpmsSignatureRsaMemory(1))
}

// allocTpmsSignatureRsaMemory allocates memory for type C.TPMS_SIGNATURE_RSA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsSignatureRsaMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsSignatureRsaValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsSignatureRsaValue = unsafe.Sizeof([1]C.TPMS_SIGNATURE_RSA{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSignatureRsa) PassRef() *C.TPMS_SIGNATURE_RSA {
	if x == nil {
		x = (*TpmsSignatureRsa)(allocTpmsSignatureRsaMemory(1))
	}
	return (*C.TPMS_SIGNATURE_RSA)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSignatureRsassa) Ref() *C.TPMS_SIGNATURE_RSA {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SIGNATURE_RSA)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSignatureRsassa) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSignatureRsassaRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSignatureRsassaRef(ref unsafe.Pointer) *TpmsSignatureRsassa {
	return (*TpmsSignatureRsassa)(ref)
}

// NewTpmsSignatureRsassa allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSignatureRsassa() *TpmsSignatureRsassa {
	return (*TpmsSignatureRsassa)(allocTpmsSignatureRsaMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSignatureRsassa) PassRef() *C.TPMS_SIGNATURE_RSA {
	if x == nil {
		x = (*TpmsSignatureRsassa)(allocTpmsSignatureRsaMemory(1))
	}
	return (*C.TPMS_SIGNATURE_RSA)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSignatureRsapss) Ref() *C.TPMS_SIGNATURE_RSA {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SIGNATURE_RSA)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSignatureRsapss) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSignatureRsapssRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSignatureRsapssRef(ref unsafe.Pointer) *TpmsSignatureRsapss {
	return (*TpmsSignatureRsapss)(ref)
}

// NewTpmsSignatureRsapss allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSignatureRsapss() *TpmsSignatureRsapss {
	return (*TpmsSignatureRsapss)(allocTpmsSignatureRsaMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSignatureRsapss) PassRef() *C.TPMS_SIGNATURE_RSA {
	if x == nil {
		x = (*TpmsSignatureRsapss)(allocTpmsSignatureRsaMemory(1))
	}
	return (*C.TPMS_SIGNATURE_RSA)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSignatureEcc) Ref() *C.TPMS_SIGNATURE_ECC {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SIGNATURE_ECC)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSignatureEcc) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSignatureEccRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSignatureEccRef(ref unsafe.Pointer) *TpmsSignatureEcc {
	return (*TpmsSignatureEcc)(ref)
}

// NewTpmsSignatureEcc allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSignatureEcc() *TpmsSignatureEcc {
	return (*TpmsSignatureEcc)(allocTpmsSignatureEccMemory(1))
}

// allocTpmsSignatureEccMemory allocates memory for type C.TPMS_SIGNATURE_ECC in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsSignatureEccMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsSignatureEccValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsSignatureEccValue = unsafe.Sizeof([1]C.TPMS_SIGNATURE_ECC{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSignatureEcc) PassRef() *C.TPMS_SIGNATURE_ECC {
	if x == nil {
		x = (*TpmsSignatureEcc)(allocTpmsSignatureEccMemory(1))
	}
	return (*C.TPMS_SIGNATURE_ECC)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSignatureEcdsa) Ref() *C.TPMS_SIGNATURE_ECC {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SIGNATURE_ECC)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSignatureEcdsa) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSignatureEcdsaRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSignatureEcdsaRef(ref unsafe.Pointer) *TpmsSignatureEcdsa {
	return (*TpmsSignatureEcdsa)(ref)
}

// NewTpmsSignatureEcdsa allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSignatureEcdsa() *TpmsSignatureEcdsa {
	return (*TpmsSignatureEcdsa)(allocTpmsSignatureEccMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSignatureEcdsa) PassRef() *C.TPMS_SIGNATURE_ECC {
	if x == nil {
		x = (*TpmsSignatureEcdsa)(allocTpmsSignatureEccMemory(1))
	}
	return (*C.TPMS_SIGNATURE_ECC)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSignatureEcdaa) Ref() *C.TPMS_SIGNATURE_ECC {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SIGNATURE_ECC)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSignatureEcdaa) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSignatureEcdaaRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSignatureEcdaaRef(ref unsafe.Pointer) *TpmsSignatureEcdaa {
	return (*TpmsSignatureEcdaa)(ref)
}

// NewTpmsSignatureEcdaa allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSignatureEcdaa() *TpmsSignatureEcdaa {
	return (*TpmsSignatureEcdaa)(allocTpmsSignatureEccMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSignatureEcdaa) PassRef() *C.TPMS_SIGNATURE_ECC {
	if x == nil {
		x = (*TpmsSignatureEcdaa)(allocTpmsSignatureEccMemory(1))
	}
	return (*C.TPMS_SIGNATURE_ECC)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSignatureSm2) Ref() *C.TPMS_SIGNATURE_ECC {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SIGNATURE_ECC)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSignatureSm2) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSignatureSm2Ref converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSignatureSm2Ref(ref unsafe.Pointer) *TpmsSignatureSm2 {
	return (*TpmsSignatureSm2)(ref)
}

// NewTpmsSignatureSm2 allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSignatureSm2() *TpmsSignatureSm2 {
	return (*TpmsSignatureSm2)(allocTpmsSignatureEccMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSignatureSm2) PassRef() *C.TPMS_SIGNATURE_ECC {
	if x == nil {
		x = (*TpmsSignatureSm2)(allocTpmsSignatureEccMemory(1))
	}
	return (*C.TPMS_SIGNATURE_ECC)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsSignatureEcschnorr) Ref() *C.TPMS_SIGNATURE_ECC {
	if x == nil {
		return nil
	}
	return (*C.TPMS_SIGNATURE_ECC)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsSignatureEcschnorr) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsSignatureEcschnorrRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsSignatureEcschnorrRef(ref unsafe.Pointer) *TpmsSignatureEcschnorr {
	return (*TpmsSignatureEcschnorr)(ref)
}

// NewTpmsSignatureEcschnorr allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsSignatureEcschnorr() *TpmsSignatureEcschnorr {
	return (*TpmsSignatureEcschnorr)(allocTpmsSignatureEccMemory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsSignatureEcschnorr) PassRef() *C.TPMS_SIGNATURE_ECC {
	if x == nil {
		x = (*TpmsSignatureEcschnorr)(allocTpmsSignatureEccMemory(1))
	}
	return (*C.TPMS_SIGNATURE_ECC)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmtSignature) Ref() *C.TPMT_SIGNATURE {
	if x == nil {
		return nil
	}
	return (*C.TPMT_SIGNATURE)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmtSignature) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmtSignatureRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmtSignatureRef(ref unsafe.Pointer) *TpmtSignature {
	return (*TpmtSignature)(ref)
}

// NewTpmtSignature allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmtSignature() *TpmtSignature {
	return (*TpmtSignature)(allocTpmtSignatureMemory(1))
}

// allocTpmtSignatureMemory allocates memory for type C.TPMT_SIGNATURE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtSignatureMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtSignatureValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtSignatureValue = unsafe.Sizeof([1]C.TPMT_SIGNATURE{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmtSignature) PassRef() *C.TPMT_SIGNATURE {
	if x == nil {
		x = (*TpmtSignature)(allocTpmtSignatureMemory(1))
	}
	return (*C.TPMT_SIGNATURE)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bEncryptedSecret) Ref() *C.TPM2B_ENCRYPTED_SECRET {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_ENCRYPTED_SECRET)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bEncryptedSecret) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bEncryptedSecretRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bEncryptedSecretRef(ref unsafe.Pointer) *Tpm2bEncryptedSecret {
	return (*Tpm2bEncryptedSecret)(ref)
}

// NewTpm2bEncryptedSecret allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bEncryptedSecret() *Tpm2bEncryptedSecret {
	return (*Tpm2bEncryptedSecret)(allocTpm2bEncryptedSecretMemory(1))
}

// allocTpm2bEncryptedSecretMemory allocates memory for type C.TPM2B_ENCRYPTED_SECRET in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bEncryptedSecretMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bEncryptedSecretValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bEncryptedSecretValue = unsafe.Sizeof([1]C.TPM2B_ENCRYPTED_SECRET{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bEncryptedSecret) PassRef() *C.TPM2B_ENCRYPTED_SECRET {
	if x == nil {
		x = (*Tpm2bEncryptedSecret)(allocTpm2bEncryptedSecretMemory(1))
	}
	return (*C.TPM2B_ENCRYPTED_SECRET)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsKeyedhashParms) Ref() *C.TPMS_KEYEDHASH_PARMS {
	if x == nil {
		return nil
	}
	return (*C.TPMS_KEYEDHASH_PARMS)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsKeyedhashParms) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsKeyedhashParmsRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsKeyedhashParmsRef(ref unsafe.Pointer) *TpmsKeyedhashParms {
	return (*TpmsKeyedhashParms)(ref)
}

// NewTpmsKeyedhashParms allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsKeyedhashParms() *TpmsKeyedhashParms {
	return (*TpmsKeyedhashParms)(allocTpmsKeyedhashParmsMemory(1))
}

// allocTpmsKeyedhashParmsMemory allocates memory for type C.TPMS_KEYEDHASH_PARMS in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsKeyedhashParmsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsKeyedhashParmsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsKeyedhashParmsValue = unsafe.Sizeof([1]C.TPMS_KEYEDHASH_PARMS{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsKeyedhashParms) PassRef() *C.TPMS_KEYEDHASH_PARMS {
	if x == nil {
		x = (*TpmsKeyedhashParms)(allocTpmsKeyedhashParmsMemory(1))
	}
	return (*C.TPMS_KEYEDHASH_PARMS)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsAsymParms) Ref() *C.TPMS_ASYM_PARMS {
	if x == nil {
		return nil
	}
	return (*C.TPMS_ASYM_PARMS)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsAsymParms) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsAsymParmsRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsAsymParmsRef(ref unsafe.Pointer) *TpmsAsymParms {
	return (*TpmsAsymParms)(ref)
}

// NewTpmsAsymParms allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsAsymParms() *TpmsAsymParms {
	return (*TpmsAsymParms)(allocTpmsAsymParmsMemory(1))
}

// allocTpmsAsymParmsMemory allocates memory for type C.TPMS_ASYM_PARMS in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsAsymParmsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsAsymParmsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsAsymParmsValue = unsafe.Sizeof([1]C.TPMS_ASYM_PARMS{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsAsymParms) PassRef() *C.TPMS_ASYM_PARMS {
	if x == nil {
		x = (*TpmsAsymParms)(allocTpmsAsymParmsMemory(1))
	}
	return (*C.TPMS_ASYM_PARMS)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsRsaParms) Ref() *C.TPMS_RSA_PARMS {
	if x == nil {
		return nil
	}
	return (*C.TPMS_RSA_PARMS)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsRsaParms) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsRsaParmsRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsRsaParmsRef(ref unsafe.Pointer) *TpmsRsaParms {
	return (*TpmsRsaParms)(ref)
}

// NewTpmsRsaParms allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsRsaParms() *TpmsRsaParms {
	return (*TpmsRsaParms)(allocTpmsRsaParmsMemory(1))
}

// allocTpmsRsaParmsMemory allocates memory for type C.TPMS_RSA_PARMS in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsRsaParmsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsRsaParmsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsRsaParmsValue = unsafe.Sizeof([1]C.TPMS_RSA_PARMS{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsRsaParms) PassRef() *C.TPMS_RSA_PARMS {
	if x == nil {
		x = (*TpmsRsaParms)(allocTpmsRsaParmsMemory(1))
	}
	return (*C.TPMS_RSA_PARMS)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsEccParms) Ref() *C.TPMS_ECC_PARMS {
	if x == nil {
		return nil
	}
	return (*C.TPMS_ECC_PARMS)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsEccParms) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsEccParmsRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsEccParmsRef(ref unsafe.Pointer) *TpmsEccParms {
	return (*TpmsEccParms)(ref)
}

// NewTpmsEccParms allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsEccParms() *TpmsEccParms {
	return (*TpmsEccParms)(allocTpmsEccParmsMemory(1))
}

// allocTpmsEccParmsMemory allocates memory for type C.TPMS_ECC_PARMS in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsEccParmsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsEccParmsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsEccParmsValue = unsafe.Sizeof([1]C.TPMS_ECC_PARMS{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsEccParms) PassRef() *C.TPMS_ECC_PARMS {
	if x == nil {
		x = (*TpmsEccParms)(allocTpmsEccParmsMemory(1))
	}
	return (*C.TPMS_ECC_PARMS)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmtPublicParms) Ref() *C.TPMT_PUBLIC_PARMS {
	if x == nil {
		return nil
	}
	return (*C.TPMT_PUBLIC_PARMS)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmtPublicParms) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmtPublicParmsRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmtPublicParmsRef(ref unsafe.Pointer) *TpmtPublicParms {
	return (*TpmtPublicParms)(ref)
}

// NewTpmtPublicParms allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmtPublicParms() *TpmtPublicParms {
	return (*TpmtPublicParms)(allocTpmtPublicParmsMemory(1))
}

// allocTpmtPublicParmsMemory allocates memory for type C.TPMT_PUBLIC_PARMS in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtPublicParmsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtPublicParmsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtPublicParmsValue = unsafe.Sizeof([1]C.TPMT_PUBLIC_PARMS{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmtPublicParms) PassRef() *C.TPMT_PUBLIC_PARMS {
	if x == nil {
		x = (*TpmtPublicParms)(allocTpmtPublicParmsMemory(1))
	}
	return (*C.TPMT_PUBLIC_PARMS)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmtPublic) Ref() *C.TPMT_PUBLIC {
	if x == nil {
		return nil
	}
	return (*C.TPMT_PUBLIC)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmtPublic) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmtPublicRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmtPublicRef(ref unsafe.Pointer) *TpmtPublic {
	return (*TpmtPublic)(ref)
}

// NewTpmtPublic allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmtPublic() *TpmtPublic {
	return (*TpmtPublic)(allocTpmtPublicMemory(1))
}

// allocTpmtPublicMemory allocates memory for type C.TPMT_PUBLIC in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtPublicMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtPublicValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtPublicValue = unsafe.Sizeof([1]C.TPMT_PUBLIC{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmtPublic) PassRef() *C.TPMT_PUBLIC {
	if x == nil {
		x = (*TpmtPublic)(allocTpmtPublicMemory(1))
	}
	return (*C.TPMT_PUBLIC)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bPublic) Ref() *C.TPM2B_PUBLIC {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_PUBLIC)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bPublic) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bPublicRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bPublicRef(ref unsafe.Pointer) *Tpm2bPublic {
	return (*Tpm2bPublic)(ref)
}

// NewTpm2bPublic allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bPublic() *Tpm2bPublic {
	return (*Tpm2bPublic)(allocTpm2bPublicMemory(1))
}

// allocTpm2bPublicMemory allocates memory for type C.TPM2B_PUBLIC in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bPublicMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bPublicValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bPublicValue = unsafe.Sizeof([1]C.TPM2B_PUBLIC{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bPublic) PassRef() *C.TPM2B_PUBLIC {
	if x == nil {
		x = (*Tpm2bPublic)(allocTpm2bPublicMemory(1))
	}
	return (*C.TPM2B_PUBLIC)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bTemplate) Ref() *C.TPM2B_TEMPLATE {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_TEMPLATE)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bTemplate) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bTemplateRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bTemplateRef(ref unsafe.Pointer) *Tpm2bTemplate {
	return (*Tpm2bTemplate)(ref)
}

// NewTpm2bTemplate allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bTemplate() *Tpm2bTemplate {
	return (*Tpm2bTemplate)(allocTpm2bTemplateMemory(1))
}

// allocTpm2bTemplateMemory allocates memory for type C.TPM2B_TEMPLATE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bTemplateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bTemplateValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bTemplateValue = unsafe.Sizeof([1]C.TPM2B_TEMPLATE{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bTemplate) PassRef() *C.TPM2B_TEMPLATE {
	if x == nil {
		x = (*Tpm2bTemplate)(allocTpm2bTemplateMemory(1))
	}
	return (*C.TPM2B_TEMPLATE)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bPrivateVendorSpecific) Ref() *C.TPM2B_PRIVATE_VENDOR_SPECIFIC {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_PRIVATE_VENDOR_SPECIFIC)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bPrivateVendorSpecific) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bPrivateVendorSpecificRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bPrivateVendorSpecificRef(ref unsafe.Pointer) *Tpm2bPrivateVendorSpecific {
	return (*Tpm2bPrivateVendorSpecific)(ref)
}

// NewTpm2bPrivateVendorSpecific allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bPrivateVendorSpecific() *Tpm2bPrivateVendorSpecific {
	return (*Tpm2bPrivateVendorSpecific)(allocTpm2bPrivateVendorSpecificMemory(1))
}

// allocTpm2bPrivateVendorSpecificMemory allocates memory for type C.TPM2B_PRIVATE_VENDOR_SPECIFIC in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bPrivateVendorSpecificMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bPrivateVendorSpecificValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bPrivateVendorSpecificValue = unsafe.Sizeof([1]C.TPM2B_PRIVATE_VENDOR_SPECIFIC{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bPrivateVendorSpecific) PassRef() *C.TPM2B_PRIVATE_VENDOR_SPECIFIC {
	if x == nil {
		x = (*Tpm2bPrivateVendorSpecific)(allocTpm2bPrivateVendorSpecificMemory(1))
	}
	return (*C.TPM2B_PRIVATE_VENDOR_SPECIFIC)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmtSensitive) Ref() *C.TPMT_SENSITIVE {
	if x == nil {
		return nil
	}
	return (*C.TPMT_SENSITIVE)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmtSensitive) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmtSensitiveRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmtSensitiveRef(ref unsafe.Pointer) *TpmtSensitive {
	return (*TpmtSensitive)(ref)
}

// NewTpmtSensitive allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmtSensitive() *TpmtSensitive {
	return (*TpmtSensitive)(allocTpmtSensitiveMemory(1))
}

// allocTpmtSensitiveMemory allocates memory for type C.TPMT_SENSITIVE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtSensitiveMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtSensitiveValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtSensitiveValue = unsafe.Sizeof([1]C.TPMT_SENSITIVE{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmtSensitive) PassRef() *C.TPMT_SENSITIVE {
	if x == nil {
		x = (*TpmtSensitive)(allocTpmtSensitiveMemory(1))
	}
	return (*C.TPMT_SENSITIVE)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bSensitive) Ref() *C.TPM2B_SENSITIVE {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_SENSITIVE)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bSensitive) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bSensitiveRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bSensitiveRef(ref unsafe.Pointer) *Tpm2bSensitive {
	return (*Tpm2bSensitive)(ref)
}

// NewTpm2bSensitive allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bSensitive() *Tpm2bSensitive {
	return (*Tpm2bSensitive)(allocTpm2bSensitiveMemory(1))
}

// allocTpm2bSensitiveMemory allocates memory for type C.TPM2B_SENSITIVE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bSensitiveMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bSensitiveValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bSensitiveValue = unsafe.Sizeof([1]C.TPM2B_SENSITIVE{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bSensitive) PassRef() *C.TPM2B_SENSITIVE {
	if x == nil {
		x = (*Tpm2bSensitive)(allocTpm2bSensitiveMemory(1))
	}
	return (*C.TPM2B_SENSITIVE)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Private) Ref() *C._PRIVATE {
	if x == nil {
		return nil
	}
	return (*C._PRIVATE)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Private) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPrivateRef converts the C object reference into a raw struct reference without wrapping.
func NewPrivateRef(ref unsafe.Pointer) *Private {
	return (*Private)(ref)
}

// NewPrivate allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPrivate() *Private {
	return (*Private)(allocPrivateMemory(1))
}

// allocPrivateMemory allocates memory for type C._PRIVATE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPrivateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPrivateValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPrivateValue = unsafe.Sizeof([1]C._PRIVATE{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Private) PassRef() *C._PRIVATE {
	if x == nil {
		x = (*Private)(allocPrivateMemory(1))
	}
	return (*C._PRIVATE)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bPrivate) Ref() *C.TPM2B_PRIVATE {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_PRIVATE)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bPrivate) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bPrivateRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bPrivateRef(ref unsafe.Pointer) *Tpm2bPrivate {
	return (*Tpm2bPrivate)(ref)
}

// NewTpm2bPrivate allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bPrivate() *Tpm2bPrivate {
	return (*Tpm2bPrivate)(allocTpm2bPrivateMemory(1))
}

// allocTpm2bPrivateMemory allocates memory for type C.TPM2B_PRIVATE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bPrivateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bPrivateValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bPrivateValue = unsafe.Sizeof([1]C.TPM2B_PRIVATE{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bPrivate) PassRef() *C.TPM2B_PRIVATE {
	if x == nil {
		x = (*Tpm2bPrivate)(allocTpm2bPrivateMemory(1))
	}
	return (*C.TPM2B_PRIVATE)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsIdObject) Ref() *C.TPMS_ID_OBJECT {
	if x == nil {
		return nil
	}
	return (*C.TPMS_ID_OBJECT)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsIdObject) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsIdObjectRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsIdObjectRef(ref unsafe.Pointer) *TpmsIdObject {
	return (*TpmsIdObject)(ref)
}

// NewTpmsIdObject allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsIdObject() *TpmsIdObject {
	return (*TpmsIdObject)(allocTpmsIdObjectMemory(1))
}

// allocTpmsIdObjectMemory allocates memory for type C.TPMS_ID_OBJECT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsIdObjectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsIdObjectValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsIdObjectValue = unsafe.Sizeof([1]C.TPMS_ID_OBJECT{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsIdObject) PassRef() *C.TPMS_ID_OBJECT {
	if x == nil {
		x = (*TpmsIdObject)(allocTpmsIdObjectMemory(1))
	}
	return (*C.TPMS_ID_OBJECT)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bIdObject) Ref() *C.TPM2B_ID_OBJECT {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_ID_OBJECT)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bIdObject) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bIdObjectRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bIdObjectRef(ref unsafe.Pointer) *Tpm2bIdObject {
	return (*Tpm2bIdObject)(ref)
}

// NewTpm2bIdObject allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bIdObject() *Tpm2bIdObject {
	return (*Tpm2bIdObject)(allocTpm2bIdObjectMemory(1))
}

// allocTpm2bIdObjectMemory allocates memory for type C.TPM2B_ID_OBJECT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bIdObjectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bIdObjectValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bIdObjectValue = unsafe.Sizeof([1]C.TPM2B_ID_OBJECT{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bIdObject) PassRef() *C.TPM2B_ID_OBJECT {
	if x == nil {
		x = (*Tpm2bIdObject)(allocTpm2bIdObjectMemory(1))
	}
	return (*C.TPM2B_ID_OBJECT)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsNvPinCounterParameters) Ref() *C.TPMS_NV_PIN_COUNTER_PARAMETERS {
	if x == nil {
		return nil
	}
	return (*C.TPMS_NV_PIN_COUNTER_PARAMETERS)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsNvPinCounterParameters) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsNvPinCounterParametersRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsNvPinCounterParametersRef(ref unsafe.Pointer) *TpmsNvPinCounterParameters {
	return (*TpmsNvPinCounterParameters)(ref)
}

// NewTpmsNvPinCounterParameters allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsNvPinCounterParameters() *TpmsNvPinCounterParameters {
	return (*TpmsNvPinCounterParameters)(allocTpmsNvPinCounterParametersMemory(1))
}

// allocTpmsNvPinCounterParametersMemory allocates memory for type C.TPMS_NV_PIN_COUNTER_PARAMETERS in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsNvPinCounterParametersMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsNvPinCounterParametersValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsNvPinCounterParametersValue = unsafe.Sizeof([1]C.TPMS_NV_PIN_COUNTER_PARAMETERS{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsNvPinCounterParameters) PassRef() *C.TPMS_NV_PIN_COUNTER_PARAMETERS {
	if x == nil {
		x = (*TpmsNvPinCounterParameters)(allocTpmsNvPinCounterParametersMemory(1))
	}
	return (*C.TPMS_NV_PIN_COUNTER_PARAMETERS)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsNvPublic) Ref() *C.TPMS_NV_PUBLIC {
	if x == nil {
		return nil
	}
	return (*C.TPMS_NV_PUBLIC)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsNvPublic) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsNvPublicRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsNvPublicRef(ref unsafe.Pointer) *TpmsNvPublic {
	return (*TpmsNvPublic)(ref)
}

// NewTpmsNvPublic allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsNvPublic() *TpmsNvPublic {
	return (*TpmsNvPublic)(allocTpmsNvPublicMemory(1))
}

// allocTpmsNvPublicMemory allocates memory for type C.TPMS_NV_PUBLIC in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsNvPublicMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsNvPublicValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsNvPublicValue = unsafe.Sizeof([1]C.TPMS_NV_PUBLIC{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsNvPublic) PassRef() *C.TPMS_NV_PUBLIC {
	if x == nil {
		x = (*TpmsNvPublic)(allocTpmsNvPublicMemory(1))
	}
	return (*C.TPMS_NV_PUBLIC)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bNvPublic) Ref() *C.TPM2B_NV_PUBLIC {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_NV_PUBLIC)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bNvPublic) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bNvPublicRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bNvPublicRef(ref unsafe.Pointer) *Tpm2bNvPublic {
	return (*Tpm2bNvPublic)(ref)
}

// NewTpm2bNvPublic allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bNvPublic() *Tpm2bNvPublic {
	return (*Tpm2bNvPublic)(allocTpm2bNvPublicMemory(1))
}

// allocTpm2bNvPublicMemory allocates memory for type C.TPM2B_NV_PUBLIC in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bNvPublicMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bNvPublicValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bNvPublicValue = unsafe.Sizeof([1]C.TPM2B_NV_PUBLIC{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bNvPublic) PassRef() *C.TPM2B_NV_PUBLIC {
	if x == nil {
		x = (*Tpm2bNvPublic)(allocTpm2bNvPublicMemory(1))
	}
	return (*C.TPM2B_NV_PUBLIC)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bContextSensitive) Ref() *C.TPM2B_CONTEXT_SENSITIVE {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_CONTEXT_SENSITIVE)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bContextSensitive) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bContextSensitiveRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bContextSensitiveRef(ref unsafe.Pointer) *Tpm2bContextSensitive {
	return (*Tpm2bContextSensitive)(ref)
}

// NewTpm2bContextSensitive allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bContextSensitive() *Tpm2bContextSensitive {
	return (*Tpm2bContextSensitive)(allocTpm2bContextSensitiveMemory(1))
}

// allocTpm2bContextSensitiveMemory allocates memory for type C.TPM2B_CONTEXT_SENSITIVE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bContextSensitiveMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bContextSensitiveValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bContextSensitiveValue = unsafe.Sizeof([1]C.TPM2B_CONTEXT_SENSITIVE{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bContextSensitive) PassRef() *C.TPM2B_CONTEXT_SENSITIVE {
	if x == nil {
		x = (*Tpm2bContextSensitive)(allocTpm2bContextSensitiveMemory(1))
	}
	return (*C.TPM2B_CONTEXT_SENSITIVE)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsContextData) Ref() *C.TPMS_CONTEXT_DATA {
	if x == nil {
		return nil
	}
	return (*C.TPMS_CONTEXT_DATA)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsContextData) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsContextDataRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsContextDataRef(ref unsafe.Pointer) *TpmsContextData {
	return (*TpmsContextData)(ref)
}

// NewTpmsContextData allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsContextData() *TpmsContextData {
	return (*TpmsContextData)(allocTpmsContextDataMemory(1))
}

// allocTpmsContextDataMemory allocates memory for type C.TPMS_CONTEXT_DATA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsContextDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsContextDataValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsContextDataValue = unsafe.Sizeof([1]C.TPMS_CONTEXT_DATA{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsContextData) PassRef() *C.TPMS_CONTEXT_DATA {
	if x == nil {
		x = (*TpmsContextData)(allocTpmsContextDataMemory(1))
	}
	return (*C.TPMS_CONTEXT_DATA)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bContextData) Ref() *C.TPM2B_CONTEXT_DATA {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_CONTEXT_DATA)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bContextData) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bContextDataRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bContextDataRef(ref unsafe.Pointer) *Tpm2bContextData {
	return (*Tpm2bContextData)(ref)
}

// NewTpm2bContextData allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bContextData() *Tpm2bContextData {
	return (*Tpm2bContextData)(allocTpm2bContextDataMemory(1))
}

// allocTpm2bContextDataMemory allocates memory for type C.TPM2B_CONTEXT_DATA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bContextDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bContextDataValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bContextDataValue = unsafe.Sizeof([1]C.TPM2B_CONTEXT_DATA{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bContextData) PassRef() *C.TPM2B_CONTEXT_DATA {
	if x == nil {
		x = (*Tpm2bContextData)(allocTpm2bContextDataMemory(1))
	}
	return (*C.TPM2B_CONTEXT_DATA)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsContext) Ref() *C.TPMS_CONTEXT {
	if x == nil {
		return nil
	}
	return (*C.TPMS_CONTEXT)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsContext) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsContextRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsContextRef(ref unsafe.Pointer) *TpmsContext {
	return (*TpmsContext)(ref)
}

// NewTpmsContext allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsContext() *TpmsContext {
	return (*TpmsContext)(allocTpmsContextMemory(1))
}

// allocTpmsContextMemory allocates memory for type C.TPMS_CONTEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsContextValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsContextValue = unsafe.Sizeof([1]C.TPMS_CONTEXT{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsContext) PassRef() *C.TPMS_CONTEXT {
	if x == nil {
		x = (*TpmsContext)(allocTpmsContextMemory(1))
	}
	return (*C.TPMS_CONTEXT)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsCreationData) Ref() *C.TPMS_CREATION_DATA {
	if x == nil {
		return nil
	}
	return (*C.TPMS_CREATION_DATA)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsCreationData) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsCreationDataRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsCreationDataRef(ref unsafe.Pointer) *TpmsCreationData {
	return (*TpmsCreationData)(ref)
}

// NewTpmsCreationData allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsCreationData() *TpmsCreationData {
	return (*TpmsCreationData)(allocTpmsCreationDataMemory(1))
}

// allocTpmsCreationDataMemory allocates memory for type C.TPMS_CREATION_DATA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsCreationDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsCreationDataValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsCreationDataValue = unsafe.Sizeof([1]C.TPMS_CREATION_DATA{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsCreationData) PassRef() *C.TPMS_CREATION_DATA {
	if x == nil {
		x = (*TpmsCreationData)(allocTpmsCreationDataMemory(1))
	}
	return (*C.TPMS_CREATION_DATA)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tpm2bCreationData) Ref() *C.TPM2B_CREATION_DATA {
	if x == nil {
		return nil
	}
	return (*C.TPM2B_CREATION_DATA)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tpm2bCreationData) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpm2bCreationDataRef converts the C object reference into a raw struct reference without wrapping.
func NewTpm2bCreationDataRef(ref unsafe.Pointer) *Tpm2bCreationData {
	return (*Tpm2bCreationData)(ref)
}

// NewTpm2bCreationData allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpm2bCreationData() *Tpm2bCreationData {
	return (*Tpm2bCreationData)(allocTpm2bCreationDataMemory(1))
}

// allocTpm2bCreationDataMemory allocates memory for type C.TPM2B_CREATION_DATA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bCreationDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bCreationDataValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bCreationDataValue = unsafe.Sizeof([1]C.TPM2B_CREATION_DATA{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tpm2bCreationData) PassRef() *C.TPM2B_CREATION_DATA {
	if x == nil {
		x = (*Tpm2bCreationData)(allocTpm2bCreationDataMemory(1))
	}
	return (*C.TPM2B_CREATION_DATA)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmsAcOutput) Ref() *C.TPMS_AC_OUTPUT {
	if x == nil {
		return nil
	}
	return (*C.TPMS_AC_OUTPUT)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmsAcOutput) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmsAcOutputRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmsAcOutputRef(ref unsafe.Pointer) *TpmsAcOutput {
	return (*TpmsAcOutput)(ref)
}

// NewTpmsAcOutput allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmsAcOutput() *TpmsAcOutput {
	return (*TpmsAcOutput)(allocTpmsAcOutputMemory(1))
}

// allocTpmsAcOutputMemory allocates memory for type C.TPMS_AC_OUTPUT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsAcOutputMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsAcOutputValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsAcOutputValue = unsafe.Sizeof([1]C.TPMS_AC_OUTPUT{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmsAcOutput) PassRef() *C.TPMS_AC_OUTPUT {
	if x == nil {
		x = (*TpmsAcOutput)(allocTpmsAcOutputMemory(1))
	}
	return (*C.TPMS_AC_OUTPUT)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TpmlAcCapabilities) Ref() *C.TPML_AC_CAPABILITIES {
	if x == nil {
		return nil
	}
	return (*C.TPML_AC_CAPABILITIES)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TpmlAcCapabilities) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTpmlAcCapabilitiesRef converts the C object reference into a raw struct reference without wrapping.
func NewTpmlAcCapabilitiesRef(ref unsafe.Pointer) *TpmlAcCapabilities {
	return (*TpmlAcCapabilities)(ref)
}

// NewTpmlAcCapabilities allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTpmlAcCapabilities() *TpmlAcCapabilities {
	return (*TpmlAcCapabilities)(allocTpmlAcCapabilitiesMemory(1))
}

// allocTpmlAcCapabilitiesMemory allocates memory for type C.TPML_AC_CAPABILITIES in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmlAcCapabilitiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmlAcCapabilitiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmlAcCapabilitiesValue = unsafe.Sizeof([1]C.TPML_AC_CAPABILITIES{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TpmlAcCapabilities) PassRef() *C.TPML_AC_CAPABILITIES {
	if x == nil {
		x = (*TpmlAcCapabilities)(allocTpmlAcCapabilitiesMemory(1))
	}
	return (*C.TPML_AC_CAPABILITIES)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tss2SysContext) Ref() *C.TSS2_SYS_CONTEXT {
	if x == nil {
		return nil
	}
	return (*C.TSS2_SYS_CONTEXT)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tss2SysContext) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTss2SysContextRef converts the C object reference into a raw struct reference without wrapping.
func NewTss2SysContextRef(ref unsafe.Pointer) *Tss2SysContext {
	return (*Tss2SysContext)(ref)
}

// NewTss2SysContext allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTss2SysContext() *Tss2SysContext {
	return (*Tss2SysContext)(allocTss2SysContextMemory(1))
}

// allocTss2SysContextMemory allocates memory for type C.TSS2_SYS_CONTEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTss2SysContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTss2SysContextValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTss2SysContextValue = unsafe.Sizeof([1]C.TSS2_SYS_CONTEXT{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tss2SysContext) PassRef() *C.TSS2_SYS_CONTEXT {
	if x == nil {
		x = (*Tss2SysContext)(allocTss2SysContextMemory(1))
	}
	return (*C.TSS2_SYS_CONTEXT)(unsafe.Pointer(x))
}

// allocTss2lSysAuthCommandMemory allocates memory for type C.TSS2L_SYS_AUTH_COMMAND in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTss2lSysAuthCommandMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTss2lSysAuthCommandValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTss2lSysAuthCommandValue = unsafe.Sizeof([1]C.TSS2L_SYS_AUTH_COMMAND{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Tss2lSysAuthCommand) Ref() *C.TSS2L_SYS_AUTH_COMMAND {
	if x == nil {
		return nil
	}
	return x.reff9bbf97f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Tss2lSysAuthCommand) Free() {
	if x != nil && x.allocsf9bbf97f != nil {
		x.allocsf9bbf97f.(*cgoAllocMap).Free()
		x.reff9bbf97f = nil
	}
}

// NewTss2lSysAuthCommandRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTss2lSysAuthCommandRef(ref unsafe.Pointer) *Tss2lSysAuthCommand {
	if ref == nil {
		return nil
	}
	obj := new(Tss2lSysAuthCommand)
	obj.reff9bbf97f = (*C.TSS2L_SYS_AUTH_COMMAND)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Tss2lSysAuthCommand) PassRef() (*C.TSS2L_SYS_AUTH_COMMAND, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff9bbf97f != nil {
		return x.reff9bbf97f, nil
	}
	memf9bbf97f := allocTss2lSysAuthCommandMemory(1)
	reff9bbf97f := (*C.TSS2L_SYS_AUTH_COMMAND)(memf9bbf97f)
	allocsf9bbf97f := new(cgoAllocMap)
	allocsf9bbf97f.Add(memf9bbf97f)

	var ccount_allocs *cgoAllocMap
	reff9bbf97f.count, ccount_allocs = (C.uint16_t)(x.Count), cgoAllocsUnknown
	allocsf9bbf97f.Borrow(ccount_allocs)

	var cauths_allocs *cgoAllocMap
	reff9bbf97f.auths, cauths_allocs = *(*[3]C.TPMS_AUTH_COMMAND)(unsafe.Pointer(&x.Auths)), cgoAllocsUnknown
	allocsf9bbf97f.Borrow(cauths_allocs)

	x.reff9bbf97f = reff9bbf97f
	x.allocsf9bbf97f = allocsf9bbf97f
	return reff9bbf97f, allocsf9bbf97f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Tss2lSysAuthCommand) PassValue() (C.TSS2L_SYS_AUTH_COMMAND, *cgoAllocMap) {
	if x.reff9bbf97f != nil {
		return *x.reff9bbf97f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Tss2lSysAuthCommand) Deref() {
	if x.reff9bbf97f == nil {
		return
	}
	x.Count = (Uint16T)(x.reff9bbf97f.count)
	x.Auths = *(*[3]TpmsAuthCommand)(unsafe.Pointer(&x.reff9bbf97f.auths))
}

// allocTss2lSysAuthResponseMemory allocates memory for type C.TSS2L_SYS_AUTH_RESPONSE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTss2lSysAuthResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTss2lSysAuthResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTss2lSysAuthResponseValue = unsafe.Sizeof([1]C.TSS2L_SYS_AUTH_RESPONSE{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Tss2lSysAuthResponse) Ref() *C.TSS2L_SYS_AUTH_RESPONSE {
	if x == nil {
		return nil
	}
	return x.ref44662040
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Tss2lSysAuthResponse) Free() {
	if x != nil && x.allocs44662040 != nil {
		x.allocs44662040.(*cgoAllocMap).Free()
		x.ref44662040 = nil
	}
}

// NewTss2lSysAuthResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTss2lSysAuthResponseRef(ref unsafe.Pointer) *Tss2lSysAuthResponse {
	if ref == nil {
		return nil
	}
	obj := new(Tss2lSysAuthResponse)
	obj.ref44662040 = (*C.TSS2L_SYS_AUTH_RESPONSE)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Tss2lSysAuthResponse) PassRef() (*C.TSS2L_SYS_AUTH_RESPONSE, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref44662040 != nil {
		return x.ref44662040, nil
	}
	mem44662040 := allocTss2lSysAuthResponseMemory(1)
	ref44662040 := (*C.TSS2L_SYS_AUTH_RESPONSE)(mem44662040)
	allocs44662040 := new(cgoAllocMap)
	allocs44662040.Add(mem44662040)

	var ccount_allocs *cgoAllocMap
	ref44662040.count, ccount_allocs = (C.uint16_t)(x.Count), cgoAllocsUnknown
	allocs44662040.Borrow(ccount_allocs)

	var cauths_allocs *cgoAllocMap
	ref44662040.auths, cauths_allocs = *(*[3]C.TPMS_AUTH_RESPONSE)(unsafe.Pointer(&x.Auths)), cgoAllocsUnknown
	allocs44662040.Borrow(cauths_allocs)

	x.ref44662040 = ref44662040
	x.allocs44662040 = allocs44662040
	return ref44662040, allocs44662040

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Tss2lSysAuthResponse) PassValue() (C.TSS2L_SYS_AUTH_RESPONSE, *cgoAllocMap) {
	if x.ref44662040 != nil {
		return *x.ref44662040, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Tss2lSysAuthResponse) Deref() {
	if x.ref44662040 == nil {
		return
	}
	x.Count = (Uint16T)(x.ref44662040.count)
	x.Auths = *(*[3]TpmsAuthResponse)(unsafe.Pointer(&x.ref44662040.auths))
}

// Ref returns a reference to C object as it is.
func (x *DivT) Ref() *C.div_t {
	if x == nil {
		return nil
	}
	return (*C.div_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *DivT) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewDivTRef converts the C object reference into a raw struct reference without wrapping.
func NewDivTRef(ref unsafe.Pointer) *DivT {
	return (*DivT)(ref)
}

// NewDivT allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewDivT() *DivT {
	return (*DivT)(allocDivTMemory(1))
}

// allocDivTMemory allocates memory for type C.div_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDivTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDivTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDivTValue = unsafe.Sizeof([1]C.div_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *DivT) PassRef() *C.div_t {
	if x == nil {
		x = (*DivT)(allocDivTMemory(1))
	}
	return (*C.div_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *LdivT) Ref() *C.ldiv_t {
	if x == nil {
		return nil
	}
	return (*C.ldiv_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *LdivT) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewLdivTRef converts the C object reference into a raw struct reference without wrapping.
func NewLdivTRef(ref unsafe.Pointer) *LdivT {
	return (*LdivT)(ref)
}

// NewLdivT allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewLdivT() *LdivT {
	return (*LdivT)(allocLdivTMemory(1))
}

// allocLdivTMemory allocates memory for type C.ldiv_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocLdivTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfLdivTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfLdivTValue = unsafe.Sizeof([1]C.ldiv_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *LdivT) PassRef() *C.ldiv_t {
	if x == nil {
		x = (*LdivT)(allocLdivTMemory(1))
	}
	return (*C.ldiv_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *LldivT) Ref() *C.lldiv_t {
	if x == nil {
		return nil
	}
	return (*C.lldiv_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *LldivT) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewLldivTRef converts the C object reference into a raw struct reference without wrapping.
func NewLldivTRef(ref unsafe.Pointer) *LldivT {
	return (*LldivT)(ref)
}

// NewLldivT allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewLldivT() *LldivT {
	return (*LldivT)(allocLldivTMemory(1))
}

// allocLldivTMemory allocates memory for type C.lldiv_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocLldivTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfLldivTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfLldivTValue = unsafe.Sizeof([1]C.lldiv_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *LldivT) PassRef() *C.lldiv_t {
	if x == nil {
		x = (*LldivT)(allocLldivTMemory(1))
	}
	return (*C.lldiv_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FsidT) Ref() *C.__fsid_t {
	if x == nil {
		return nil
	}
	return (*C.__fsid_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FsidT) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFsidTRef converts the C object reference into a raw struct reference without wrapping.
func NewFsidTRef(ref unsafe.Pointer) *FsidT {
	return (*FsidT)(ref)
}

// NewFsidT allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFsidT() *FsidT {
	return (*FsidT)(alloc_FsidTMemory(1))
}

// alloc_FsidTMemory allocates memory for type C.__fsid_t in C.
// The caller is responsible for freeing the this memory via C.free.
func alloc_FsidTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOf_FsidTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOf_FsidTValue = unsafe.Sizeof([1]C.__fsid_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FsidT) PassRef() *C.__fsid_t {
	if x == nil {
		x = (*FsidT)(alloc_FsidTMemory(1))
	}
	return (*C.__fsid_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FdSet) Ref() *C.fd_set {
	if x == nil {
		return nil
	}
	return (*C.fd_set)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FdSet) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFdSetRef converts the C object reference into a raw struct reference without wrapping.
func NewFdSetRef(ref unsafe.Pointer) *FdSet {
	return (*FdSet)(ref)
}

// NewFdSet allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFdSet() *FdSet {
	return (*FdSet)(allocFdSetMemory(1))
}

// allocFdSetMemory allocates memory for type C.fd_set in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFdSetMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFdSetValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFdSetValue = unsafe.Sizeof([1]C.fd_set{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FdSet) PassRef() *C.fd_set {
	if x == nil {
		x = (*FdSet)(allocFdSetMemory(1))
	}
	return (*C.fd_set)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *SigsetT) Ref() *C.__sigset_t {
	if x == nil {
		return nil
	}
	return (*C.__sigset_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *SigsetT) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewSigsetTRef converts the C object reference into a raw struct reference without wrapping.
func NewSigsetTRef(ref unsafe.Pointer) *SigsetT {
	return (*SigsetT)(ref)
}

// NewSigsetT allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewSigsetT() *SigsetT {
	return (*SigsetT)(alloc_SigsetTMemory(1))
}

// alloc_SigsetTMemory allocates memory for type C.__sigset_t in C.
// The caller is responsible for freeing the this memory via C.free.
func alloc_SigsetTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOf_SigsetTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOf_SigsetTValue = unsafe.Sizeof([1]C.__sigset_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *SigsetT) PassRef() *C.__sigset_t {
	if x == nil {
		x = (*SigsetT)(alloc_SigsetTMemory(1))
	}
	return (*C.__sigset_t)(unsafe.Pointer(x))
}

// copyPCharBytes copies the data from Go slice as *C.char.
func copyPCharBytes(slice *sliceHeader) (*C.char, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfCharValue) * slice.Len,
		Cap:  int(sizeOfCharValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.char)(mem0), allocs
}

// allocCharMemory allocates memory for type C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCharValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCharValue = unsafe.Sizeof([1]C.char{})

func (x Tss2RcHandler) PassRef() (ref *C.TSS2_RC_HANDLER, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2RcHandlerC80E0A42Func == nil {
		tss2RcHandlerC80E0A42Func = x
	}
	return (*C.TSS2_RC_HANDLER)(C.TSS2_RC_HANDLER_c80e0a42), nil
}

func (x Tss2RcHandler) PassValue() (ref C.TSS2_RC_HANDLER, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2RcHandlerC80E0A42Func == nil {
		tss2RcHandlerC80E0A42Func = x
	}
	return (C.TSS2_RC_HANDLER)(C.TSS2_RC_HANDLER_c80e0a42), nil
}

func NewTss2RcHandlerRef(ref unsafe.Pointer) *Tss2RcHandler {
	return (*Tss2RcHandler)(ref)
}

//export tss2RcHandlerC80E0A42
func tss2RcHandlerC80E0A42(crc C.TSS2_RC) *C.char {
	if tss2RcHandlerC80E0A42Func != nil {
		rcc80e0a42 := (Tss2Rc)(crc)
		retc80e0a42 := tss2RcHandlerC80E0A42Func(rcc80e0a42)
		ret, _ := copyPCharBytes((*sliceHeader)(unsafe.Pointer(&retc80e0a42)))
		return ret
	}
	panic("callback func has not been set (race?)")
}

var tss2RcHandlerC80E0A42Func Tss2RcHandler

// Ref returns a reference to C object as it is.
func (x *ImaxdivT) Ref() *C.imaxdiv_t {
	if x == nil {
		return nil
	}
	return (*C.imaxdiv_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *ImaxdivT) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewImaxdivTRef converts the C object reference into a raw struct reference without wrapping.
func NewImaxdivTRef(ref unsafe.Pointer) *ImaxdivT {
	return (*ImaxdivT)(ref)
}

// NewImaxdivT allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewImaxdivT() *ImaxdivT {
	return (*ImaxdivT)(allocImaxdivTMemory(1))
}

// allocImaxdivTMemory allocates memory for type C.imaxdiv_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImaxdivTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImaxdivTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImaxdivTValue = unsafe.Sizeof([1]C.imaxdiv_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *ImaxdivT) PassRef() *C.imaxdiv_t {
	if x == nil {
		x = (*ImaxdivT)(allocImaxdivTMemory(1))
	}
	return (*C.imaxdiv_t)(unsafe.Pointer(x))
}

// copyPUint8TBytes copies the data from Go slice as *C.uint8_t.
func copyPUint8TBytes(slice *sliceHeader) (*C.uint8_t, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfUint8TValue) * slice.Len,
		Cap:  int(sizeOfUint8TValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.uint8_t)(mem0), allocs
}

// allocUint8TMemory allocates memory for type C.uint8_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUint8TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUint8TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUint8TValue = unsafe.Sizeof([1]C.uint8_t{})

// copyPTpmlAlgBytes copies the data from Go slice as *C.TPML_ALG.
func copyPTpmlAlgBytes(slice *sliceHeader) (*C.TPML_ALG, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmlAlgValue) * slice.Len,
		Cap:  int(sizeOfTpmlAlgValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPML_ALG)(mem0), allocs
}

// copyPTpmsAlgorithmDetailEccBytes copies the data from Go slice as *C.TPMS_ALGORITHM_DETAIL_ECC.
func copyPTpmsAlgorithmDetailEccBytes(slice *sliceHeader) (*C.TPMS_ALGORITHM_DETAIL_ECC, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsAlgorithmDetailEccValue) * slice.Len,
		Cap:  int(sizeOfTpmsAlgorithmDetailEccValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_ALGORITHM_DETAIL_ECC)(mem0), allocs
}

// copyPTpmlCcBytes copies the data from Go slice as *C.TPML_CC.
func copyPTpmlCcBytes(slice *sliceHeader) (*C.TPML_CC, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmlCcValue) * slice.Len,
		Cap:  int(sizeOfTpmlCcValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPML_CC)(mem0), allocs
}

// copyPTpmlDigestValuesBytes copies the data from Go slice as *C.TPML_DIGEST_VALUES.
func copyPTpmlDigestValuesBytes(slice *sliceHeader) (*C.TPML_DIGEST_VALUES, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmlDigestValuesValue) * slice.Len,
		Cap:  int(sizeOfTpmlDigestValuesValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPML_DIGEST_VALUES)(mem0), allocs
}

// copyPTpmsContextBytes copies the data from Go slice as *C.TPMS_CONTEXT.
func copyPTpmsContextBytes(slice *sliceHeader) (*C.TPMS_CONTEXT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsContextValue) * slice.Len,
		Cap:  int(sizeOfTpmsContextValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_CONTEXT)(mem0), allocs
}

// copyPTpm2bMaxNvBufferBytes copies the data from Go slice as *C.TPM2B_MAX_NV_BUFFER.
func copyPTpm2bMaxNvBufferBytes(slice *sliceHeader) (*C.TPM2B_MAX_NV_BUFFER, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2bMaxNvBufferValue) * slice.Len,
		Cap:  int(sizeOfTpm2bMaxNvBufferValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2B_MAX_NV_BUFFER)(mem0), allocs
}

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackArgSTss2lSysAuthCommand transforms a sliced Go data structure into plain C format.
func unpackArgSTss2lSysAuthCommand(x []Tss2lSysAuthCommand) (unpacked *C.TSS2L_SYS_AUTH_COMMAND, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTss2lSysAuthCommandMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TSS2L_SYS_AUTH_COMMAND)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TSS2L_SYS_AUTH_COMMAND)(h.Data)
	return
}

// packSTss2lSysAuthCommand reads sliced Go data structure out from plain C format.
func packSTss2lSysAuthCommand(v []Tss2lSysAuthCommand, ptr0 *C.TSS2L_SYS_AUTH_COMMAND) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTss2lSysAuthCommandValue]C.TSS2L_SYS_AUTH_COMMAND)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTss2lSysAuthCommandRef(unsafe.Pointer(&ptr1))
	}
}

// copyPTpmiShAuthSessionBytes copies the data from Go slice as *C.TPMI_SH_AUTH_SESSION.
func copyPTpmiShAuthSessionBytes(slice *sliceHeader) (*C.TPMI_SH_AUTH_SESSION, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmiShAuthSessionValue) * slice.Len,
		Cap:  int(sizeOfTpmiShAuthSessionValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMI_SH_AUTH_SESSION)(mem0), allocs
}

// allocTpmiShAuthSessionMemory allocates memory for type C.TPMI_SH_AUTH_SESSION in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmiShAuthSessionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmiShAuthSessionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmiShAuthSessionValue = unsafe.Sizeof([1]C.TPMI_SH_AUTH_SESSION{})

// copyPTpm2HandleBytes copies the data from Go slice as *C.TPM2_HANDLE.
func copyPTpm2HandleBytes(slice *sliceHeader) (*C.TPM2_HANDLE, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2HandleValue) * slice.Len,
		Cap:  int(sizeOfTpm2HandleValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2_HANDLE)(mem0), allocs
}

// allocTpm2HandleMemory allocates memory for type C.TPM2_HANDLE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2HandleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2HandleValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2HandleValue = unsafe.Sizeof([1]C.TPM2_HANDLE{})

// copyPTpm2bSensitiveBytes copies the data from Go slice as *C.TPM2B_SENSITIVE.
func copyPTpm2bSensitiveBytes(slice *sliceHeader) (*C.TPM2B_SENSITIVE, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2bSensitiveValue) * slice.Len,
		Cap:  int(sizeOfTpm2bSensitiveValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2B_SENSITIVE)(mem0), allocs
}

// copyPTpm2bMaxBufferBytes copies the data from Go slice as *C.TPM2B_MAX_BUFFER.
func copyPTpm2bMaxBufferBytes(slice *sliceHeader) (*C.TPM2B_MAX_BUFFER, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2bMaxBufferValue) * slice.Len,
		Cap:  int(sizeOfTpm2bMaxBufferValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2B_MAX_BUFFER)(mem0), allocs
}

// copyPTpm2bDigestBytes copies the data from Go slice as *C.TPM2B_DIGEST.
func copyPTpm2bDigestBytes(slice *sliceHeader) (*C.TPM2B_DIGEST, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2bDigestValue) * slice.Len,
		Cap:  int(sizeOfTpm2bDigestValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2B_DIGEST)(mem0), allocs
}

// copyPTpm2bSensitiveDataBytes copies the data from Go slice as *C.TPM2B_SENSITIVE_DATA.
func copyPTpm2bSensitiveDataBytes(slice *sliceHeader) (*C.TPM2B_SENSITIVE_DATA, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2bSensitiveDataValue) * slice.Len,
		Cap:  int(sizeOfTpm2bSensitiveDataValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2B_SENSITIVE_DATA)(mem0), allocs
}

// copyPTpmiDhObjectBytes copies the data from Go slice as *C.TPMI_DH_OBJECT.
func copyPTpmiDhObjectBytes(slice *sliceHeader) (*C.TPMI_DH_OBJECT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmiDhObjectValue) * slice.Len,
		Cap:  int(sizeOfTpmiDhObjectValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMI_DH_OBJECT)(mem0), allocs
}

// allocTpmiDhObjectMemory allocates memory for type C.TPMI_DH_OBJECT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmiDhObjectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmiDhObjectValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmiDhObjectValue = unsafe.Sizeof([1]C.TPMI_DH_OBJECT{})

// copyPTpm2bEccPointBytes copies the data from Go slice as *C.TPM2B_ECC_POINT.
func copyPTpm2bEccPointBytes(slice *sliceHeader) (*C.TPM2B_ECC_POINT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2bEccPointValue) * slice.Len,
		Cap:  int(sizeOfTpm2bEccPointValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2B_ECC_POINT)(mem0), allocs
}

// unpackArgSTss2lSysAuthResponse transforms a sliced Go data structure into plain C format.
func unpackArgSTss2lSysAuthResponse(x []Tss2lSysAuthResponse) (unpacked *C.TSS2L_SYS_AUTH_RESPONSE, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTss2lSysAuthResponseMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TSS2L_SYS_AUTH_RESPONSE)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TSS2L_SYS_AUTH_RESPONSE)(h.Data)
	return
}

// packSTss2lSysAuthResponse reads sliced Go data structure out from plain C format.
func packSTss2lSysAuthResponse(v []Tss2lSysAuthResponse, ptr0 *C.TSS2L_SYS_AUTH_RESPONSE) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTss2lSysAuthResponseValue]C.TSS2L_SYS_AUTH_RESPONSE)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTss2lSysAuthResponseRef(unsafe.Pointer(&ptr1))
	}
}

// copyPTpmiYesNoBytes copies the data from Go slice as *C.TPMI_YES_NO.
func copyPTpmiYesNoBytes(slice *sliceHeader) (*C.TPMI_YES_NO, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmiYesNoValue) * slice.Len,
		Cap:  int(sizeOfTpmiYesNoValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMI_YES_NO)(mem0), allocs
}

// allocTpmiYesNoMemory allocates memory for type C.TPMI_YES_NO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmiYesNoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmiYesNoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmiYesNoValue = unsafe.Sizeof([1]C.TPMI_YES_NO{})

// copyPTpm2bTimeoutBytes copies the data from Go slice as *C.TPM2B_TIMEOUT.
func copyPTpm2bTimeoutBytes(slice *sliceHeader) (*C.TPM2B_TIMEOUT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2bTimeoutValue) * slice.Len,
		Cap:  int(sizeOfTpm2bTimeoutValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2B_TIMEOUT)(mem0), allocs
}

// allocTpm2bTimeoutMemory allocates memory for type C.TPM2B_TIMEOUT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bTimeoutMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bTimeoutValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bTimeoutValue = unsafe.Sizeof([1]C.TPM2B_TIMEOUT{})

// copyPTpmtHaBytes copies the data from Go slice as *C.TPMT_HA.
func copyPTpmtHaBytes(slice *sliceHeader) (*C.TPMT_HA, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmtHaValue) * slice.Len,
		Cap:  int(sizeOfTpmtHaValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMT_HA)(mem0), allocs
}

// copyPTpmiDhContextBytes copies the data from Go slice as *C.TPMI_DH_CONTEXT.
func copyPTpmiDhContextBytes(slice *sliceHeader) (*C.TPMI_DH_CONTEXT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmiDhContextValue) * slice.Len,
		Cap:  int(sizeOfTpmiDhContextValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMI_DH_CONTEXT)(mem0), allocs
}

// allocTpmiDhContextMemory allocates memory for type C.TPMI_DH_CONTEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmiDhContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmiDhContextValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmiDhContextValue = unsafe.Sizeof([1]C.TPMI_DH_CONTEXT{})

// copyPTpmtPublicParmsBytes copies the data from Go slice as *C.TPMT_PUBLIC_PARMS.
func copyPTpmtPublicParmsBytes(slice *sliceHeader) (*C.TPMT_PUBLIC_PARMS, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmtPublicParmsValue) * slice.Len,
		Cap:  int(sizeOfTpmtPublicParmsValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMT_PUBLIC_PARMS)(mem0), allocs
}

// copyPTpm2bDataBytes copies the data from Go slice as *C.TPM2B_DATA.
func copyPTpm2bDataBytes(slice *sliceHeader) (*C.TPM2B_DATA, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2bDataValue) * slice.Len,
		Cap:  int(sizeOfTpm2bDataValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2B_DATA)(mem0), allocs
}

// copyPTpmsAcOutputBytes copies the data from Go slice as *C.TPMS_AC_OUTPUT.
func copyPTpmsAcOutputBytes(slice *sliceHeader) (*C.TPMS_AC_OUTPUT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmsAcOutputValue) * slice.Len,
		Cap:  int(sizeOfTpmsAcOutputValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMS_AC_OUTPUT)(mem0), allocs
}

// unpackPCharString copies the data from Go string as *C.char.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CString(str))
	allocs.Add(mem0)
	return (*C.char)(mem0), allocs
}
