// License: CC-0

// WARNING: This file has automatically been generated on Sat, 17 Apr 2021 20:21:45 IST.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package go_tpm2_tss

/*
#cgo pkg-config: tss2-tcti-mssim tss2-tcti-device tss2-mu tss2-tctildr tss2-rc tss2-sys tss2-esys
#cgo CFLAGS: -I ../c/include
#include "tss2/tss2_common.h"
#include "tss2/tss2_esys.h"
#include "tss2/tss2_mu.h"
#include "tss2/tss2_rc.h"
#include "tss2/tss2_sys.h"
#include "tss2/tss2_tcti_device.h"
#include "tss2/tss2_tcti.h"
#include "tss2/tss2_tctildr.h"
#include "tss2/tss2_tcti_mssim.h"
#include "tss2/tss2_tcti_tbs.h"
#include "tss2/tss2_tpm2_types.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// Ref returns a reference to C object as it is.
func (x *Tss2AbiVersion) Ref() *C.TSS2_ABI_VERSION {
	if x == nil {
		return nil
	}
	return (*C.TSS2_ABI_VERSION)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tss2AbiVersion) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTss2AbiVersionRef converts the C object reference into a raw struct reference without wrapping.
func NewTss2AbiVersionRef(ref unsafe.Pointer) *Tss2AbiVersion {
	return (*Tss2AbiVersion)(ref)
}

// NewTss2AbiVersion allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTss2AbiVersion() *Tss2AbiVersion {
	return (*Tss2AbiVersion)(allocTss2AbiVersionMemory(1))
}

// allocTss2AbiVersionMemory allocates memory for type C.TSS2_ABI_VERSION in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTss2AbiVersionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTss2AbiVersionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTss2AbiVersionValue = unsafe.Sizeof([1]C.TSS2_ABI_VERSION{})

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tss2AbiVersion) PassRef() *C.TSS2_ABI_VERSION {
	if x == nil {
		x = (*Tss2AbiVersion)(allocTss2AbiVersionMemory(1))
	}
	return (*C.TSS2_ABI_VERSION)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *EsysContext) Ref() *C.ESYS_CONTEXT {
	if x == nil {
		return nil
	}
	return (*C.ESYS_CONTEXT)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *EsysContext) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewEsysContextRef converts the C object reference into a raw struct reference without wrapping.
func NewEsysContextRef(ref unsafe.Pointer) *EsysContext {
	return (*EsysContext)(ref)
}

// NewEsysContext allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewEsysContext() *EsysContext {
	return (*EsysContext)(allocEsysContextMemory(1))
}

// allocEsysContextMemory allocates memory for type C.ESYS_CONTEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocEsysContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfEsysContextValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfEsysContextValue = unsafe.Sizeof([1]C.ESYS_CONTEXT{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *EsysContext) PassRef() *C.ESYS_CONTEXT {
	if x == nil {
		x = (*EsysContext)(allocEsysContextMemory(1))
	}
	return (*C.ESYS_CONTEXT)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tss2TctiContext) Ref() *C.TSS2_TCTI_CONTEXT {
	if x == nil {
		return nil
	}
	return (*C.TSS2_TCTI_CONTEXT)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tss2TctiContext) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTss2TctiContextRef converts the C object reference into a raw struct reference without wrapping.
func NewTss2TctiContextRef(ref unsafe.Pointer) *Tss2TctiContext {
	return (*Tss2TctiContext)(ref)
}

// NewTss2TctiContext allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTss2TctiContext() *Tss2TctiContext {
	return (*Tss2TctiContext)(allocTss2TctiContextMemory(1))
}

// allocTss2TctiContextMemory allocates memory for type C.TSS2_TCTI_CONTEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTss2TctiContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTss2TctiContextValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTss2TctiContextValue = unsafe.Sizeof([1]C.TSS2_TCTI_CONTEXT{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tss2TctiContext) PassRef() *C.TSS2_TCTI_CONTEXT {
	if x == nil {
		x = (*Tss2TctiContext)(allocTss2TctiContextMemory(1))
	}
	return (*C.TSS2_TCTI_CONTEXT)(unsafe.Pointer(x))
}

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

func (x Tss2TctiTransmitFcn) PassRef() (ref *C.TSS2_TCTI_TRANSMIT_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiTransmitFcn3FB81C0DFunc == nil {
		tss2TctiTransmitFcn3FB81C0DFunc = x
	}
	return (*C.TSS2_TCTI_TRANSMIT_FCN)(C.TSS2_TCTI_TRANSMIT_FCN_3fb81c0d), nil
}

func (x Tss2TctiTransmitFcn) PassValue() (ref C.TSS2_TCTI_TRANSMIT_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiTransmitFcn3FB81C0DFunc == nil {
		tss2TctiTransmitFcn3FB81C0DFunc = x
	}
	return (C.TSS2_TCTI_TRANSMIT_FCN)(C.TSS2_TCTI_TRANSMIT_FCN_3fb81c0d), nil
}

func NewTss2TctiTransmitFcnRef(ref unsafe.Pointer) *Tss2TctiTransmitFcn {
	return (*Tss2TctiTransmitFcn)(ref)
}

//export tss2TctiTransmitFcn3FB81C0D
func tss2TctiTransmitFcn3FB81C0D(ctcticontext *C.TSS2_TCTI_CONTEXT, csize C.size_t, ccommand *C.uint8_t) C.TSS2_RC {
	if tss2TctiTransmitFcn3FB81C0DFunc != nil {
		tcticontext3fb81c0d := (*Tss2TctiContext)(unsafe.Pointer(ctcticontext))
		size3fb81c0d := (SizeT)(csize)
		var command3fb81c0d []Uint8T
		hxfc4425b := (*sliceHeader)(unsafe.Pointer(&command3fb81c0d))
		hxfc4425b.Data = unsafe.Pointer(ccommand)
		hxfc4425b.Cap = 0x7fffffff
		// hxfc4425b.Len = ?

		ret3fb81c0d := tss2TctiTransmitFcn3FB81C0DFunc(tcticontext3fb81c0d, size3fb81c0d, command3fb81c0d)
		ret, _ := (C.TSS2_RC)(ret3fb81c0d), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var tss2TctiTransmitFcn3FB81C0DFunc Tss2TctiTransmitFcn

func (x Tss2TctiReceiveFcn) PassRef() (ref *C.TSS2_TCTI_RECEIVE_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiReceiveFcnF4548F13Func == nil {
		tss2TctiReceiveFcnF4548F13Func = x
	}
	return (*C.TSS2_TCTI_RECEIVE_FCN)(C.TSS2_TCTI_RECEIVE_FCN_f4548f13), nil
}

func (x Tss2TctiReceiveFcn) PassValue() (ref C.TSS2_TCTI_RECEIVE_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiReceiveFcnF4548F13Func == nil {
		tss2TctiReceiveFcnF4548F13Func = x
	}
	return (C.TSS2_TCTI_RECEIVE_FCN)(C.TSS2_TCTI_RECEIVE_FCN_f4548f13), nil
}

func NewTss2TctiReceiveFcnRef(ref unsafe.Pointer) *Tss2TctiReceiveFcn {
	return (*Tss2TctiReceiveFcn)(ref)
}

//export tss2TctiReceiveFcnF4548F13
func tss2TctiReceiveFcnF4548F13(ctcticontext *C.TSS2_TCTI_CONTEXT, csize *C.size_t, cresponse *C.uint8_t, ctimeout C.int32_t) C.TSS2_RC {
	if tss2TctiReceiveFcnF4548F13Func != nil {
		tcticontextf4548f13 := (*Tss2TctiContext)(unsafe.Pointer(ctcticontext))
		var sizef4548f13 []SizeT
		hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&sizef4548f13))
		hxf95e7c8.Data = unsafe.Pointer(csize)
		hxf95e7c8.Cap = 0x7fffffff
		// hxf95e7c8.Len = ?

		var responsef4548f13 []Uint8T
		hxff2234b := (*sliceHeader)(unsafe.Pointer(&responsef4548f13))
		hxff2234b.Data = unsafe.Pointer(cresponse)
		hxff2234b.Cap = 0x7fffffff
		// hxff2234b.Len = ?

		timeoutf4548f13 := (Int32T)(ctimeout)
		retf4548f13 := tss2TctiReceiveFcnF4548F13Func(tcticontextf4548f13, sizef4548f13, responsef4548f13, timeoutf4548f13)
		ret, _ := (C.TSS2_RC)(retf4548f13), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var tss2TctiReceiveFcnF4548F13Func Tss2TctiReceiveFcn

func (x Tss2TctiFinalizeFcn) PassRef() (ref *C.TSS2_TCTI_FINALIZE_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiFinalizeFcnF5E8712EFunc == nil {
		tss2TctiFinalizeFcnF5E8712EFunc = x
	}
	return (*C.TSS2_TCTI_FINALIZE_FCN)(C.TSS2_TCTI_FINALIZE_FCN_f5e8712e), nil
}

func (x Tss2TctiFinalizeFcn) PassValue() (ref C.TSS2_TCTI_FINALIZE_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiFinalizeFcnF5E8712EFunc == nil {
		tss2TctiFinalizeFcnF5E8712EFunc = x
	}
	return (C.TSS2_TCTI_FINALIZE_FCN)(C.TSS2_TCTI_FINALIZE_FCN_f5e8712e), nil
}

func NewTss2TctiFinalizeFcnRef(ref unsafe.Pointer) *Tss2TctiFinalizeFcn {
	return (*Tss2TctiFinalizeFcn)(ref)
}

//export tss2TctiFinalizeFcnF5E8712E
func tss2TctiFinalizeFcnF5E8712E(ctcticontext *C.TSS2_TCTI_CONTEXT) {
	if tss2TctiFinalizeFcnF5E8712EFunc != nil {
		tcticontextf5e8712e := (*Tss2TctiContext)(unsafe.Pointer(ctcticontext))
		tss2TctiFinalizeFcnF5E8712EFunc(tcticontextf5e8712e)
		return
	}
	panic("callback func has not been set (race?)")
}

var tss2TctiFinalizeFcnF5E8712EFunc Tss2TctiFinalizeFcn

func (x Tss2TctiCancelFcn) PassRef() (ref *C.TSS2_TCTI_CANCEL_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiCancelFcn900241EBFunc == nil {
		tss2TctiCancelFcn900241EBFunc = x
	}
	return (*C.TSS2_TCTI_CANCEL_FCN)(C.TSS2_TCTI_CANCEL_FCN_900241eb), nil
}

func (x Tss2TctiCancelFcn) PassValue() (ref C.TSS2_TCTI_CANCEL_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiCancelFcn900241EBFunc == nil {
		tss2TctiCancelFcn900241EBFunc = x
	}
	return (C.TSS2_TCTI_CANCEL_FCN)(C.TSS2_TCTI_CANCEL_FCN_900241eb), nil
}

func NewTss2TctiCancelFcnRef(ref unsafe.Pointer) *Tss2TctiCancelFcn {
	return (*Tss2TctiCancelFcn)(ref)
}

//export tss2TctiCancelFcn900241EB
func tss2TctiCancelFcn900241EB(ctcticontext *C.TSS2_TCTI_CONTEXT) C.TSS2_RC {
	if tss2TctiCancelFcn900241EBFunc != nil {
		tcticontext900241eb := (*Tss2TctiContext)(unsafe.Pointer(ctcticontext))
		ret900241eb := tss2TctiCancelFcn900241EBFunc(tcticontext900241eb)
		ret, _ := (C.TSS2_RC)(ret900241eb), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var tss2TctiCancelFcn900241EBFunc Tss2TctiCancelFcn

func (x Tss2TctiGetPollHandlesFcn) PassRef() (ref *C.TSS2_TCTI_GET_POLL_HANDLES_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiGetPollHandlesFcnD9753DA9Func == nil {
		tss2TctiGetPollHandlesFcnD9753DA9Func = x
	}
	return (*C.TSS2_TCTI_GET_POLL_HANDLES_FCN)(C.TSS2_TCTI_GET_POLL_HANDLES_FCN_d9753da9), nil
}

func (x Tss2TctiGetPollHandlesFcn) PassValue() (ref C.TSS2_TCTI_GET_POLL_HANDLES_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiGetPollHandlesFcnD9753DA9Func == nil {
		tss2TctiGetPollHandlesFcnD9753DA9Func = x
	}
	return (C.TSS2_TCTI_GET_POLL_HANDLES_FCN)(C.TSS2_TCTI_GET_POLL_HANDLES_FCN_d9753da9), nil
}

func NewTss2TctiGetPollHandlesFcnRef(ref unsafe.Pointer) *Tss2TctiGetPollHandlesFcn {
	return (*Tss2TctiGetPollHandlesFcn)(ref)
}

//export tss2TctiGetPollHandlesFcnD9753DA9
func tss2TctiGetPollHandlesFcnD9753DA9(ctcticontext *C.TSS2_TCTI_CONTEXT, chandles *C.TSS2_TCTI_POLL_HANDLE, cnumHandles *C.size_t) C.TSS2_RC {
	if tss2TctiGetPollHandlesFcnD9753DA9Func != nil {
		tcticontextd9753da9 := (*Tss2TctiContext)(unsafe.Pointer(ctcticontext))
		handlesd9753da9 := (*Tss2TctiPollHandle)(unsafe.Pointer(chandles))
		var numHandlesd9753da9 []SizeT
		hxff73280 := (*sliceHeader)(unsafe.Pointer(&numHandlesd9753da9))
		hxff73280.Data = unsafe.Pointer(cnumHandles)
		hxff73280.Cap = 0x7fffffff
		// hxff73280.Len = ?

		retd9753da9 := tss2TctiGetPollHandlesFcnD9753DA9Func(tcticontextd9753da9, handlesd9753da9, numHandlesd9753da9)
		ret, _ := (C.TSS2_RC)(retd9753da9), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var tss2TctiGetPollHandlesFcnD9753DA9Func Tss2TctiGetPollHandlesFcn

func (x Tss2TctiSetLocalityFcn) PassRef() (ref *C.TSS2_TCTI_SET_LOCALITY_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiSetLocalityFcn47C1ECDAFunc == nil {
		tss2TctiSetLocalityFcn47C1ECDAFunc = x
	}
	return (*C.TSS2_TCTI_SET_LOCALITY_FCN)(C.TSS2_TCTI_SET_LOCALITY_FCN_47c1ecda), nil
}

func (x Tss2TctiSetLocalityFcn) PassValue() (ref C.TSS2_TCTI_SET_LOCALITY_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiSetLocalityFcn47C1ECDAFunc == nil {
		tss2TctiSetLocalityFcn47C1ECDAFunc = x
	}
	return (C.TSS2_TCTI_SET_LOCALITY_FCN)(C.TSS2_TCTI_SET_LOCALITY_FCN_47c1ecda), nil
}

func NewTss2TctiSetLocalityFcnRef(ref unsafe.Pointer) *Tss2TctiSetLocalityFcn {
	return (*Tss2TctiSetLocalityFcn)(ref)
}

//export tss2TctiSetLocalityFcn47C1ECDA
func tss2TctiSetLocalityFcn47C1ECDA(ctcticontext *C.TSS2_TCTI_CONTEXT, clocality C.uint8_t) C.TSS2_RC {
	if tss2TctiSetLocalityFcn47C1ECDAFunc != nil {
		tcticontext47c1ecda := (*Tss2TctiContext)(unsafe.Pointer(ctcticontext))
		locality47c1ecda := (Uint8T)(clocality)
		ret47c1ecda := tss2TctiSetLocalityFcn47C1ECDAFunc(tcticontext47c1ecda, locality47c1ecda)
		ret, _ := (C.TSS2_RC)(ret47c1ecda), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var tss2TctiSetLocalityFcn47C1ECDAFunc Tss2TctiSetLocalityFcn

func (x Tss2TctiMakeStickyFcn) PassRef() (ref *C.TSS2_TCTI_MAKE_STICKY_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiMakeStickyFcnDE2406FCFunc == nil {
		tss2TctiMakeStickyFcnDE2406FCFunc = x
	}
	return (*C.TSS2_TCTI_MAKE_STICKY_FCN)(C.TSS2_TCTI_MAKE_STICKY_FCN_de2406fc), nil
}

func (x Tss2TctiMakeStickyFcn) PassValue() (ref C.TSS2_TCTI_MAKE_STICKY_FCN, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiMakeStickyFcnDE2406FCFunc == nil {
		tss2TctiMakeStickyFcnDE2406FCFunc = x
	}
	return (C.TSS2_TCTI_MAKE_STICKY_FCN)(C.TSS2_TCTI_MAKE_STICKY_FCN_de2406fc), nil
}

func NewTss2TctiMakeStickyFcnRef(ref unsafe.Pointer) *Tss2TctiMakeStickyFcn {
	return (*Tss2TctiMakeStickyFcn)(ref)
}

//export tss2TctiMakeStickyFcnDE2406FC
func tss2TctiMakeStickyFcnDE2406FC(ctcticontext *C.TSS2_TCTI_CONTEXT, chandle *C.TPM2_HANDLE, csticky C.uint8_t) C.TSS2_RC {
	if tss2TctiMakeStickyFcnDE2406FCFunc != nil {
		tcticontextde2406fc := (*Tss2TctiContext)(unsafe.Pointer(ctcticontext))
		var handlede2406fc []Tpm2Handle
		hxfa9955c := (*sliceHeader)(unsafe.Pointer(&handlede2406fc))
		hxfa9955c.Data = unsafe.Pointer(chandle)
		hxfa9955c.Cap = 0x7fffffff
		// hxfa9955c.Len = ?

		stickyde2406fc := (Uint8T)(csticky)
		retde2406fc := tss2TctiMakeStickyFcnDE2406FCFunc(tcticontextde2406fc, handlede2406fc, stickyde2406fc)
		ret, _ := (C.TSS2_RC)(retde2406fc), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var tss2TctiMakeStickyFcnDE2406FCFunc Tss2TctiMakeStickyFcn

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}

func (x Tss2TctiInitFunc) PassRef() (ref *C.TSS2_TCTI_INIT_FUNC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiInitFuncA5EFFE61Func == nil {
		tss2TctiInitFuncA5EFFE61Func = x
	}
	return (*C.TSS2_TCTI_INIT_FUNC)(C.TSS2_TCTI_INIT_FUNC_a5effe61), nil
}

func (x Tss2TctiInitFunc) PassValue() (ref C.TSS2_TCTI_INIT_FUNC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiInitFuncA5EFFE61Func == nil {
		tss2TctiInitFuncA5EFFE61Func = x
	}
	return (C.TSS2_TCTI_INIT_FUNC)(C.TSS2_TCTI_INIT_FUNC_a5effe61), nil
}

func NewTss2TctiInitFuncRef(ref unsafe.Pointer) *Tss2TctiInitFunc {
	return (*Tss2TctiInitFunc)(ref)
}

//export tss2TctiInitFuncA5EFFE61
func tss2TctiInitFuncA5EFFE61(ctcticontext *C.TSS2_TCTI_CONTEXT, csize *C.size_t, cconfig *C.char) C.TSS2_RC {
	if tss2TctiInitFuncA5EFFE61Func != nil {
		tcticontexta5effe61 := (*Tss2TctiContext)(unsafe.Pointer(ctcticontext))
		var sizea5effe61 []uint32
		hxfa3f05c := (*sliceHeader)(unsafe.Pointer(&sizea5effe61))
		hxfa3f05c.Data = unsafe.Pointer(csize)
		hxfa3f05c.Cap = 0x7fffffff
		// hxfa3f05c.Len = ?

		configa5effe61 := packPCharString(cconfig)
		reta5effe61 := tss2TctiInitFuncA5EFFE61Func(tcticontexta5effe61, sizea5effe61, configa5effe61)
		ret, _ := (C.TSS2_RC)(reta5effe61), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var tss2TctiInitFuncA5EFFE61Func Tss2TctiInitFunc

// Ref returns a reference to C object as it is.
func (x *Tss2TctiContextCommonV1) Ref() *C.TSS2_TCTI_CONTEXT_COMMON_V1 {
	if x == nil {
		return nil
	}
	return (*C.TSS2_TCTI_CONTEXT_COMMON_V1)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tss2TctiContextCommonV1) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTss2TctiContextCommonV1Ref converts the C object reference into a raw struct reference without wrapping.
func NewTss2TctiContextCommonV1Ref(ref unsafe.Pointer) *Tss2TctiContextCommonV1 {
	return (*Tss2TctiContextCommonV1)(ref)
}

// NewTss2TctiContextCommonV1 allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTss2TctiContextCommonV1() *Tss2TctiContextCommonV1 {
	return (*Tss2TctiContextCommonV1)(allocTss2TctiContextCommonV1Memory(1))
}

// allocTss2TctiContextCommonV1Memory allocates memory for type C.TSS2_TCTI_CONTEXT_COMMON_V1 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTss2TctiContextCommonV1Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTss2TctiContextCommonV1Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTss2TctiContextCommonV1Value = unsafe.Sizeof([1]C.TSS2_TCTI_CONTEXT_COMMON_V1{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tss2TctiContextCommonV1) PassRef() *C.TSS2_TCTI_CONTEXT_COMMON_V1 {
	if x == nil {
		x = (*Tss2TctiContextCommonV1)(allocTss2TctiContextCommonV1Memory(1))
	}
	return (*C.TSS2_TCTI_CONTEXT_COMMON_V1)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tss2TctiContextCommonV2) Ref() *C.TSS2_TCTI_CONTEXT_COMMON_V2 {
	if x == nil {
		return nil
	}
	return (*C.TSS2_TCTI_CONTEXT_COMMON_V2)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tss2TctiContextCommonV2) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTss2TctiContextCommonV2Ref converts the C object reference into a raw struct reference without wrapping.
func NewTss2TctiContextCommonV2Ref(ref unsafe.Pointer) *Tss2TctiContextCommonV2 {
	return (*Tss2TctiContextCommonV2)(ref)
}

// NewTss2TctiContextCommonV2 allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTss2TctiContextCommonV2() *Tss2TctiContextCommonV2 {
	return (*Tss2TctiContextCommonV2)(allocTss2TctiContextCommonV2Memory(1))
}

// allocTss2TctiContextCommonV2Memory allocates memory for type C.TSS2_TCTI_CONTEXT_COMMON_V2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTss2TctiContextCommonV2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTss2TctiContextCommonV2Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTss2TctiContextCommonV2Value = unsafe.Sizeof([1]C.TSS2_TCTI_CONTEXT_COMMON_V2{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tss2TctiContextCommonV2) PassRef() *C.TSS2_TCTI_CONTEXT_COMMON_V2 {
	if x == nil {
		x = (*Tss2TctiContextCommonV2)(allocTss2TctiContextCommonV2Memory(1))
	}
	return (*C.TSS2_TCTI_CONTEXT_COMMON_V2)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tss2TctiContextCommonCurrent) Ref() *C.TSS2_TCTI_CONTEXT_COMMON_V2 {
	if x == nil {
		return nil
	}
	return (*C.TSS2_TCTI_CONTEXT_COMMON_V2)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tss2TctiContextCommonCurrent) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTss2TctiContextCommonCurrentRef converts the C object reference into a raw struct reference without wrapping.
func NewTss2TctiContextCommonCurrentRef(ref unsafe.Pointer) *Tss2TctiContextCommonCurrent {
	return (*Tss2TctiContextCommonCurrent)(ref)
}

// NewTss2TctiContextCommonCurrent allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTss2TctiContextCommonCurrent() *Tss2TctiContextCommonCurrent {
	return (*Tss2TctiContextCommonCurrent)(allocTss2TctiContextCommonV2Memory(1))
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tss2TctiContextCommonCurrent) PassRef() *C.TSS2_TCTI_CONTEXT_COMMON_V2 {
	if x == nil {
		x = (*Tss2TctiContextCommonCurrent)(allocTss2TctiContextCommonV2Memory(1))
	}
	return (*C.TSS2_TCTI_CONTEXT_COMMON_V2)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tss2TctiInfo) Ref() *C.TSS2_TCTI_INFO {
	if x == nil {
		return nil
	}
	return (*C.TSS2_TCTI_INFO)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tss2TctiInfo) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTss2TctiInfoRef converts the C object reference into a raw struct reference without wrapping.
func NewTss2TctiInfoRef(ref unsafe.Pointer) *Tss2TctiInfo {
	return (*Tss2TctiInfo)(ref)
}

// NewTss2TctiInfo allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTss2TctiInfo() *Tss2TctiInfo {
	return (*Tss2TctiInfo)(allocTss2TctiInfoMemory(1))
}

// allocTss2TctiInfoMemory allocates memory for type C.TSS2_TCTI_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTss2TctiInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTss2TctiInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTss2TctiInfoValue = unsafe.Sizeof([1]C.TSS2_TCTI_INFO{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tss2TctiInfo) PassRef() *C.TSS2_TCTI_INFO {
	if x == nil {
		x = (*Tss2TctiInfo)(allocTss2TctiInfoMemory(1))
	}
	return (*C.TSS2_TCTI_INFO)(unsafe.Pointer(x))
}

// copyPTss2TctiInfoBytes copies the data from Go slice as *C.TSS2_TCTI_INFO.
func copyPTss2TctiInfoBytes(slice *sliceHeader) (*C.TSS2_TCTI_INFO, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTss2TctiInfoValue) * slice.Len,
		Cap:  int(sizeOfTss2TctiInfoValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TSS2_TCTI_INFO)(mem0), allocs
}

func (x Tss2TctiInfoFunc) PassRef() (ref *C.TSS2_TCTI_INFO_FUNC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiInfoFunc3AB67CD0Func == nil {
		tss2TctiInfoFunc3AB67CD0Func = x
	}
	return (*C.TSS2_TCTI_INFO_FUNC)(C.TSS2_TCTI_INFO_FUNC_3ab67cd0), nil
}

func (x Tss2TctiInfoFunc) PassValue() (ref C.TSS2_TCTI_INFO_FUNC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2TctiInfoFunc3AB67CD0Func == nil {
		tss2TctiInfoFunc3AB67CD0Func = x
	}
	return (C.TSS2_TCTI_INFO_FUNC)(C.TSS2_TCTI_INFO_FUNC_3ab67cd0), nil
}

func NewTss2TctiInfoFuncRef(ref unsafe.Pointer) *Tss2TctiInfoFunc {
	return (*Tss2TctiInfoFunc)(ref)
}

//export tss2TctiInfoFunc3AB67CD0
func tss2TctiInfoFunc3AB67CD0() *C.TSS2_TCTI_INFO {
	if tss2TctiInfoFunc3AB67CD0Func != nil {
		ret3ab67cd0 := tss2TctiInfoFunc3AB67CD0Func()
		ret, _ := copyPTss2TctiInfoBytes((*sliceHeader)(unsafe.Pointer(&ret3ab67cd0)))
		return ret
	}
	panic("callback func has not been set (race?)")
}

var tss2TctiInfoFunc3AB67CD0Func Tss2TctiInfoFunc

// allocTpmsEmptyMemory allocates memory for type C.TPMS_EMPTY in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsEmptyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsEmptyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsEmptyValue = unsafe.Sizeof([1]C.TPMS_EMPTY{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsEmpty) Ref() *C.TPMS_EMPTY {
	if x == nil {
		return nil
	}
	return x.ref25eb996f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsEmpty) Free() {
	if x != nil && x.allocs25eb996f != nil {
		x.allocs25eb996f.(*cgoAllocMap).Free()
		x.ref25eb996f = nil
	}
}

// NewTpmsEmptyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsEmptyRef(ref unsafe.Pointer) *TpmsEmpty {
	if ref == nil {
		return nil
	}
	obj := new(TpmsEmpty)
	obj.ref25eb996f = (*C.TPMS_EMPTY)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsEmpty) PassRef() (*C.TPMS_EMPTY, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref25eb996f != nil {
		return x.ref25eb996f, nil
	}
	mem25eb996f := allocTpmsEmptyMemory(1)
	ref25eb996f := (*C.TPMS_EMPTY)(mem25eb996f)
	allocs25eb996f := new(cgoAllocMap)
	allocs25eb996f.Add(mem25eb996f)

	var cempty_allocs *cgoAllocMap
	ref25eb996f.empty, cempty_allocs = *(*[1]C.BYTE)(unsafe.Pointer(&x.Empty)), cgoAllocsUnknown
	allocs25eb996f.Borrow(cempty_allocs)

	x.ref25eb996f = ref25eb996f
	x.allocs25eb996f = allocs25eb996f
	return ref25eb996f, allocs25eb996f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsEmpty) PassValue() (C.TPMS_EMPTY, *cgoAllocMap) {
	if x.ref25eb996f != nil {
		return *x.ref25eb996f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsEmpty) Deref() {
	if x.ref25eb996f == nil {
		return
	}
	x.Empty = *(*[1]Byte)(unsafe.Pointer(&x.ref25eb996f.empty))
}

// allocTpmsAlgorithmDescriptionMemory allocates memory for type C.TPMS_ALGORITHM_DESCRIPTION in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsAlgorithmDescriptionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsAlgorithmDescriptionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsAlgorithmDescriptionValue = unsafe.Sizeof([1]C.TPMS_ALGORITHM_DESCRIPTION{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsAlgorithmDescription) Ref() *C.TPMS_ALGORITHM_DESCRIPTION {
	if x == nil {
		return nil
	}
	return x.ref3b72095b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsAlgorithmDescription) Free() {
	if x != nil && x.allocs3b72095b != nil {
		x.allocs3b72095b.(*cgoAllocMap).Free()
		x.ref3b72095b = nil
	}
}

// NewTpmsAlgorithmDescriptionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsAlgorithmDescriptionRef(ref unsafe.Pointer) *TpmsAlgorithmDescription {
	if ref == nil {
		return nil
	}
	obj := new(TpmsAlgorithmDescription)
	obj.ref3b72095b = (*C.TPMS_ALGORITHM_DESCRIPTION)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsAlgorithmDescription) PassRef() (*C.TPMS_ALGORITHM_DESCRIPTION, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3b72095b != nil {
		return x.ref3b72095b, nil
	}
	mem3b72095b := allocTpmsAlgorithmDescriptionMemory(1)
	ref3b72095b := (*C.TPMS_ALGORITHM_DESCRIPTION)(mem3b72095b)
	allocs3b72095b := new(cgoAllocMap)
	allocs3b72095b.Add(mem3b72095b)

	var calg_allocs *cgoAllocMap
	ref3b72095b.alg, calg_allocs = (C.TPM2_ALG_ID)(x.Alg), cgoAllocsUnknown
	allocs3b72095b.Borrow(calg_allocs)

	var cattributes_allocs *cgoAllocMap
	ref3b72095b.attributes, cattributes_allocs = (C.TPMA_ALGORITHM)(x.Attributes), cgoAllocsUnknown
	allocs3b72095b.Borrow(cattributes_allocs)

	x.ref3b72095b = ref3b72095b
	x.allocs3b72095b = allocs3b72095b
	return ref3b72095b, allocs3b72095b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsAlgorithmDescription) PassValue() (C.TPMS_ALGORITHM_DESCRIPTION, *cgoAllocMap) {
	if x.ref3b72095b != nil {
		return *x.ref3b72095b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsAlgorithmDescription) Deref() {
	if x.ref3b72095b == nil {
		return
	}
	x.Alg = (Tpm2AlgId)(x.ref3b72095b.alg)
	x.Attributes = (TpmaAlgorithm)(x.ref3b72095b.attributes)
}

// allocTpmtHaMemory allocates memory for type C.TPMT_HA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtHaMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtHaValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtHaValue = unsafe.Sizeof([1]C.TPMT_HA{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmtHa) Ref() *C.TPMT_HA {
	if x == nil {
		return nil
	}
	return x.reffcefc3a6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmtHa) Free() {
	if x != nil && x.allocsfcefc3a6 != nil {
		x.allocsfcefc3a6.(*cgoAllocMap).Free()
		x.reffcefc3a6 = nil
	}
}

// NewTpmtHaRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmtHaRef(ref unsafe.Pointer) *TpmtHa {
	if ref == nil {
		return nil
	}
	obj := new(TpmtHa)
	obj.reffcefc3a6 = (*C.TPMT_HA)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmtHa) PassRef() (*C.TPMT_HA, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffcefc3a6 != nil {
		return x.reffcefc3a6, nil
	}
	memfcefc3a6 := allocTpmtHaMemory(1)
	reffcefc3a6 := (*C.TPMT_HA)(memfcefc3a6)
	allocsfcefc3a6 := new(cgoAllocMap)
	allocsfcefc3a6.Add(memfcefc3a6)

	var chashAlg_allocs *cgoAllocMap
	reffcefc3a6.hashAlg, chashAlg_allocs = (C.TPMI_ALG_HASH)(x.Hashalg), cgoAllocsUnknown
	allocsfcefc3a6.Borrow(chashAlg_allocs)

	var cdigest_allocs *cgoAllocMap
	reffcefc3a6.digest, cdigest_allocs = *(*C.TPMU_HA)(unsafe.Pointer(&x.Digest)), cgoAllocsUnknown
	allocsfcefc3a6.Borrow(cdigest_allocs)

	x.reffcefc3a6 = reffcefc3a6
	x.allocsfcefc3a6 = allocsfcefc3a6
	return reffcefc3a6, allocsfcefc3a6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmtHa) PassValue() (C.TPMT_HA, *cgoAllocMap) {
	if x.reffcefc3a6 != nil {
		return *x.reffcefc3a6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmtHa) Deref() {
	if x.reffcefc3a6 == nil {
		return
	}
	x.Hashalg = (TpmiAlgHash)(x.reffcefc3a6.hashAlg)
	x.Digest = *(*TpmuHa)(unsafe.Pointer(&x.reffcefc3a6.digest))
}

// allocTpm2bDigestMemory allocates memory for type C.TPM2B_DIGEST in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bDigestMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bDigestValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bDigestValue = unsafe.Sizeof([1]C.TPM2B_DIGEST{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Tpm2bDigest) Ref() *C.TPM2B_DIGEST {
	if x == nil {
		return nil
	}
	return x.refa5988425
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Tpm2bDigest) Free() {
	if x != nil && x.allocsa5988425 != nil {
		x.allocsa5988425.(*cgoAllocMap).Free()
		x.refa5988425 = nil
	}
}

// NewTpm2bDigestRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpm2bDigestRef(ref unsafe.Pointer) *Tpm2bDigest {
	if ref == nil {
		return nil
	}
	obj := new(Tpm2bDigest)
	obj.refa5988425 = (*C.TPM2B_DIGEST)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Tpm2bDigest) PassRef() (*C.TPM2B_DIGEST, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa5988425 != nil {
		return x.refa5988425, nil
	}
	mema5988425 := allocTpm2bDigestMemory(1)
	refa5988425 := (*C.TPM2B_DIGEST)(mema5988425)
	allocsa5988425 := new(cgoAllocMap)
	allocsa5988425.Add(mema5988425)

	var csize_allocs *cgoAllocMap
	refa5988425.size, csize_allocs = (C.UINT16)(x.Size), cgoAllocsUnknown
	allocsa5988425.Borrow(csize_allocs)

	var cbuffer_allocs *cgoAllocMap
	refa5988425.buffer, cbuffer_allocs = *(*[64]C.BYTE)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocsa5988425.Borrow(cbuffer_allocs)

	x.refa5988425 = refa5988425
	x.allocsa5988425 = allocsa5988425
	return refa5988425, allocsa5988425

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Tpm2bDigest) PassValue() (C.TPM2B_DIGEST, *cgoAllocMap) {
	if x.refa5988425 != nil {
		return *x.refa5988425, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Tpm2bDigest) Deref() {
	if x.refa5988425 == nil {
		return
	}
	x.Size = (Uint16)(x.refa5988425.size)
	x.Buffer = *(*[64]Byte)(unsafe.Pointer(&x.refa5988425.buffer))
}

// allocTpm2bDataMemory allocates memory for type C.TPM2B_DATA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bDataValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bDataValue = unsafe.Sizeof([1]C.TPM2B_DATA{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Tpm2bData) Ref() *C.TPM2B_DATA {
	if x == nil {
		return nil
	}
	return x.refeeb25ec3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Tpm2bData) Free() {
	if x != nil && x.allocseeb25ec3 != nil {
		x.allocseeb25ec3.(*cgoAllocMap).Free()
		x.refeeb25ec3 = nil
	}
}

// NewTpm2bDataRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpm2bDataRef(ref unsafe.Pointer) *Tpm2bData {
	if ref == nil {
		return nil
	}
	obj := new(Tpm2bData)
	obj.refeeb25ec3 = (*C.TPM2B_DATA)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Tpm2bData) PassRef() (*C.TPM2B_DATA, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refeeb25ec3 != nil {
		return x.refeeb25ec3, nil
	}
	memeeb25ec3 := allocTpm2bDataMemory(1)
	refeeb25ec3 := (*C.TPM2B_DATA)(memeeb25ec3)
	allocseeb25ec3 := new(cgoAllocMap)
	allocseeb25ec3.Add(memeeb25ec3)

	var csize_allocs *cgoAllocMap
	refeeb25ec3.size, csize_allocs = (C.UINT16)(x.Size), cgoAllocsUnknown
	allocseeb25ec3.Borrow(csize_allocs)

	var cbuffer_allocs *cgoAllocMap
	refeeb25ec3.buffer, cbuffer_allocs = *(*[64]C.BYTE)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocseeb25ec3.Borrow(cbuffer_allocs)

	x.refeeb25ec3 = refeeb25ec3
	x.allocseeb25ec3 = allocseeb25ec3
	return refeeb25ec3, allocseeb25ec3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Tpm2bData) PassValue() (C.TPM2B_DATA, *cgoAllocMap) {
	if x.refeeb25ec3 != nil {
		return *x.refeeb25ec3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Tpm2bData) Deref() {
	if x.refeeb25ec3 == nil {
		return
	}
	x.Size = (Uint16)(x.refeeb25ec3.size)
	x.Buffer = *(*[64]Byte)(unsafe.Pointer(&x.refeeb25ec3.buffer))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Tpm2bNonce) Ref() *C.TPM2B_DIGEST {
	if x == nil {
		return nil
	}
	return x.refa5988425
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Tpm2bNonce) Free() {
	if x != nil && x.allocsa5988425 != nil {
		x.allocsa5988425.(*cgoAllocMap).Free()
		x.refa5988425 = nil
	}
}

// NewTpm2bNonceRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpm2bNonceRef(ref unsafe.Pointer) *Tpm2bNonce {
	if ref == nil {
		return nil
	}
	obj := new(Tpm2bNonce)
	obj.refa5988425 = (*C.TPM2B_DIGEST)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Tpm2bNonce) PassRef() (*C.TPM2B_DIGEST, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa5988425 != nil {
		return x.refa5988425, nil
	}
	mema5988425 := allocTpm2bDigestMemory(1)
	refa5988425 := (*C.TPM2B_DIGEST)(mema5988425)
	allocsa5988425 := new(cgoAllocMap)
	allocsa5988425.Add(mema5988425)

	var csize_allocs *cgoAllocMap
	refa5988425.size, csize_allocs = (C.UINT16)(x.Size), cgoAllocsUnknown
	allocsa5988425.Borrow(csize_allocs)

	var cbuffer_allocs *cgoAllocMap
	refa5988425.buffer, cbuffer_allocs = *(*[64]C.BYTE)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocsa5988425.Borrow(cbuffer_allocs)

	x.refa5988425 = refa5988425
	x.allocsa5988425 = allocsa5988425
	return refa5988425, allocsa5988425

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Tpm2bNonce) PassValue() (C.TPM2B_DIGEST, *cgoAllocMap) {
	if x.refa5988425 != nil {
		return *x.refa5988425, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Tpm2bNonce) Deref() {
	if x.refa5988425 == nil {
		return
	}
	x.Size = (Uint16)(x.refa5988425.size)
	x.Buffer = *(*[64]Byte)(unsafe.Pointer(&x.refa5988425.buffer))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Tpm2bAuth) Ref() *C.TPM2B_DIGEST {
	if x == nil {
		return nil
	}
	return x.refa5988425
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Tpm2bAuth) Free() {
	if x != nil && x.allocsa5988425 != nil {
		x.allocsa5988425.(*cgoAllocMap).Free()
		x.refa5988425 = nil
	}
}

// NewTpm2bAuthRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpm2bAuthRef(ref unsafe.Pointer) *Tpm2bAuth {
	if ref == nil {
		return nil
	}
	obj := new(Tpm2bAuth)
	obj.refa5988425 = (*C.TPM2B_DIGEST)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Tpm2bAuth) PassRef() (*C.TPM2B_DIGEST, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa5988425 != nil {
		return x.refa5988425, nil
	}
	mema5988425 := allocTpm2bDigestMemory(1)
	refa5988425 := (*C.TPM2B_DIGEST)(mema5988425)
	allocsa5988425 := new(cgoAllocMap)
	allocsa5988425.Add(mema5988425)

	var csize_allocs *cgoAllocMap
	refa5988425.size, csize_allocs = (C.UINT16)(x.Size), cgoAllocsUnknown
	allocsa5988425.Borrow(csize_allocs)

	var cbuffer_allocs *cgoAllocMap
	refa5988425.buffer, cbuffer_allocs = *(*[64]C.BYTE)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocsa5988425.Borrow(cbuffer_allocs)

	x.refa5988425 = refa5988425
	x.allocsa5988425 = allocsa5988425
	return refa5988425, allocsa5988425

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Tpm2bAuth) PassValue() (C.TPM2B_DIGEST, *cgoAllocMap) {
	if x.refa5988425 != nil {
		return *x.refa5988425, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Tpm2bAuth) Deref() {
	if x.refa5988425 == nil {
		return
	}
	x.Size = (Uint16)(x.refa5988425.size)
	x.Buffer = *(*[64]Byte)(unsafe.Pointer(&x.refa5988425.buffer))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Tpm2bOperand) Ref() *C.TPM2B_DIGEST {
	if x == nil {
		return nil
	}
	return x.refa5988425
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Tpm2bOperand) Free() {
	if x != nil && x.allocsa5988425 != nil {
		x.allocsa5988425.(*cgoAllocMap).Free()
		x.refa5988425 = nil
	}
}

// NewTpm2bOperandRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpm2bOperandRef(ref unsafe.Pointer) *Tpm2bOperand {
	if ref == nil {
		return nil
	}
	obj := new(Tpm2bOperand)
	obj.refa5988425 = (*C.TPM2B_DIGEST)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Tpm2bOperand) PassRef() (*C.TPM2B_DIGEST, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa5988425 != nil {
		return x.refa5988425, nil
	}
	mema5988425 := allocTpm2bDigestMemory(1)
	refa5988425 := (*C.TPM2B_DIGEST)(mema5988425)
	allocsa5988425 := new(cgoAllocMap)
	allocsa5988425.Add(mema5988425)

	var csize_allocs *cgoAllocMap
	refa5988425.size, csize_allocs = (C.UINT16)(x.Size), cgoAllocsUnknown
	allocsa5988425.Borrow(csize_allocs)

	var cbuffer_allocs *cgoAllocMap
	refa5988425.buffer, cbuffer_allocs = *(*[64]C.BYTE)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocsa5988425.Borrow(cbuffer_allocs)

	x.refa5988425 = refa5988425
	x.allocsa5988425 = allocsa5988425
	return refa5988425, allocsa5988425

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Tpm2bOperand) PassValue() (C.TPM2B_DIGEST, *cgoAllocMap) {
	if x.refa5988425 != nil {
		return *x.refa5988425, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Tpm2bOperand) Deref() {
	if x.refa5988425 == nil {
		return
	}
	x.Size = (Uint16)(x.refa5988425.size)
	x.Buffer = *(*[64]Byte)(unsafe.Pointer(&x.refa5988425.buffer))
}

// allocTpm2bEventMemory allocates memory for type C.TPM2B_EVENT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bEventMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bEventValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bEventValue = unsafe.Sizeof([1]C.TPM2B_EVENT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Tpm2bEvent) Ref() *C.TPM2B_EVENT {
	if x == nil {
		return nil
	}
	return x.refd655c82a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Tpm2bEvent) Free() {
	if x != nil && x.allocsd655c82a != nil {
		x.allocsd655c82a.(*cgoAllocMap).Free()
		x.refd655c82a = nil
	}
}

// NewTpm2bEventRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpm2bEventRef(ref unsafe.Pointer) *Tpm2bEvent {
	if ref == nil {
		return nil
	}
	obj := new(Tpm2bEvent)
	obj.refd655c82a = (*C.TPM2B_EVENT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Tpm2bEvent) PassRef() (*C.TPM2B_EVENT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd655c82a != nil {
		return x.refd655c82a, nil
	}
	memd655c82a := allocTpm2bEventMemory(1)
	refd655c82a := (*C.TPM2B_EVENT)(memd655c82a)
	allocsd655c82a := new(cgoAllocMap)
	allocsd655c82a.Add(memd655c82a)

	var csize_allocs *cgoAllocMap
	refd655c82a.size, csize_allocs = (C.UINT16)(x.Size), cgoAllocsUnknown
	allocsd655c82a.Borrow(csize_allocs)

	var cbuffer_allocs *cgoAllocMap
	refd655c82a.buffer, cbuffer_allocs = *(*[1024]C.BYTE)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocsd655c82a.Borrow(cbuffer_allocs)

	x.refd655c82a = refd655c82a
	x.allocsd655c82a = allocsd655c82a
	return refd655c82a, allocsd655c82a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Tpm2bEvent) PassValue() (C.TPM2B_EVENT, *cgoAllocMap) {
	if x.refd655c82a != nil {
		return *x.refd655c82a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Tpm2bEvent) Deref() {
	if x.refd655c82a == nil {
		return
	}
	x.Size = (Uint16)(x.refd655c82a.size)
	x.Buffer = *(*[1024]Byte)(unsafe.Pointer(&x.refd655c82a.buffer))
}

// allocTpm2bMaxBufferMemory allocates memory for type C.TPM2B_MAX_BUFFER in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bMaxBufferMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bMaxBufferValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bMaxBufferValue = unsafe.Sizeof([1]C.TPM2B_MAX_BUFFER{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Tpm2bMaxBuffer) Ref() *C.TPM2B_MAX_BUFFER {
	if x == nil {
		return nil
	}
	return x.ref59a18869
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Tpm2bMaxBuffer) Free() {
	if x != nil && x.allocs59a18869 != nil {
		x.allocs59a18869.(*cgoAllocMap).Free()
		x.ref59a18869 = nil
	}
}

// NewTpm2bMaxBufferRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpm2bMaxBufferRef(ref unsafe.Pointer) *Tpm2bMaxBuffer {
	if ref == nil {
		return nil
	}
	obj := new(Tpm2bMaxBuffer)
	obj.ref59a18869 = (*C.TPM2B_MAX_BUFFER)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Tpm2bMaxBuffer) PassRef() (*C.TPM2B_MAX_BUFFER, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref59a18869 != nil {
		return x.ref59a18869, nil
	}
	mem59a18869 := allocTpm2bMaxBufferMemory(1)
	ref59a18869 := (*C.TPM2B_MAX_BUFFER)(mem59a18869)
	allocs59a18869 := new(cgoAllocMap)
	allocs59a18869.Add(mem59a18869)

	var csize_allocs *cgoAllocMap
	ref59a18869.size, csize_allocs = (C.UINT16)(x.Size), cgoAllocsUnknown
	allocs59a18869.Borrow(csize_allocs)

	var cbuffer_allocs *cgoAllocMap
	ref59a18869.buffer, cbuffer_allocs = *(*[1024]C.BYTE)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocs59a18869.Borrow(cbuffer_allocs)

	x.ref59a18869 = ref59a18869
	x.allocs59a18869 = allocs59a18869
	return ref59a18869, allocs59a18869

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Tpm2bMaxBuffer) PassValue() (C.TPM2B_MAX_BUFFER, *cgoAllocMap) {
	if x.ref59a18869 != nil {
		return *x.ref59a18869, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Tpm2bMaxBuffer) Deref() {
	if x.ref59a18869 == nil {
		return
	}
	x.Size = (Uint16)(x.ref59a18869.size)
	x.Buffer = *(*[1024]Byte)(unsafe.Pointer(&x.ref59a18869.buffer))
}

// allocTpm2bMaxNvBufferMemory allocates memory for type C.TPM2B_MAX_NV_BUFFER in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bMaxNvBufferMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bMaxNvBufferValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bMaxNvBufferValue = unsafe.Sizeof([1]C.TPM2B_MAX_NV_BUFFER{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Tpm2bMaxNvBuffer) Ref() *C.TPM2B_MAX_NV_BUFFER {
	if x == nil {
		return nil
	}
	return x.ref2847ea85
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Tpm2bMaxNvBuffer) Free() {
	if x != nil && x.allocs2847ea85 != nil {
		x.allocs2847ea85.(*cgoAllocMap).Free()
		x.ref2847ea85 = nil
	}
}

// NewTpm2bMaxNvBufferRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpm2bMaxNvBufferRef(ref unsafe.Pointer) *Tpm2bMaxNvBuffer {
	if ref == nil {
		return nil
	}
	obj := new(Tpm2bMaxNvBuffer)
	obj.ref2847ea85 = (*C.TPM2B_MAX_NV_BUFFER)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Tpm2bMaxNvBuffer) PassRef() (*C.TPM2B_MAX_NV_BUFFER, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2847ea85 != nil {
		return x.ref2847ea85, nil
	}
	mem2847ea85 := allocTpm2bMaxNvBufferMemory(1)
	ref2847ea85 := (*C.TPM2B_MAX_NV_BUFFER)(mem2847ea85)
	allocs2847ea85 := new(cgoAllocMap)
	allocs2847ea85.Add(mem2847ea85)

	var csize_allocs *cgoAllocMap
	ref2847ea85.size, csize_allocs = (C.UINT16)(x.Size), cgoAllocsUnknown
	allocs2847ea85.Borrow(csize_allocs)

	var cbuffer_allocs *cgoAllocMap
	ref2847ea85.buffer, cbuffer_allocs = *(*[2048]C.BYTE)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocs2847ea85.Borrow(cbuffer_allocs)

	x.ref2847ea85 = ref2847ea85
	x.allocs2847ea85 = allocs2847ea85
	return ref2847ea85, allocs2847ea85

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Tpm2bMaxNvBuffer) PassValue() (C.TPM2B_MAX_NV_BUFFER, *cgoAllocMap) {
	if x.ref2847ea85 != nil {
		return *x.ref2847ea85, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Tpm2bMaxNvBuffer) Deref() {
	if x.ref2847ea85 == nil {
		return
	}
	x.Size = (Uint16)(x.ref2847ea85.size)
	x.Buffer = *(*[2048]Byte)(unsafe.Pointer(&x.ref2847ea85.buffer))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Tpm2bTimeout) Ref() *C.TPM2B_DIGEST {
	if x == nil {
		return nil
	}
	return x.refa5988425
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Tpm2bTimeout) Free() {
	if x != nil && x.allocsa5988425 != nil {
		x.allocsa5988425.(*cgoAllocMap).Free()
		x.refa5988425 = nil
	}
}

// NewTpm2bTimeoutRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpm2bTimeoutRef(ref unsafe.Pointer) *Tpm2bTimeout {
	if ref == nil {
		return nil
	}
	obj := new(Tpm2bTimeout)
	obj.refa5988425 = (*C.TPM2B_DIGEST)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Tpm2bTimeout) PassRef() (*C.TPM2B_DIGEST, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa5988425 != nil {
		return x.refa5988425, nil
	}
	mema5988425 := allocTpm2bDigestMemory(1)
	refa5988425 := (*C.TPM2B_DIGEST)(mema5988425)
	allocsa5988425 := new(cgoAllocMap)
	allocsa5988425.Add(mema5988425)

	var csize_allocs *cgoAllocMap
	refa5988425.size, csize_allocs = (C.UINT16)(x.Size), cgoAllocsUnknown
	allocsa5988425.Borrow(csize_allocs)

	var cbuffer_allocs *cgoAllocMap
	refa5988425.buffer, cbuffer_allocs = *(*[64]C.BYTE)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocsa5988425.Borrow(cbuffer_allocs)

	x.refa5988425 = refa5988425
	x.allocsa5988425 = allocsa5988425
	return refa5988425, allocsa5988425

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Tpm2bTimeout) PassValue() (C.TPM2B_DIGEST, *cgoAllocMap) {
	if x.refa5988425 != nil {
		return *x.refa5988425, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Tpm2bTimeout) Deref() {
	if x.refa5988425 == nil {
		return
	}
	x.Size = (Uint16)(x.refa5988425.size)
	x.Buffer = *(*[64]Byte)(unsafe.Pointer(&x.refa5988425.buffer))
}

// allocTpm2bIvMemory allocates memory for type C.TPM2B_IV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bIvMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bIvValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bIvValue = unsafe.Sizeof([1]C.TPM2B_IV{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Tpm2bIv) Ref() *C.TPM2B_IV {
	if x == nil {
		return nil
	}
	return x.refaf2c000
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Tpm2bIv) Free() {
	if x != nil && x.allocsaf2c000 != nil {
		x.allocsaf2c000.(*cgoAllocMap).Free()
		x.refaf2c000 = nil
	}
}

// NewTpm2bIvRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpm2bIvRef(ref unsafe.Pointer) *Tpm2bIv {
	if ref == nil {
		return nil
	}
	obj := new(Tpm2bIv)
	obj.refaf2c000 = (*C.TPM2B_IV)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Tpm2bIv) PassRef() (*C.TPM2B_IV, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refaf2c000 != nil {
		return x.refaf2c000, nil
	}
	memaf2c000 := allocTpm2bIvMemory(1)
	refaf2c000 := (*C.TPM2B_IV)(memaf2c000)
	allocsaf2c000 := new(cgoAllocMap)
	allocsaf2c000.Add(memaf2c000)

	var csize_allocs *cgoAllocMap
	refaf2c000.size, csize_allocs = (C.UINT16)(x.Size), cgoAllocsUnknown
	allocsaf2c000.Borrow(csize_allocs)

	var cbuffer_allocs *cgoAllocMap
	refaf2c000.buffer, cbuffer_allocs = *(*[16]C.BYTE)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocsaf2c000.Borrow(cbuffer_allocs)

	x.refaf2c000 = refaf2c000
	x.allocsaf2c000 = allocsaf2c000
	return refaf2c000, allocsaf2c000

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Tpm2bIv) PassValue() (C.TPM2B_IV, *cgoAllocMap) {
	if x.refaf2c000 != nil {
		return *x.refaf2c000, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Tpm2bIv) Deref() {
	if x.refaf2c000 == nil {
		return
	}
	x.Size = (Uint16)(x.refaf2c000.size)
	x.Buffer = *(*[16]Byte)(unsafe.Pointer(&x.refaf2c000.buffer))
}

// allocTpm2bNameMemory allocates memory for type C.TPM2B_NAME in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bNameMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bNameValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bNameValue = unsafe.Sizeof([1]C.TPM2B_NAME{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Tpm2bName) Ref() *C.TPM2B_NAME {
	if x == nil {
		return nil
	}
	return x.ref1d62d3a6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Tpm2bName) Free() {
	if x != nil && x.allocs1d62d3a6 != nil {
		x.allocs1d62d3a6.(*cgoAllocMap).Free()
		x.ref1d62d3a6 = nil
	}
}

// NewTpm2bNameRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpm2bNameRef(ref unsafe.Pointer) *Tpm2bName {
	if ref == nil {
		return nil
	}
	obj := new(Tpm2bName)
	obj.ref1d62d3a6 = (*C.TPM2B_NAME)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Tpm2bName) PassRef() (*C.TPM2B_NAME, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1d62d3a6 != nil {
		return x.ref1d62d3a6, nil
	}
	mem1d62d3a6 := allocTpm2bNameMemory(1)
	ref1d62d3a6 := (*C.TPM2B_NAME)(mem1d62d3a6)
	allocs1d62d3a6 := new(cgoAllocMap)
	allocs1d62d3a6.Add(mem1d62d3a6)

	var csize_allocs *cgoAllocMap
	ref1d62d3a6.size, csize_allocs = (C.UINT16)(x.Size), cgoAllocsUnknown
	allocs1d62d3a6.Borrow(csize_allocs)

	var cname_allocs *cgoAllocMap
	ref1d62d3a6.name, cname_allocs = *(*[68]C.BYTE)(unsafe.Pointer(&x.Name)), cgoAllocsUnknown
	allocs1d62d3a6.Borrow(cname_allocs)

	x.ref1d62d3a6 = ref1d62d3a6
	x.allocs1d62d3a6 = allocs1d62d3a6
	return ref1d62d3a6, allocs1d62d3a6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Tpm2bName) PassValue() (C.TPM2B_NAME, *cgoAllocMap) {
	if x.ref1d62d3a6 != nil {
		return *x.ref1d62d3a6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Tpm2bName) Deref() {
	if x.ref1d62d3a6 == nil {
		return
	}
	x.Size = (Uint16)(x.ref1d62d3a6.size)
	x.Name = *(*[68]Byte)(unsafe.Pointer(&x.ref1d62d3a6.name))
}

// allocTpmsPcrSelectMemory allocates memory for type C.TPMS_PCR_SELECT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsPcrSelectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsPcrSelectValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsPcrSelectValue = unsafe.Sizeof([1]C.TPMS_PCR_SELECT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsPcrSelect) Ref() *C.TPMS_PCR_SELECT {
	if x == nil {
		return nil
	}
	return x.ref3862416a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsPcrSelect) Free() {
	if x != nil && x.allocs3862416a != nil {
		x.allocs3862416a.(*cgoAllocMap).Free()
		x.ref3862416a = nil
	}
}

// NewTpmsPcrSelectRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsPcrSelectRef(ref unsafe.Pointer) *TpmsPcrSelect {
	if ref == nil {
		return nil
	}
	obj := new(TpmsPcrSelect)
	obj.ref3862416a = (*C.TPMS_PCR_SELECT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsPcrSelect) PassRef() (*C.TPMS_PCR_SELECT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3862416a != nil {
		return x.ref3862416a, nil
	}
	mem3862416a := allocTpmsPcrSelectMemory(1)
	ref3862416a := (*C.TPMS_PCR_SELECT)(mem3862416a)
	allocs3862416a := new(cgoAllocMap)
	allocs3862416a.Add(mem3862416a)

	var csizeofSelect_allocs *cgoAllocMap
	ref3862416a.sizeofSelect, csizeofSelect_allocs = (C.UINT8)(x.Sizeofselect), cgoAllocsUnknown
	allocs3862416a.Borrow(csizeofSelect_allocs)

	var cpcrSelect_allocs *cgoAllocMap
	ref3862416a.pcrSelect, cpcrSelect_allocs = *(*[4]C.BYTE)(unsafe.Pointer(&x.Pcrselect)), cgoAllocsUnknown
	allocs3862416a.Borrow(cpcrSelect_allocs)

	x.ref3862416a = ref3862416a
	x.allocs3862416a = allocs3862416a
	return ref3862416a, allocs3862416a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsPcrSelect) PassValue() (C.TPMS_PCR_SELECT, *cgoAllocMap) {
	if x.ref3862416a != nil {
		return *x.ref3862416a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsPcrSelect) Deref() {
	if x.ref3862416a == nil {
		return
	}
	x.Sizeofselect = (Uint8)(x.ref3862416a.sizeofSelect)
	x.Pcrselect = *(*[4]Byte)(unsafe.Pointer(&x.ref3862416a.pcrSelect))
}

// allocTpmsPcrSelectionMemory allocates memory for type C.TPMS_PCR_SELECTION in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsPcrSelectionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsPcrSelectionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsPcrSelectionValue = unsafe.Sizeof([1]C.TPMS_PCR_SELECTION{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsPcrSelection) Ref() *C.TPMS_PCR_SELECTION {
	if x == nil {
		return nil
	}
	return x.ref691160fe
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsPcrSelection) Free() {
	if x != nil && x.allocs691160fe != nil {
		x.allocs691160fe.(*cgoAllocMap).Free()
		x.ref691160fe = nil
	}
}

// NewTpmsPcrSelectionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsPcrSelectionRef(ref unsafe.Pointer) *TpmsPcrSelection {
	if ref == nil {
		return nil
	}
	obj := new(TpmsPcrSelection)
	obj.ref691160fe = (*C.TPMS_PCR_SELECTION)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsPcrSelection) PassRef() (*C.TPMS_PCR_SELECTION, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref691160fe != nil {
		return x.ref691160fe, nil
	}
	mem691160fe := allocTpmsPcrSelectionMemory(1)
	ref691160fe := (*C.TPMS_PCR_SELECTION)(mem691160fe)
	allocs691160fe := new(cgoAllocMap)
	allocs691160fe.Add(mem691160fe)

	var chash_allocs *cgoAllocMap
	ref691160fe.hash, chash_allocs = (C.TPMI_ALG_HASH)(x.Hash), cgoAllocsUnknown
	allocs691160fe.Borrow(chash_allocs)

	var csizeofSelect_allocs *cgoAllocMap
	ref691160fe.sizeofSelect, csizeofSelect_allocs = (C.UINT8)(x.Sizeofselect), cgoAllocsUnknown
	allocs691160fe.Borrow(csizeofSelect_allocs)

	var cpcrSelect_allocs *cgoAllocMap
	ref691160fe.pcrSelect, cpcrSelect_allocs = *(*[4]C.BYTE)(unsafe.Pointer(&x.Pcrselect)), cgoAllocsUnknown
	allocs691160fe.Borrow(cpcrSelect_allocs)

	x.ref691160fe = ref691160fe
	x.allocs691160fe = allocs691160fe
	return ref691160fe, allocs691160fe

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsPcrSelection) PassValue() (C.TPMS_PCR_SELECTION, *cgoAllocMap) {
	if x.ref691160fe != nil {
		return *x.ref691160fe, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsPcrSelection) Deref() {
	if x.ref691160fe == nil {
		return
	}
	x.Hash = (TpmiAlgHash)(x.ref691160fe.hash)
	x.Sizeofselect = (Uint8)(x.ref691160fe.sizeofSelect)
	x.Pcrselect = *(*[4]Byte)(unsafe.Pointer(&x.ref691160fe.pcrSelect))
}

// allocTpmtTkCreationMemory allocates memory for type C.TPMT_TK_CREATION in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtTkCreationMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtTkCreationValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtTkCreationValue = unsafe.Sizeof([1]C.TPMT_TK_CREATION{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmtTkCreation) Ref() *C.TPMT_TK_CREATION {
	if x == nil {
		return nil
	}
	return x.reff8fc2eb3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmtTkCreation) Free() {
	if x != nil && x.allocsf8fc2eb3 != nil {
		x.allocsf8fc2eb3.(*cgoAllocMap).Free()
		x.reff8fc2eb3 = nil
	}
}

// NewTpmtTkCreationRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmtTkCreationRef(ref unsafe.Pointer) *TpmtTkCreation {
	if ref == nil {
		return nil
	}
	obj := new(TpmtTkCreation)
	obj.reff8fc2eb3 = (*C.TPMT_TK_CREATION)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmtTkCreation) PassRef() (*C.TPMT_TK_CREATION, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff8fc2eb3 != nil {
		return x.reff8fc2eb3, nil
	}
	memf8fc2eb3 := allocTpmtTkCreationMemory(1)
	reff8fc2eb3 := (*C.TPMT_TK_CREATION)(memf8fc2eb3)
	allocsf8fc2eb3 := new(cgoAllocMap)
	allocsf8fc2eb3.Add(memf8fc2eb3)

	var ctag_allocs *cgoAllocMap
	reff8fc2eb3.tag, ctag_allocs = (C.TPM2_ST)(x.Tag), cgoAllocsUnknown
	allocsf8fc2eb3.Borrow(ctag_allocs)

	var chierarchy_allocs *cgoAllocMap
	reff8fc2eb3.hierarchy, chierarchy_allocs = (C.TPMI_RH_HIERARCHY)(x.Hierarchy), cgoAllocsUnknown
	allocsf8fc2eb3.Borrow(chierarchy_allocs)

	var cdigest_allocs *cgoAllocMap
	reff8fc2eb3.digest, cdigest_allocs = x.Digest.PassValue()
	allocsf8fc2eb3.Borrow(cdigest_allocs)

	x.reff8fc2eb3 = reff8fc2eb3
	x.allocsf8fc2eb3 = allocsf8fc2eb3
	return reff8fc2eb3, allocsf8fc2eb3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmtTkCreation) PassValue() (C.TPMT_TK_CREATION, *cgoAllocMap) {
	if x.reff8fc2eb3 != nil {
		return *x.reff8fc2eb3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmtTkCreation) Deref() {
	if x.reff8fc2eb3 == nil {
		return
	}
	x.Tag = (Tpm2St)(x.reff8fc2eb3.tag)
	x.Hierarchy = (TpmiRhHierarchy)(x.reff8fc2eb3.hierarchy)
	x.Digest = *NewTpm2bDigestRef(unsafe.Pointer(&x.reff8fc2eb3.digest))
}

// allocTpmtTkVerifiedMemory allocates memory for type C.TPMT_TK_VERIFIED in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtTkVerifiedMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtTkVerifiedValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtTkVerifiedValue = unsafe.Sizeof([1]C.TPMT_TK_VERIFIED{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmtTkVerified) Ref() *C.TPMT_TK_VERIFIED {
	if x == nil {
		return nil
	}
	return x.refa05754de
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmtTkVerified) Free() {
	if x != nil && x.allocsa05754de != nil {
		x.allocsa05754de.(*cgoAllocMap).Free()
		x.refa05754de = nil
	}
}

// NewTpmtTkVerifiedRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmtTkVerifiedRef(ref unsafe.Pointer) *TpmtTkVerified {
	if ref == nil {
		return nil
	}
	obj := new(TpmtTkVerified)
	obj.refa05754de = (*C.TPMT_TK_VERIFIED)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmtTkVerified) PassRef() (*C.TPMT_TK_VERIFIED, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa05754de != nil {
		return x.refa05754de, nil
	}
	mema05754de := allocTpmtTkVerifiedMemory(1)
	refa05754de := (*C.TPMT_TK_VERIFIED)(mema05754de)
	allocsa05754de := new(cgoAllocMap)
	allocsa05754de.Add(mema05754de)

	var ctag_allocs *cgoAllocMap
	refa05754de.tag, ctag_allocs = (C.TPM2_ST)(x.Tag), cgoAllocsUnknown
	allocsa05754de.Borrow(ctag_allocs)

	var chierarchy_allocs *cgoAllocMap
	refa05754de.hierarchy, chierarchy_allocs = (C.TPMI_RH_HIERARCHY)(x.Hierarchy), cgoAllocsUnknown
	allocsa05754de.Borrow(chierarchy_allocs)

	var cdigest_allocs *cgoAllocMap
	refa05754de.digest, cdigest_allocs = x.Digest.PassValue()
	allocsa05754de.Borrow(cdigest_allocs)

	x.refa05754de = refa05754de
	x.allocsa05754de = allocsa05754de
	return refa05754de, allocsa05754de

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmtTkVerified) PassValue() (C.TPMT_TK_VERIFIED, *cgoAllocMap) {
	if x.refa05754de != nil {
		return *x.refa05754de, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmtTkVerified) Deref() {
	if x.refa05754de == nil {
		return
	}
	x.Tag = (Tpm2St)(x.refa05754de.tag)
	x.Hierarchy = (TpmiRhHierarchy)(x.refa05754de.hierarchy)
	x.Digest = *NewTpm2bDigestRef(unsafe.Pointer(&x.refa05754de.digest))
}

// allocTpmtTkAuthMemory allocates memory for type C.TPMT_TK_AUTH in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtTkAuthMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtTkAuthValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtTkAuthValue = unsafe.Sizeof([1]C.TPMT_TK_AUTH{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmtTkAuth) Ref() *C.TPMT_TK_AUTH {
	if x == nil {
		return nil
	}
	return x.ref13a3ead8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmtTkAuth) Free() {
	if x != nil && x.allocs13a3ead8 != nil {
		x.allocs13a3ead8.(*cgoAllocMap).Free()
		x.ref13a3ead8 = nil
	}
}

// NewTpmtTkAuthRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmtTkAuthRef(ref unsafe.Pointer) *TpmtTkAuth {
	if ref == nil {
		return nil
	}
	obj := new(TpmtTkAuth)
	obj.ref13a3ead8 = (*C.TPMT_TK_AUTH)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmtTkAuth) PassRef() (*C.TPMT_TK_AUTH, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref13a3ead8 != nil {
		return x.ref13a3ead8, nil
	}
	mem13a3ead8 := allocTpmtTkAuthMemory(1)
	ref13a3ead8 := (*C.TPMT_TK_AUTH)(mem13a3ead8)
	allocs13a3ead8 := new(cgoAllocMap)
	allocs13a3ead8.Add(mem13a3ead8)

	var ctag_allocs *cgoAllocMap
	ref13a3ead8.tag, ctag_allocs = (C.TPM2_ST)(x.Tag), cgoAllocsUnknown
	allocs13a3ead8.Borrow(ctag_allocs)

	var chierarchy_allocs *cgoAllocMap
	ref13a3ead8.hierarchy, chierarchy_allocs = (C.TPMI_RH_HIERARCHY)(x.Hierarchy), cgoAllocsUnknown
	allocs13a3ead8.Borrow(chierarchy_allocs)

	var cdigest_allocs *cgoAllocMap
	ref13a3ead8.digest, cdigest_allocs = x.Digest.PassValue()
	allocs13a3ead8.Borrow(cdigest_allocs)

	x.ref13a3ead8 = ref13a3ead8
	x.allocs13a3ead8 = allocs13a3ead8
	return ref13a3ead8, allocs13a3ead8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmtTkAuth) PassValue() (C.TPMT_TK_AUTH, *cgoAllocMap) {
	if x.ref13a3ead8 != nil {
		return *x.ref13a3ead8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmtTkAuth) Deref() {
	if x.ref13a3ead8 == nil {
		return
	}
	x.Tag = (Tpm2St)(x.ref13a3ead8.tag)
	x.Hierarchy = (TpmiRhHierarchy)(x.ref13a3ead8.hierarchy)
	x.Digest = *NewTpm2bDigestRef(unsafe.Pointer(&x.ref13a3ead8.digest))
}

// allocTpmtTkHashcheckMemory allocates memory for type C.TPMT_TK_HASHCHECK in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtTkHashcheckMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtTkHashcheckValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtTkHashcheckValue = unsafe.Sizeof([1]C.TPMT_TK_HASHCHECK{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmtTkHashcheck) Ref() *C.TPMT_TK_HASHCHECK {
	if x == nil {
		return nil
	}
	return x.refe0b9eec8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmtTkHashcheck) Free() {
	if x != nil && x.allocse0b9eec8 != nil {
		x.allocse0b9eec8.(*cgoAllocMap).Free()
		x.refe0b9eec8 = nil
	}
}

// NewTpmtTkHashcheckRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmtTkHashcheckRef(ref unsafe.Pointer) *TpmtTkHashcheck {
	if ref == nil {
		return nil
	}
	obj := new(TpmtTkHashcheck)
	obj.refe0b9eec8 = (*C.TPMT_TK_HASHCHECK)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmtTkHashcheck) PassRef() (*C.TPMT_TK_HASHCHECK, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe0b9eec8 != nil {
		return x.refe0b9eec8, nil
	}
	meme0b9eec8 := allocTpmtTkHashcheckMemory(1)
	refe0b9eec8 := (*C.TPMT_TK_HASHCHECK)(meme0b9eec8)
	allocse0b9eec8 := new(cgoAllocMap)
	allocse0b9eec8.Add(meme0b9eec8)

	var ctag_allocs *cgoAllocMap
	refe0b9eec8.tag, ctag_allocs = (C.TPM2_ST)(x.Tag), cgoAllocsUnknown
	allocse0b9eec8.Borrow(ctag_allocs)

	var chierarchy_allocs *cgoAllocMap
	refe0b9eec8.hierarchy, chierarchy_allocs = (C.TPMI_RH_HIERARCHY)(x.Hierarchy), cgoAllocsUnknown
	allocse0b9eec8.Borrow(chierarchy_allocs)

	var cdigest_allocs *cgoAllocMap
	refe0b9eec8.digest, cdigest_allocs = x.Digest.PassValue()
	allocse0b9eec8.Borrow(cdigest_allocs)

	x.refe0b9eec8 = refe0b9eec8
	x.allocse0b9eec8 = allocse0b9eec8
	return refe0b9eec8, allocse0b9eec8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmtTkHashcheck) PassValue() (C.TPMT_TK_HASHCHECK, *cgoAllocMap) {
	if x.refe0b9eec8 != nil {
		return *x.refe0b9eec8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmtTkHashcheck) Deref() {
	if x.refe0b9eec8 == nil {
		return
	}
	x.Tag = (Tpm2St)(x.refe0b9eec8.tag)
	x.Hierarchy = (TpmiRhHierarchy)(x.refe0b9eec8.hierarchy)
	x.Digest = *NewTpm2bDigestRef(unsafe.Pointer(&x.refe0b9eec8.digest))
}

// allocTpmsAlgPropertyMemory allocates memory for type C.TPMS_ALG_PROPERTY in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsAlgPropertyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsAlgPropertyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsAlgPropertyValue = unsafe.Sizeof([1]C.TPMS_ALG_PROPERTY{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsAlgProperty) Ref() *C.TPMS_ALG_PROPERTY {
	if x == nil {
		return nil
	}
	return x.reff5365ade
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsAlgProperty) Free() {
	if x != nil && x.allocsf5365ade != nil {
		x.allocsf5365ade.(*cgoAllocMap).Free()
		x.reff5365ade = nil
	}
}

// NewTpmsAlgPropertyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsAlgPropertyRef(ref unsafe.Pointer) *TpmsAlgProperty {
	if ref == nil {
		return nil
	}
	obj := new(TpmsAlgProperty)
	obj.reff5365ade = (*C.TPMS_ALG_PROPERTY)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsAlgProperty) PassRef() (*C.TPMS_ALG_PROPERTY, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff5365ade != nil {
		return x.reff5365ade, nil
	}
	memf5365ade := allocTpmsAlgPropertyMemory(1)
	reff5365ade := (*C.TPMS_ALG_PROPERTY)(memf5365ade)
	allocsf5365ade := new(cgoAllocMap)
	allocsf5365ade.Add(memf5365ade)

	var calg_allocs *cgoAllocMap
	reff5365ade.alg, calg_allocs = (C.TPM2_ALG_ID)(x.Alg), cgoAllocsUnknown
	allocsf5365ade.Borrow(calg_allocs)

	var calgProperties_allocs *cgoAllocMap
	reff5365ade.algProperties, calgProperties_allocs = (C.TPMA_ALGORITHM)(x.Algproperties), cgoAllocsUnknown
	allocsf5365ade.Borrow(calgProperties_allocs)

	x.reff5365ade = reff5365ade
	x.allocsf5365ade = allocsf5365ade
	return reff5365ade, allocsf5365ade

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsAlgProperty) PassValue() (C.TPMS_ALG_PROPERTY, *cgoAllocMap) {
	if x.reff5365ade != nil {
		return *x.reff5365ade, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsAlgProperty) Deref() {
	if x.reff5365ade == nil {
		return
	}
	x.Alg = (Tpm2AlgId)(x.reff5365ade.alg)
	x.Algproperties = (TpmaAlgorithm)(x.reff5365ade.algProperties)
}

// allocTpmsTaggedPropertyMemory allocates memory for type C.TPMS_TAGGED_PROPERTY in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsTaggedPropertyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsTaggedPropertyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsTaggedPropertyValue = unsafe.Sizeof([1]C.TPMS_TAGGED_PROPERTY{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsTaggedProperty) Ref() *C.TPMS_TAGGED_PROPERTY {
	if x == nil {
		return nil
	}
	return x.ref3544866c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsTaggedProperty) Free() {
	if x != nil && x.allocs3544866c != nil {
		x.allocs3544866c.(*cgoAllocMap).Free()
		x.ref3544866c = nil
	}
}

// NewTpmsTaggedPropertyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsTaggedPropertyRef(ref unsafe.Pointer) *TpmsTaggedProperty {
	if ref == nil {
		return nil
	}
	obj := new(TpmsTaggedProperty)
	obj.ref3544866c = (*C.TPMS_TAGGED_PROPERTY)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsTaggedProperty) PassRef() (*C.TPMS_TAGGED_PROPERTY, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3544866c != nil {
		return x.ref3544866c, nil
	}
	mem3544866c := allocTpmsTaggedPropertyMemory(1)
	ref3544866c := (*C.TPMS_TAGGED_PROPERTY)(mem3544866c)
	allocs3544866c := new(cgoAllocMap)
	allocs3544866c.Add(mem3544866c)

	var cproperty_allocs *cgoAllocMap
	ref3544866c.property, cproperty_allocs = (C.TPM2_PT)(x.Property), cgoAllocsUnknown
	allocs3544866c.Borrow(cproperty_allocs)

	var cvalue_allocs *cgoAllocMap
	ref3544866c.value, cvalue_allocs = (C.UINT32)(x.Value), cgoAllocsUnknown
	allocs3544866c.Borrow(cvalue_allocs)

	x.ref3544866c = ref3544866c
	x.allocs3544866c = allocs3544866c
	return ref3544866c, allocs3544866c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsTaggedProperty) PassValue() (C.TPMS_TAGGED_PROPERTY, *cgoAllocMap) {
	if x.ref3544866c != nil {
		return *x.ref3544866c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsTaggedProperty) Deref() {
	if x.ref3544866c == nil {
		return
	}
	x.Property = (Tpm2Pt)(x.ref3544866c.property)
	x.Value = (Uint32)(x.ref3544866c.value)
}

// allocTpmsTaggedPcrSelectMemory allocates memory for type C.TPMS_TAGGED_PCR_SELECT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsTaggedPcrSelectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsTaggedPcrSelectValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsTaggedPcrSelectValue = unsafe.Sizeof([1]C.TPMS_TAGGED_PCR_SELECT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsTaggedPcrSelect) Ref() *C.TPMS_TAGGED_PCR_SELECT {
	if x == nil {
		return nil
	}
	return x.ref168b217f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsTaggedPcrSelect) Free() {
	if x != nil && x.allocs168b217f != nil {
		x.allocs168b217f.(*cgoAllocMap).Free()
		x.ref168b217f = nil
	}
}

// NewTpmsTaggedPcrSelectRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsTaggedPcrSelectRef(ref unsafe.Pointer) *TpmsTaggedPcrSelect {
	if ref == nil {
		return nil
	}
	obj := new(TpmsTaggedPcrSelect)
	obj.ref168b217f = (*C.TPMS_TAGGED_PCR_SELECT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsTaggedPcrSelect) PassRef() (*C.TPMS_TAGGED_PCR_SELECT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref168b217f != nil {
		return x.ref168b217f, nil
	}
	mem168b217f := allocTpmsTaggedPcrSelectMemory(1)
	ref168b217f := (*C.TPMS_TAGGED_PCR_SELECT)(mem168b217f)
	allocs168b217f := new(cgoAllocMap)
	allocs168b217f.Add(mem168b217f)

	var ctag_allocs *cgoAllocMap
	ref168b217f.tag, ctag_allocs = (C.TPM2_PT_PCR)(x.Tag), cgoAllocsUnknown
	allocs168b217f.Borrow(ctag_allocs)

	var csizeofSelect_allocs *cgoAllocMap
	ref168b217f.sizeofSelect, csizeofSelect_allocs = (C.UINT8)(x.Sizeofselect), cgoAllocsUnknown
	allocs168b217f.Borrow(csizeofSelect_allocs)

	var cpcrSelect_allocs *cgoAllocMap
	ref168b217f.pcrSelect, cpcrSelect_allocs = *(*[4]C.BYTE)(unsafe.Pointer(&x.Pcrselect)), cgoAllocsUnknown
	allocs168b217f.Borrow(cpcrSelect_allocs)

	x.ref168b217f = ref168b217f
	x.allocs168b217f = allocs168b217f
	return ref168b217f, allocs168b217f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsTaggedPcrSelect) PassValue() (C.TPMS_TAGGED_PCR_SELECT, *cgoAllocMap) {
	if x.ref168b217f != nil {
		return *x.ref168b217f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsTaggedPcrSelect) Deref() {
	if x.ref168b217f == nil {
		return
	}
	x.Tag = (Tpm2PtPcr)(x.ref168b217f.tag)
	x.Sizeofselect = (Uint8)(x.ref168b217f.sizeofSelect)
	x.Pcrselect = *(*[4]Byte)(unsafe.Pointer(&x.ref168b217f.pcrSelect))
}

// allocTpmsTaggedPolicyMemory allocates memory for type C.TPMS_TAGGED_POLICY in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsTaggedPolicyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsTaggedPolicyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsTaggedPolicyValue = unsafe.Sizeof([1]C.TPMS_TAGGED_POLICY{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsTaggedPolicy) Ref() *C.TPMS_TAGGED_POLICY {
	if x == nil {
		return nil
	}
	return x.refc72d4bc6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsTaggedPolicy) Free() {
	if x != nil && x.allocsc72d4bc6 != nil {
		x.allocsc72d4bc6.(*cgoAllocMap).Free()
		x.refc72d4bc6 = nil
	}
}

// NewTpmsTaggedPolicyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsTaggedPolicyRef(ref unsafe.Pointer) *TpmsTaggedPolicy {
	if ref == nil {
		return nil
	}
	obj := new(TpmsTaggedPolicy)
	obj.refc72d4bc6 = (*C.TPMS_TAGGED_POLICY)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsTaggedPolicy) PassRef() (*C.TPMS_TAGGED_POLICY, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc72d4bc6 != nil {
		return x.refc72d4bc6, nil
	}
	memc72d4bc6 := allocTpmsTaggedPolicyMemory(1)
	refc72d4bc6 := (*C.TPMS_TAGGED_POLICY)(memc72d4bc6)
	allocsc72d4bc6 := new(cgoAllocMap)
	allocsc72d4bc6.Add(memc72d4bc6)

	var chandle_allocs *cgoAllocMap
	refc72d4bc6.handle, chandle_allocs = (C.TPM2_HANDLE)(x.Handle), cgoAllocsUnknown
	allocsc72d4bc6.Borrow(chandle_allocs)

	var cpolicyHash_allocs *cgoAllocMap
	refc72d4bc6.policyHash, cpolicyHash_allocs = x.Policyhash.PassValue()
	allocsc72d4bc6.Borrow(cpolicyHash_allocs)

	x.refc72d4bc6 = refc72d4bc6
	x.allocsc72d4bc6 = allocsc72d4bc6
	return refc72d4bc6, allocsc72d4bc6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsTaggedPolicy) PassValue() (C.TPMS_TAGGED_POLICY, *cgoAllocMap) {
	if x.refc72d4bc6 != nil {
		return *x.refc72d4bc6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsTaggedPolicy) Deref() {
	if x.refc72d4bc6 == nil {
		return
	}
	x.Handle = (Tpm2Handle)(x.refc72d4bc6.handle)
	x.Policyhash = *NewTpmtHaRef(unsafe.Pointer(&x.refc72d4bc6.policyHash))
}

// allocTpmlCcMemory allocates memory for type C.TPML_CC in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmlCcMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmlCcValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmlCcValue = unsafe.Sizeof([1]C.TPML_CC{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmlCc) Ref() *C.TPML_CC {
	if x == nil {
		return nil
	}
	return x.ref64b80431
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmlCc) Free() {
	if x != nil && x.allocs64b80431 != nil {
		x.allocs64b80431.(*cgoAllocMap).Free()
		x.ref64b80431 = nil
	}
}

// NewTpmlCcRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmlCcRef(ref unsafe.Pointer) *TpmlCc {
	if ref == nil {
		return nil
	}
	obj := new(TpmlCc)
	obj.ref64b80431 = (*C.TPML_CC)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmlCc) PassRef() (*C.TPML_CC, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref64b80431 != nil {
		return x.ref64b80431, nil
	}
	mem64b80431 := allocTpmlCcMemory(1)
	ref64b80431 := (*C.TPML_CC)(mem64b80431)
	allocs64b80431 := new(cgoAllocMap)
	allocs64b80431.Add(mem64b80431)

	var ccount_allocs *cgoAllocMap
	ref64b80431.count, ccount_allocs = (C.UINT32)(x.Count), cgoAllocsUnknown
	allocs64b80431.Borrow(ccount_allocs)

	var ccommandCodes_allocs *cgoAllocMap
	ref64b80431.commandCodes, ccommandCodes_allocs = *(*[256]C.TPM2_CC)(unsafe.Pointer(&x.Commandcodes)), cgoAllocsUnknown
	allocs64b80431.Borrow(ccommandCodes_allocs)

	x.ref64b80431 = ref64b80431
	x.allocs64b80431 = allocs64b80431
	return ref64b80431, allocs64b80431

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmlCc) PassValue() (C.TPML_CC, *cgoAllocMap) {
	if x.ref64b80431 != nil {
		return *x.ref64b80431, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmlCc) Deref() {
	if x.ref64b80431 == nil {
		return
	}
	x.Count = (Uint32)(x.ref64b80431.count)
	x.Commandcodes = *(*[256]Tpm2Cc)(unsafe.Pointer(&x.ref64b80431.commandCodes))
}

// allocTpmlCcaMemory allocates memory for type C.TPML_CCA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmlCcaMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmlCcaValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmlCcaValue = unsafe.Sizeof([1]C.TPML_CCA{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmlCca) Ref() *C.TPML_CCA {
	if x == nil {
		return nil
	}
	return x.ref826326b5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmlCca) Free() {
	if x != nil && x.allocs826326b5 != nil {
		x.allocs826326b5.(*cgoAllocMap).Free()
		x.ref826326b5 = nil
	}
}

// NewTpmlCcaRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmlCcaRef(ref unsafe.Pointer) *TpmlCca {
	if ref == nil {
		return nil
	}
	obj := new(TpmlCca)
	obj.ref826326b5 = (*C.TPML_CCA)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmlCca) PassRef() (*C.TPML_CCA, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref826326b5 != nil {
		return x.ref826326b5, nil
	}
	mem826326b5 := allocTpmlCcaMemory(1)
	ref826326b5 := (*C.TPML_CCA)(mem826326b5)
	allocs826326b5 := new(cgoAllocMap)
	allocs826326b5.Add(mem826326b5)

	var ccount_allocs *cgoAllocMap
	ref826326b5.count, ccount_allocs = (C.UINT32)(x.Count), cgoAllocsUnknown
	allocs826326b5.Borrow(ccount_allocs)

	var ccommandAttributes_allocs *cgoAllocMap
	ref826326b5.commandAttributes, ccommandAttributes_allocs = *(*[256]C.TPMA_CC)(unsafe.Pointer(&x.Commandattributes)), cgoAllocsUnknown
	allocs826326b5.Borrow(ccommandAttributes_allocs)

	x.ref826326b5 = ref826326b5
	x.allocs826326b5 = allocs826326b5
	return ref826326b5, allocs826326b5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmlCca) PassValue() (C.TPML_CCA, *cgoAllocMap) {
	if x.ref826326b5 != nil {
		return *x.ref826326b5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmlCca) Deref() {
	if x.ref826326b5 == nil {
		return
	}
	x.Count = (Uint32)(x.ref826326b5.count)
	x.Commandattributes = *(*[256]TpmaCc)(unsafe.Pointer(&x.ref826326b5.commandAttributes))
}

// allocTpmlAlgMemory allocates memory for type C.TPML_ALG in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmlAlgMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmlAlgValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmlAlgValue = unsafe.Sizeof([1]C.TPML_ALG{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmlAlg) Ref() *C.TPML_ALG {
	if x == nil {
		return nil
	}
	return x.refef1c4b21
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmlAlg) Free() {
	if x != nil && x.allocsef1c4b21 != nil {
		x.allocsef1c4b21.(*cgoAllocMap).Free()
		x.refef1c4b21 = nil
	}
}

// NewTpmlAlgRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmlAlgRef(ref unsafe.Pointer) *TpmlAlg {
	if ref == nil {
		return nil
	}
	obj := new(TpmlAlg)
	obj.refef1c4b21 = (*C.TPML_ALG)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmlAlg) PassRef() (*C.TPML_ALG, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refef1c4b21 != nil {
		return x.refef1c4b21, nil
	}
	memef1c4b21 := allocTpmlAlgMemory(1)
	refef1c4b21 := (*C.TPML_ALG)(memef1c4b21)
	allocsef1c4b21 := new(cgoAllocMap)
	allocsef1c4b21.Add(memef1c4b21)

	var ccount_allocs *cgoAllocMap
	refef1c4b21.count, ccount_allocs = (C.UINT32)(x.Count), cgoAllocsUnknown
	allocsef1c4b21.Borrow(ccount_allocs)

	var calgorithms_allocs *cgoAllocMap
	refef1c4b21.algorithms, calgorithms_allocs = *(*[128]C.TPM2_ALG_ID)(unsafe.Pointer(&x.Algorithms)), cgoAllocsUnknown
	allocsef1c4b21.Borrow(calgorithms_allocs)

	x.refef1c4b21 = refef1c4b21
	x.allocsef1c4b21 = allocsef1c4b21
	return refef1c4b21, allocsef1c4b21

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmlAlg) PassValue() (C.TPML_ALG, *cgoAllocMap) {
	if x.refef1c4b21 != nil {
		return *x.refef1c4b21, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmlAlg) Deref() {
	if x.refef1c4b21 == nil {
		return
	}
	x.Count = (Uint32)(x.refef1c4b21.count)
	x.Algorithms = *(*[128]Tpm2AlgId)(unsafe.Pointer(&x.refef1c4b21.algorithms))
}

// allocTpmlHandleMemory allocates memory for type C.TPML_HANDLE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmlHandleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmlHandleValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmlHandleValue = unsafe.Sizeof([1]C.TPML_HANDLE{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmlHandle) Ref() *C.TPML_HANDLE {
	if x == nil {
		return nil
	}
	return x.ref4e3c7552
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmlHandle) Free() {
	if x != nil && x.allocs4e3c7552 != nil {
		x.allocs4e3c7552.(*cgoAllocMap).Free()
		x.ref4e3c7552 = nil
	}
}

// NewTpmlHandleRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmlHandleRef(ref unsafe.Pointer) *TpmlHandle {
	if ref == nil {
		return nil
	}
	obj := new(TpmlHandle)
	obj.ref4e3c7552 = (*C.TPML_HANDLE)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmlHandle) PassRef() (*C.TPML_HANDLE, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4e3c7552 != nil {
		return x.ref4e3c7552, nil
	}
	mem4e3c7552 := allocTpmlHandleMemory(1)
	ref4e3c7552 := (*C.TPML_HANDLE)(mem4e3c7552)
	allocs4e3c7552 := new(cgoAllocMap)
	allocs4e3c7552.Add(mem4e3c7552)

	var ccount_allocs *cgoAllocMap
	ref4e3c7552.count, ccount_allocs = (C.UINT32)(x.Count), cgoAllocsUnknown
	allocs4e3c7552.Borrow(ccount_allocs)

	var chandle_allocs *cgoAllocMap
	ref4e3c7552.handle, chandle_allocs = *(*[254]C.TPM2_HANDLE)(unsafe.Pointer(&x.Handle)), cgoAllocsUnknown
	allocs4e3c7552.Borrow(chandle_allocs)

	x.ref4e3c7552 = ref4e3c7552
	x.allocs4e3c7552 = allocs4e3c7552
	return ref4e3c7552, allocs4e3c7552

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmlHandle) PassValue() (C.TPML_HANDLE, *cgoAllocMap) {
	if x.ref4e3c7552 != nil {
		return *x.ref4e3c7552, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmlHandle) Deref() {
	if x.ref4e3c7552 == nil {
		return
	}
	x.Count = (Uint32)(x.ref4e3c7552.count)
	x.Handle = *(*[254]Tpm2Handle)(unsafe.Pointer(&x.ref4e3c7552.handle))
}

// allocTpmlDigestMemory allocates memory for type C.TPML_DIGEST in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmlDigestMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmlDigestValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmlDigestValue = unsafe.Sizeof([1]C.TPML_DIGEST{})

// allocA8Tpm2bDigestMemory allocates memory for type [8]C.TPM2B_DIGEST in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA8Tpm2bDigestMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA8Tpm2bDigestValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfA8Tpm2bDigestValue = unsafe.Sizeof([1][8]C.TPM2B_DIGEST{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackA8Tpm2bDigest transforms a sliced Go data structure into plain C format.
func unpackA8Tpm2bDigest(x [8]Tpm2bDigest) (unpacked [8]C.TPM2B_DIGEST, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := allocA8Tpm2bDigestMemory(1)
	allocs.Add(mem0)
	v0 := (*[8]C.TPM2B_DIGEST)(mem0)
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	unpacked = *(*[8]C.TPM2B_DIGEST)(mem0)
	return
}

// packA8Tpm2bDigest reads sliced Go data structure out from plain C format.
func packA8Tpm2bDigest(v *[8]Tpm2bDigest, ptr0 *[8]C.TPM2B_DIGEST) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewTpm2bDigestRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmlDigest) Ref() *C.TPML_DIGEST {
	if x == nil {
		return nil
	}
	return x.refd2aef539
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmlDigest) Free() {
	if x != nil && x.allocsd2aef539 != nil {
		x.allocsd2aef539.(*cgoAllocMap).Free()
		x.refd2aef539 = nil
	}
}

// NewTpmlDigestRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmlDigestRef(ref unsafe.Pointer) *TpmlDigest {
	if ref == nil {
		return nil
	}
	obj := new(TpmlDigest)
	obj.refd2aef539 = (*C.TPML_DIGEST)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmlDigest) PassRef() (*C.TPML_DIGEST, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd2aef539 != nil {
		return x.refd2aef539, nil
	}
	memd2aef539 := allocTpmlDigestMemory(1)
	refd2aef539 := (*C.TPML_DIGEST)(memd2aef539)
	allocsd2aef539 := new(cgoAllocMap)
	allocsd2aef539.Add(memd2aef539)

	var ccount_allocs *cgoAllocMap
	refd2aef539.count, ccount_allocs = (C.UINT32)(x.Count), cgoAllocsUnknown
	allocsd2aef539.Borrow(ccount_allocs)

	var cdigests_allocs *cgoAllocMap
	refd2aef539.digests, cdigests_allocs = unpackA8Tpm2bDigest(x.Digests)
	allocsd2aef539.Borrow(cdigests_allocs)

	x.refd2aef539 = refd2aef539
	x.allocsd2aef539 = allocsd2aef539
	return refd2aef539, allocsd2aef539

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmlDigest) PassValue() (C.TPML_DIGEST, *cgoAllocMap) {
	if x.refd2aef539 != nil {
		return *x.refd2aef539, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmlDigest) Deref() {
	if x.refd2aef539 == nil {
		return
	}
	x.Count = (Uint32)(x.refd2aef539.count)
	packA8Tpm2bDigest(&x.Digests, (*[8]C.TPM2B_DIGEST)(unsafe.Pointer(&x.refd2aef539.digests)))
}

// allocTpmlDigestValuesMemory allocates memory for type C.TPML_DIGEST_VALUES in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmlDigestValuesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmlDigestValuesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmlDigestValuesValue = unsafe.Sizeof([1]C.TPML_DIGEST_VALUES{})

// allocA16TpmtHaMemory allocates memory for type [16]C.TPMT_HA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA16TpmtHaMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA16TpmtHaValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfA16TpmtHaValue = unsafe.Sizeof([1][16]C.TPMT_HA{})

// unpackA16TpmtHa transforms a sliced Go data structure into plain C format.
func unpackA16TpmtHa(x [16]TpmtHa) (unpacked [16]C.TPMT_HA, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := allocA16TpmtHaMemory(1)
	allocs.Add(mem0)
	v0 := (*[16]C.TPMT_HA)(mem0)
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	unpacked = *(*[16]C.TPMT_HA)(mem0)
	return
}

// packA16TpmtHa reads sliced Go data structure out from plain C format.
func packA16TpmtHa(v *[16]TpmtHa, ptr0 *[16]C.TPMT_HA) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewTpmtHaRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmlDigestValues) Ref() *C.TPML_DIGEST_VALUES {
	if x == nil {
		return nil
	}
	return x.ref882542d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmlDigestValues) Free() {
	if x != nil && x.allocs882542d != nil {
		x.allocs882542d.(*cgoAllocMap).Free()
		x.ref882542d = nil
	}
}

// NewTpmlDigestValuesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmlDigestValuesRef(ref unsafe.Pointer) *TpmlDigestValues {
	if ref == nil {
		return nil
	}
	obj := new(TpmlDigestValues)
	obj.ref882542d = (*C.TPML_DIGEST_VALUES)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmlDigestValues) PassRef() (*C.TPML_DIGEST_VALUES, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref882542d != nil {
		return x.ref882542d, nil
	}
	mem882542d := allocTpmlDigestValuesMemory(1)
	ref882542d := (*C.TPML_DIGEST_VALUES)(mem882542d)
	allocs882542d := new(cgoAllocMap)
	allocs882542d.Add(mem882542d)

	var ccount_allocs *cgoAllocMap
	ref882542d.count, ccount_allocs = (C.UINT32)(x.Count), cgoAllocsUnknown
	allocs882542d.Borrow(ccount_allocs)

	var cdigests_allocs *cgoAllocMap
	ref882542d.digests, cdigests_allocs = unpackA16TpmtHa(x.Digests)
	allocs882542d.Borrow(cdigests_allocs)

	x.ref882542d = ref882542d
	x.allocs882542d = allocs882542d
	return ref882542d, allocs882542d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmlDigestValues) PassValue() (C.TPML_DIGEST_VALUES, *cgoAllocMap) {
	if x.ref882542d != nil {
		return *x.ref882542d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmlDigestValues) Deref() {
	if x.ref882542d == nil {
		return
	}
	x.Count = (Uint32)(x.ref882542d.count)
	packA16TpmtHa(&x.Digests, (*[16]C.TPMT_HA)(unsafe.Pointer(&x.ref882542d.digests)))
}

// allocTpmlPcrSelectionMemory allocates memory for type C.TPML_PCR_SELECTION in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmlPcrSelectionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmlPcrSelectionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmlPcrSelectionValue = unsafe.Sizeof([1]C.TPML_PCR_SELECTION{})

// allocA16TpmsPcrSelectionMemory allocates memory for type [16]C.TPMS_PCR_SELECTION in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA16TpmsPcrSelectionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA16TpmsPcrSelectionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfA16TpmsPcrSelectionValue = unsafe.Sizeof([1][16]C.TPMS_PCR_SELECTION{})

// unpackA16TpmsPcrSelection transforms a sliced Go data structure into plain C format.
func unpackA16TpmsPcrSelection(x [16]TpmsPcrSelection) (unpacked [16]C.TPMS_PCR_SELECTION, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := allocA16TpmsPcrSelectionMemory(1)
	allocs.Add(mem0)
	v0 := (*[16]C.TPMS_PCR_SELECTION)(mem0)
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	unpacked = *(*[16]C.TPMS_PCR_SELECTION)(mem0)
	return
}

// packA16TpmsPcrSelection reads sliced Go data structure out from plain C format.
func packA16TpmsPcrSelection(v *[16]TpmsPcrSelection, ptr0 *[16]C.TPMS_PCR_SELECTION) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewTpmsPcrSelectionRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmlPcrSelection) Ref() *C.TPML_PCR_SELECTION {
	if x == nil {
		return nil
	}
	return x.ref79fb3c2c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmlPcrSelection) Free() {
	if x != nil && x.allocs79fb3c2c != nil {
		x.allocs79fb3c2c.(*cgoAllocMap).Free()
		x.ref79fb3c2c = nil
	}
}

// NewTpmlPcrSelectionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmlPcrSelectionRef(ref unsafe.Pointer) *TpmlPcrSelection {
	if ref == nil {
		return nil
	}
	obj := new(TpmlPcrSelection)
	obj.ref79fb3c2c = (*C.TPML_PCR_SELECTION)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmlPcrSelection) PassRef() (*C.TPML_PCR_SELECTION, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref79fb3c2c != nil {
		return x.ref79fb3c2c, nil
	}
	mem79fb3c2c := allocTpmlPcrSelectionMemory(1)
	ref79fb3c2c := (*C.TPML_PCR_SELECTION)(mem79fb3c2c)
	allocs79fb3c2c := new(cgoAllocMap)
	allocs79fb3c2c.Add(mem79fb3c2c)

	var ccount_allocs *cgoAllocMap
	ref79fb3c2c.count, ccount_allocs = (C.UINT32)(x.Count), cgoAllocsUnknown
	allocs79fb3c2c.Borrow(ccount_allocs)

	var cpcrSelections_allocs *cgoAllocMap
	ref79fb3c2c.pcrSelections, cpcrSelections_allocs = unpackA16TpmsPcrSelection(x.Pcrselections)
	allocs79fb3c2c.Borrow(cpcrSelections_allocs)

	x.ref79fb3c2c = ref79fb3c2c
	x.allocs79fb3c2c = allocs79fb3c2c
	return ref79fb3c2c, allocs79fb3c2c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmlPcrSelection) PassValue() (C.TPML_PCR_SELECTION, *cgoAllocMap) {
	if x.ref79fb3c2c != nil {
		return *x.ref79fb3c2c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmlPcrSelection) Deref() {
	if x.ref79fb3c2c == nil {
		return
	}
	x.Count = (Uint32)(x.ref79fb3c2c.count)
	packA16TpmsPcrSelection(&x.Pcrselections, (*[16]C.TPMS_PCR_SELECTION)(unsafe.Pointer(&x.ref79fb3c2c.pcrSelections)))
}

// allocTpmlAlgPropertyMemory allocates memory for type C.TPML_ALG_PROPERTY in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmlAlgPropertyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmlAlgPropertyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmlAlgPropertyValue = unsafe.Sizeof([1]C.TPML_ALG_PROPERTY{})

// allocA127TpmsAlgPropertyMemory allocates memory for type [127]C.TPMS_ALG_PROPERTY in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA127TpmsAlgPropertyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA127TpmsAlgPropertyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfA127TpmsAlgPropertyValue = unsafe.Sizeof([1][127]C.TPMS_ALG_PROPERTY{})

// unpackA127TpmsAlgProperty transforms a sliced Go data structure into plain C format.
func unpackA127TpmsAlgProperty(x [127]TpmsAlgProperty) (unpacked [127]C.TPMS_ALG_PROPERTY, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := allocA127TpmsAlgPropertyMemory(1)
	allocs.Add(mem0)
	v0 := (*[127]C.TPMS_ALG_PROPERTY)(mem0)
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	unpacked = *(*[127]C.TPMS_ALG_PROPERTY)(mem0)
	return
}

// packA127TpmsAlgProperty reads sliced Go data structure out from plain C format.
func packA127TpmsAlgProperty(v *[127]TpmsAlgProperty, ptr0 *[127]C.TPMS_ALG_PROPERTY) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewTpmsAlgPropertyRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmlAlgProperty) Ref() *C.TPML_ALG_PROPERTY {
	if x == nil {
		return nil
	}
	return x.refc510d244
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmlAlgProperty) Free() {
	if x != nil && x.allocsc510d244 != nil {
		x.allocsc510d244.(*cgoAllocMap).Free()
		x.refc510d244 = nil
	}
}

// NewTpmlAlgPropertyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmlAlgPropertyRef(ref unsafe.Pointer) *TpmlAlgProperty {
	if ref == nil {
		return nil
	}
	obj := new(TpmlAlgProperty)
	obj.refc510d244 = (*C.TPML_ALG_PROPERTY)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmlAlgProperty) PassRef() (*C.TPML_ALG_PROPERTY, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc510d244 != nil {
		return x.refc510d244, nil
	}
	memc510d244 := allocTpmlAlgPropertyMemory(1)
	refc510d244 := (*C.TPML_ALG_PROPERTY)(memc510d244)
	allocsc510d244 := new(cgoAllocMap)
	allocsc510d244.Add(memc510d244)

	var ccount_allocs *cgoAllocMap
	refc510d244.count, ccount_allocs = (C.UINT32)(x.Count), cgoAllocsUnknown
	allocsc510d244.Borrow(ccount_allocs)

	var calgProperties_allocs *cgoAllocMap
	refc510d244.algProperties, calgProperties_allocs = unpackA127TpmsAlgProperty(x.Algproperties)
	allocsc510d244.Borrow(calgProperties_allocs)

	x.refc510d244 = refc510d244
	x.allocsc510d244 = allocsc510d244
	return refc510d244, allocsc510d244

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmlAlgProperty) PassValue() (C.TPML_ALG_PROPERTY, *cgoAllocMap) {
	if x.refc510d244 != nil {
		return *x.refc510d244, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmlAlgProperty) Deref() {
	if x.refc510d244 == nil {
		return
	}
	x.Count = (Uint32)(x.refc510d244.count)
	packA127TpmsAlgProperty(&x.Algproperties, (*[127]C.TPMS_ALG_PROPERTY)(unsafe.Pointer(&x.refc510d244.algProperties)))
}

// allocTpmlTaggedTpmPropertyMemory allocates memory for type C.TPML_TAGGED_TPM_PROPERTY in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmlTaggedTpmPropertyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmlTaggedTpmPropertyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmlTaggedTpmPropertyValue = unsafe.Sizeof([1]C.TPML_TAGGED_TPM_PROPERTY{})

// allocA127TpmsTaggedPropertyMemory allocates memory for type [127]C.TPMS_TAGGED_PROPERTY in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA127TpmsTaggedPropertyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA127TpmsTaggedPropertyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfA127TpmsTaggedPropertyValue = unsafe.Sizeof([1][127]C.TPMS_TAGGED_PROPERTY{})

// unpackA127TpmsTaggedProperty transforms a sliced Go data structure into plain C format.
func unpackA127TpmsTaggedProperty(x [127]TpmsTaggedProperty) (unpacked [127]C.TPMS_TAGGED_PROPERTY, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := allocA127TpmsTaggedPropertyMemory(1)
	allocs.Add(mem0)
	v0 := (*[127]C.TPMS_TAGGED_PROPERTY)(mem0)
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	unpacked = *(*[127]C.TPMS_TAGGED_PROPERTY)(mem0)
	return
}

// packA127TpmsTaggedProperty reads sliced Go data structure out from plain C format.
func packA127TpmsTaggedProperty(v *[127]TpmsTaggedProperty, ptr0 *[127]C.TPMS_TAGGED_PROPERTY) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewTpmsTaggedPropertyRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmlTaggedTpmProperty) Ref() *C.TPML_TAGGED_TPM_PROPERTY {
	if x == nil {
		return nil
	}
	return x.refafb53290
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmlTaggedTpmProperty) Free() {
	if x != nil && x.allocsafb53290 != nil {
		x.allocsafb53290.(*cgoAllocMap).Free()
		x.refafb53290 = nil
	}
}

// NewTpmlTaggedTpmPropertyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmlTaggedTpmPropertyRef(ref unsafe.Pointer) *TpmlTaggedTpmProperty {
	if ref == nil {
		return nil
	}
	obj := new(TpmlTaggedTpmProperty)
	obj.refafb53290 = (*C.TPML_TAGGED_TPM_PROPERTY)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmlTaggedTpmProperty) PassRef() (*C.TPML_TAGGED_TPM_PROPERTY, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refafb53290 != nil {
		return x.refafb53290, nil
	}
	memafb53290 := allocTpmlTaggedTpmPropertyMemory(1)
	refafb53290 := (*C.TPML_TAGGED_TPM_PROPERTY)(memafb53290)
	allocsafb53290 := new(cgoAllocMap)
	allocsafb53290.Add(memafb53290)

	var ccount_allocs *cgoAllocMap
	refafb53290.count, ccount_allocs = (C.UINT32)(x.Count), cgoAllocsUnknown
	allocsafb53290.Borrow(ccount_allocs)

	var ctpmProperty_allocs *cgoAllocMap
	refafb53290.tpmProperty, ctpmProperty_allocs = unpackA127TpmsTaggedProperty(x.Tpmproperty)
	allocsafb53290.Borrow(ctpmProperty_allocs)

	x.refafb53290 = refafb53290
	x.allocsafb53290 = allocsafb53290
	return refafb53290, allocsafb53290

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmlTaggedTpmProperty) PassValue() (C.TPML_TAGGED_TPM_PROPERTY, *cgoAllocMap) {
	if x.refafb53290 != nil {
		return *x.refafb53290, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmlTaggedTpmProperty) Deref() {
	if x.refafb53290 == nil {
		return
	}
	x.Count = (Uint32)(x.refafb53290.count)
	packA127TpmsTaggedProperty(&x.Tpmproperty, (*[127]C.TPMS_TAGGED_PROPERTY)(unsafe.Pointer(&x.refafb53290.tpmProperty)))
}

// allocTpmlTaggedPcrPropertyMemory allocates memory for type C.TPML_TAGGED_PCR_PROPERTY in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmlTaggedPcrPropertyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmlTaggedPcrPropertyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmlTaggedPcrPropertyValue = unsafe.Sizeof([1]C.TPML_TAGGED_PCR_PROPERTY{})

// allocA84TpmsTaggedPcrSelectMemory allocates memory for type [84]C.TPMS_TAGGED_PCR_SELECT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA84TpmsTaggedPcrSelectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA84TpmsTaggedPcrSelectValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfA84TpmsTaggedPcrSelectValue = unsafe.Sizeof([1][84]C.TPMS_TAGGED_PCR_SELECT{})

// unpackA84TpmsTaggedPcrSelect transforms a sliced Go data structure into plain C format.
func unpackA84TpmsTaggedPcrSelect(x [84]TpmsTaggedPcrSelect) (unpacked [84]C.TPMS_TAGGED_PCR_SELECT, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := allocA84TpmsTaggedPcrSelectMemory(1)
	allocs.Add(mem0)
	v0 := (*[84]C.TPMS_TAGGED_PCR_SELECT)(mem0)
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	unpacked = *(*[84]C.TPMS_TAGGED_PCR_SELECT)(mem0)
	return
}

// packA84TpmsTaggedPcrSelect reads sliced Go data structure out from plain C format.
func packA84TpmsTaggedPcrSelect(v *[84]TpmsTaggedPcrSelect, ptr0 *[84]C.TPMS_TAGGED_PCR_SELECT) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewTpmsTaggedPcrSelectRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmlTaggedPcrProperty) Ref() *C.TPML_TAGGED_PCR_PROPERTY {
	if x == nil {
		return nil
	}
	return x.ref4d027140
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmlTaggedPcrProperty) Free() {
	if x != nil && x.allocs4d027140 != nil {
		x.allocs4d027140.(*cgoAllocMap).Free()
		x.ref4d027140 = nil
	}
}

// NewTpmlTaggedPcrPropertyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmlTaggedPcrPropertyRef(ref unsafe.Pointer) *TpmlTaggedPcrProperty {
	if ref == nil {
		return nil
	}
	obj := new(TpmlTaggedPcrProperty)
	obj.ref4d027140 = (*C.TPML_TAGGED_PCR_PROPERTY)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmlTaggedPcrProperty) PassRef() (*C.TPML_TAGGED_PCR_PROPERTY, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4d027140 != nil {
		return x.ref4d027140, nil
	}
	mem4d027140 := allocTpmlTaggedPcrPropertyMemory(1)
	ref4d027140 := (*C.TPML_TAGGED_PCR_PROPERTY)(mem4d027140)
	allocs4d027140 := new(cgoAllocMap)
	allocs4d027140.Add(mem4d027140)

	var ccount_allocs *cgoAllocMap
	ref4d027140.count, ccount_allocs = (C.UINT32)(x.Count), cgoAllocsUnknown
	allocs4d027140.Borrow(ccount_allocs)

	var cpcrProperty_allocs *cgoAllocMap
	ref4d027140.pcrProperty, cpcrProperty_allocs = unpackA84TpmsTaggedPcrSelect(x.Pcrproperty)
	allocs4d027140.Borrow(cpcrProperty_allocs)

	x.ref4d027140 = ref4d027140
	x.allocs4d027140 = allocs4d027140
	return ref4d027140, allocs4d027140

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmlTaggedPcrProperty) PassValue() (C.TPML_TAGGED_PCR_PROPERTY, *cgoAllocMap) {
	if x.ref4d027140 != nil {
		return *x.ref4d027140, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmlTaggedPcrProperty) Deref() {
	if x.ref4d027140 == nil {
		return
	}
	x.Count = (Uint32)(x.ref4d027140.count)
	packA84TpmsTaggedPcrSelect(&x.Pcrproperty, (*[84]C.TPMS_TAGGED_PCR_SELECT)(unsafe.Pointer(&x.ref4d027140.pcrProperty)))
}

// allocTpmlEccCurveMemory allocates memory for type C.TPML_ECC_CURVE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmlEccCurveMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmlEccCurveValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmlEccCurveValue = unsafe.Sizeof([1]C.TPML_ECC_CURVE{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmlEccCurve) Ref() *C.TPML_ECC_CURVE {
	if x == nil {
		return nil
	}
	return x.ref1d4d459
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmlEccCurve) Free() {
	if x != nil && x.allocs1d4d459 != nil {
		x.allocs1d4d459.(*cgoAllocMap).Free()
		x.ref1d4d459 = nil
	}
}

// NewTpmlEccCurveRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmlEccCurveRef(ref unsafe.Pointer) *TpmlEccCurve {
	if ref == nil {
		return nil
	}
	obj := new(TpmlEccCurve)
	obj.ref1d4d459 = (*C.TPML_ECC_CURVE)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmlEccCurve) PassRef() (*C.TPML_ECC_CURVE, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1d4d459 != nil {
		return x.ref1d4d459, nil
	}
	mem1d4d459 := allocTpmlEccCurveMemory(1)
	ref1d4d459 := (*C.TPML_ECC_CURVE)(mem1d4d459)
	allocs1d4d459 := new(cgoAllocMap)
	allocs1d4d459.Add(mem1d4d459)

	var ccount_allocs *cgoAllocMap
	ref1d4d459.count, ccount_allocs = (C.UINT32)(x.Count), cgoAllocsUnknown
	allocs1d4d459.Borrow(ccount_allocs)

	var ceccCurves_allocs *cgoAllocMap
	ref1d4d459.eccCurves, ceccCurves_allocs = *(*[508]C.TPM2_ECC_CURVE)(unsafe.Pointer(&x.Ecccurves)), cgoAllocsUnknown
	allocs1d4d459.Borrow(ceccCurves_allocs)

	x.ref1d4d459 = ref1d4d459
	x.allocs1d4d459 = allocs1d4d459
	return ref1d4d459, allocs1d4d459

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmlEccCurve) PassValue() (C.TPML_ECC_CURVE, *cgoAllocMap) {
	if x.ref1d4d459 != nil {
		return *x.ref1d4d459, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmlEccCurve) Deref() {
	if x.ref1d4d459 == nil {
		return
	}
	x.Count = (Uint32)(x.ref1d4d459.count)
	x.Ecccurves = *(*[508]Tpm2EccCurve)(unsafe.Pointer(&x.ref1d4d459.eccCurves))
}

// allocTpmlIntelPttPropertyMemory allocates memory for type C.TPML_INTEL_PTT_PROPERTY in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmlIntelPttPropertyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmlIntelPttPropertyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmlIntelPttPropertyValue = unsafe.Sizeof([1]C.TPML_INTEL_PTT_PROPERTY{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmlIntelPttProperty) Ref() *C.TPML_INTEL_PTT_PROPERTY {
	if x == nil {
		return nil
	}
	return x.ref8d735f38
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmlIntelPttProperty) Free() {
	if x != nil && x.allocs8d735f38 != nil {
		x.allocs8d735f38.(*cgoAllocMap).Free()
		x.ref8d735f38 = nil
	}
}

// NewTpmlIntelPttPropertyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmlIntelPttPropertyRef(ref unsafe.Pointer) *TpmlIntelPttProperty {
	if ref == nil {
		return nil
	}
	obj := new(TpmlIntelPttProperty)
	obj.ref8d735f38 = (*C.TPML_INTEL_PTT_PROPERTY)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmlIntelPttProperty) PassRef() (*C.TPML_INTEL_PTT_PROPERTY, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8d735f38 != nil {
		return x.ref8d735f38, nil
	}
	mem8d735f38 := allocTpmlIntelPttPropertyMemory(1)
	ref8d735f38 := (*C.TPML_INTEL_PTT_PROPERTY)(mem8d735f38)
	allocs8d735f38 := new(cgoAllocMap)
	allocs8d735f38.Add(mem8d735f38)

	var ccount_allocs *cgoAllocMap
	ref8d735f38.count, ccount_allocs = (C.UINT32)(x.Count), cgoAllocsUnknown
	allocs8d735f38.Borrow(ccount_allocs)

	var cproperty_allocs *cgoAllocMap
	ref8d735f38.property, cproperty_allocs = *(*[256]C.UINT32)(unsafe.Pointer(&x.Property)), cgoAllocsUnknown
	allocs8d735f38.Borrow(cproperty_allocs)

	x.ref8d735f38 = ref8d735f38
	x.allocs8d735f38 = allocs8d735f38
	return ref8d735f38, allocs8d735f38

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmlIntelPttProperty) PassValue() (C.TPML_INTEL_PTT_PROPERTY, *cgoAllocMap) {
	if x.ref8d735f38 != nil {
		return *x.ref8d735f38, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmlIntelPttProperty) Deref() {
	if x.ref8d735f38 == nil {
		return
	}
	x.Count = (Uint32)(x.ref8d735f38.count)
	x.Property = *(*[256]Uint32)(unsafe.Pointer(&x.ref8d735f38.property))
}

// allocTpmsCapabilityDataMemory allocates memory for type C.TPMS_CAPABILITY_DATA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsCapabilityDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsCapabilityDataValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsCapabilityDataValue = unsafe.Sizeof([1]C.TPMS_CAPABILITY_DATA{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsCapabilityData) Ref() *C.TPMS_CAPABILITY_DATA {
	if x == nil {
		return nil
	}
	return x.ref67ad78ab
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsCapabilityData) Free() {
	if x != nil && x.allocs67ad78ab != nil {
		x.allocs67ad78ab.(*cgoAllocMap).Free()
		x.ref67ad78ab = nil
	}
}

// NewTpmsCapabilityDataRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsCapabilityDataRef(ref unsafe.Pointer) *TpmsCapabilityData {
	if ref == nil {
		return nil
	}
	obj := new(TpmsCapabilityData)
	obj.ref67ad78ab = (*C.TPMS_CAPABILITY_DATA)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsCapabilityData) PassRef() (*C.TPMS_CAPABILITY_DATA, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref67ad78ab != nil {
		return x.ref67ad78ab, nil
	}
	mem67ad78ab := allocTpmsCapabilityDataMemory(1)
	ref67ad78ab := (*C.TPMS_CAPABILITY_DATA)(mem67ad78ab)
	allocs67ad78ab := new(cgoAllocMap)
	allocs67ad78ab.Add(mem67ad78ab)

	var ccapability_allocs *cgoAllocMap
	ref67ad78ab.capability, ccapability_allocs = (C.TPM2_CAP)(x.Capability), cgoAllocsUnknown
	allocs67ad78ab.Borrow(ccapability_allocs)

	var cdata_allocs *cgoAllocMap
	ref67ad78ab.data, cdata_allocs = *(*C.TPMU_CAPABILITIES)(unsafe.Pointer(&x.Data)), cgoAllocsUnknown
	allocs67ad78ab.Borrow(cdata_allocs)

	x.ref67ad78ab = ref67ad78ab
	x.allocs67ad78ab = allocs67ad78ab
	return ref67ad78ab, allocs67ad78ab

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsCapabilityData) PassValue() (C.TPMS_CAPABILITY_DATA, *cgoAllocMap) {
	if x.ref67ad78ab != nil {
		return *x.ref67ad78ab, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsCapabilityData) Deref() {
	if x.ref67ad78ab == nil {
		return
	}
	x.Capability = (Tpm2Cap)(x.ref67ad78ab.capability)
	x.Data = *(*TpmuCapabilities)(unsafe.Pointer(&x.ref67ad78ab.data))
}

// allocTpmsClockInfoMemory allocates memory for type C.TPMS_CLOCK_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsClockInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsClockInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsClockInfoValue = unsafe.Sizeof([1]C.TPMS_CLOCK_INFO{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsClockInfo) Ref() *C.TPMS_CLOCK_INFO {
	if x == nil {
		return nil
	}
	return x.ref65ce4bbf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsClockInfo) Free() {
	if x != nil && x.allocs65ce4bbf != nil {
		x.allocs65ce4bbf.(*cgoAllocMap).Free()
		x.ref65ce4bbf = nil
	}
}

// NewTpmsClockInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsClockInfoRef(ref unsafe.Pointer) *TpmsClockInfo {
	if ref == nil {
		return nil
	}
	obj := new(TpmsClockInfo)
	obj.ref65ce4bbf = (*C.TPMS_CLOCK_INFO)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsClockInfo) PassRef() (*C.TPMS_CLOCK_INFO, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref65ce4bbf != nil {
		return x.ref65ce4bbf, nil
	}
	mem65ce4bbf := allocTpmsClockInfoMemory(1)
	ref65ce4bbf := (*C.TPMS_CLOCK_INFO)(mem65ce4bbf)
	allocs65ce4bbf := new(cgoAllocMap)
	allocs65ce4bbf.Add(mem65ce4bbf)

	var cclock_allocs *cgoAllocMap
	ref65ce4bbf.clock, cclock_allocs = (C.UINT64)(x.Clock), cgoAllocsUnknown
	allocs65ce4bbf.Borrow(cclock_allocs)

	var cresetCount_allocs *cgoAllocMap
	ref65ce4bbf.resetCount, cresetCount_allocs = (C.UINT32)(x.Resetcount), cgoAllocsUnknown
	allocs65ce4bbf.Borrow(cresetCount_allocs)

	var crestartCount_allocs *cgoAllocMap
	ref65ce4bbf.restartCount, crestartCount_allocs = (C.UINT32)(x.Restartcount), cgoAllocsUnknown
	allocs65ce4bbf.Borrow(crestartCount_allocs)

	var csafe_allocs *cgoAllocMap
	ref65ce4bbf.safe, csafe_allocs = (C.TPMI_YES_NO)(x.Safe), cgoAllocsUnknown
	allocs65ce4bbf.Borrow(csafe_allocs)

	x.ref65ce4bbf = ref65ce4bbf
	x.allocs65ce4bbf = allocs65ce4bbf
	return ref65ce4bbf, allocs65ce4bbf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsClockInfo) PassValue() (C.TPMS_CLOCK_INFO, *cgoAllocMap) {
	if x.ref65ce4bbf != nil {
		return *x.ref65ce4bbf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsClockInfo) Deref() {
	if x.ref65ce4bbf == nil {
		return
	}
	x.Clock = (Uint64)(x.ref65ce4bbf.clock)
	x.Resetcount = (Uint32)(x.ref65ce4bbf.resetCount)
	x.Restartcount = (Uint32)(x.ref65ce4bbf.restartCount)
	x.Safe = (TpmiYesNo)(x.ref65ce4bbf.safe)
}

// allocTpmsTimeInfoMemory allocates memory for type C.TPMS_TIME_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsTimeInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsTimeInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsTimeInfoValue = unsafe.Sizeof([1]C.TPMS_TIME_INFO{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsTimeInfo) Ref() *C.TPMS_TIME_INFO {
	if x == nil {
		return nil
	}
	return x.refe427c7f1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsTimeInfo) Free() {
	if x != nil && x.allocse427c7f1 != nil {
		x.allocse427c7f1.(*cgoAllocMap).Free()
		x.refe427c7f1 = nil
	}
}

// NewTpmsTimeInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsTimeInfoRef(ref unsafe.Pointer) *TpmsTimeInfo {
	if ref == nil {
		return nil
	}
	obj := new(TpmsTimeInfo)
	obj.refe427c7f1 = (*C.TPMS_TIME_INFO)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsTimeInfo) PassRef() (*C.TPMS_TIME_INFO, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe427c7f1 != nil {
		return x.refe427c7f1, nil
	}
	meme427c7f1 := allocTpmsTimeInfoMemory(1)
	refe427c7f1 := (*C.TPMS_TIME_INFO)(meme427c7f1)
	allocse427c7f1 := new(cgoAllocMap)
	allocse427c7f1.Add(meme427c7f1)

	var ctime_allocs *cgoAllocMap
	refe427c7f1.time, ctime_allocs = (C.UINT64)(x.Time), cgoAllocsUnknown
	allocse427c7f1.Borrow(ctime_allocs)

	var cclockInfo_allocs *cgoAllocMap
	refe427c7f1.clockInfo, cclockInfo_allocs = x.Clockinfo.PassValue()
	allocse427c7f1.Borrow(cclockInfo_allocs)

	x.refe427c7f1 = refe427c7f1
	x.allocse427c7f1 = allocse427c7f1
	return refe427c7f1, allocse427c7f1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsTimeInfo) PassValue() (C.TPMS_TIME_INFO, *cgoAllocMap) {
	if x.refe427c7f1 != nil {
		return *x.refe427c7f1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsTimeInfo) Deref() {
	if x.refe427c7f1 == nil {
		return
	}
	x.Time = (Uint64)(x.refe427c7f1.time)
	x.Clockinfo = *NewTpmsClockInfoRef(unsafe.Pointer(&x.refe427c7f1.clockInfo))
}

// allocTpmsTimeAttestInfoMemory allocates memory for type C.TPMS_TIME_ATTEST_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsTimeAttestInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsTimeAttestInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsTimeAttestInfoValue = unsafe.Sizeof([1]C.TPMS_TIME_ATTEST_INFO{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsTimeAttestInfo) Ref() *C.TPMS_TIME_ATTEST_INFO {
	if x == nil {
		return nil
	}
	return x.ref3f48111
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsTimeAttestInfo) Free() {
	if x != nil && x.allocs3f48111 != nil {
		x.allocs3f48111.(*cgoAllocMap).Free()
		x.ref3f48111 = nil
	}
}

// NewTpmsTimeAttestInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsTimeAttestInfoRef(ref unsafe.Pointer) *TpmsTimeAttestInfo {
	if ref == nil {
		return nil
	}
	obj := new(TpmsTimeAttestInfo)
	obj.ref3f48111 = (*C.TPMS_TIME_ATTEST_INFO)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsTimeAttestInfo) PassRef() (*C.TPMS_TIME_ATTEST_INFO, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3f48111 != nil {
		return x.ref3f48111, nil
	}
	mem3f48111 := allocTpmsTimeAttestInfoMemory(1)
	ref3f48111 := (*C.TPMS_TIME_ATTEST_INFO)(mem3f48111)
	allocs3f48111 := new(cgoAllocMap)
	allocs3f48111.Add(mem3f48111)

	var ctime_allocs *cgoAllocMap
	ref3f48111.time, ctime_allocs = x.Time.PassValue()
	allocs3f48111.Borrow(ctime_allocs)

	var cfirmwareVersion_allocs *cgoAllocMap
	ref3f48111.firmwareVersion, cfirmwareVersion_allocs = (C.UINT64)(x.Firmwareversion), cgoAllocsUnknown
	allocs3f48111.Borrow(cfirmwareVersion_allocs)

	x.ref3f48111 = ref3f48111
	x.allocs3f48111 = allocs3f48111
	return ref3f48111, allocs3f48111

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsTimeAttestInfo) PassValue() (C.TPMS_TIME_ATTEST_INFO, *cgoAllocMap) {
	if x.ref3f48111 != nil {
		return *x.ref3f48111, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsTimeAttestInfo) Deref() {
	if x.ref3f48111 == nil {
		return
	}
	x.Time = *NewTpmsTimeInfoRef(unsafe.Pointer(&x.ref3f48111.time))
	x.Firmwareversion = (Uint64)(x.ref3f48111.firmwareVersion)
}

// allocTpmsCertifyInfoMemory allocates memory for type C.TPMS_CERTIFY_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsCertifyInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsCertifyInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsCertifyInfoValue = unsafe.Sizeof([1]C.TPMS_CERTIFY_INFO{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsCertifyInfo) Ref() *C.TPMS_CERTIFY_INFO {
	if x == nil {
		return nil
	}
	return x.ref55e2ea11
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsCertifyInfo) Free() {
	if x != nil && x.allocs55e2ea11 != nil {
		x.allocs55e2ea11.(*cgoAllocMap).Free()
		x.ref55e2ea11 = nil
	}
}

// NewTpmsCertifyInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsCertifyInfoRef(ref unsafe.Pointer) *TpmsCertifyInfo {
	if ref == nil {
		return nil
	}
	obj := new(TpmsCertifyInfo)
	obj.ref55e2ea11 = (*C.TPMS_CERTIFY_INFO)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsCertifyInfo) PassRef() (*C.TPMS_CERTIFY_INFO, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref55e2ea11 != nil {
		return x.ref55e2ea11, nil
	}
	mem55e2ea11 := allocTpmsCertifyInfoMemory(1)
	ref55e2ea11 := (*C.TPMS_CERTIFY_INFO)(mem55e2ea11)
	allocs55e2ea11 := new(cgoAllocMap)
	allocs55e2ea11.Add(mem55e2ea11)

	var cname_allocs *cgoAllocMap
	ref55e2ea11.name, cname_allocs = x.Name.PassValue()
	allocs55e2ea11.Borrow(cname_allocs)

	var cqualifiedName_allocs *cgoAllocMap
	ref55e2ea11.qualifiedName, cqualifiedName_allocs = x.Qualifiedname.PassValue()
	allocs55e2ea11.Borrow(cqualifiedName_allocs)

	x.ref55e2ea11 = ref55e2ea11
	x.allocs55e2ea11 = allocs55e2ea11
	return ref55e2ea11, allocs55e2ea11

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsCertifyInfo) PassValue() (C.TPMS_CERTIFY_INFO, *cgoAllocMap) {
	if x.ref55e2ea11 != nil {
		return *x.ref55e2ea11, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsCertifyInfo) Deref() {
	if x.ref55e2ea11 == nil {
		return
	}
	x.Name = *NewTpm2bNameRef(unsafe.Pointer(&x.ref55e2ea11.name))
	x.Qualifiedname = *NewTpm2bNameRef(unsafe.Pointer(&x.ref55e2ea11.qualifiedName))
}

// allocTpmsQuoteInfoMemory allocates memory for type C.TPMS_QUOTE_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsQuoteInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsQuoteInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsQuoteInfoValue = unsafe.Sizeof([1]C.TPMS_QUOTE_INFO{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsQuoteInfo) Ref() *C.TPMS_QUOTE_INFO {
	if x == nil {
		return nil
	}
	return x.refde852d70
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsQuoteInfo) Free() {
	if x != nil && x.allocsde852d70 != nil {
		x.allocsde852d70.(*cgoAllocMap).Free()
		x.refde852d70 = nil
	}
}

// NewTpmsQuoteInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsQuoteInfoRef(ref unsafe.Pointer) *TpmsQuoteInfo {
	if ref == nil {
		return nil
	}
	obj := new(TpmsQuoteInfo)
	obj.refde852d70 = (*C.TPMS_QUOTE_INFO)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsQuoteInfo) PassRef() (*C.TPMS_QUOTE_INFO, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refde852d70 != nil {
		return x.refde852d70, nil
	}
	memde852d70 := allocTpmsQuoteInfoMemory(1)
	refde852d70 := (*C.TPMS_QUOTE_INFO)(memde852d70)
	allocsde852d70 := new(cgoAllocMap)
	allocsde852d70.Add(memde852d70)

	var cpcrSelect_allocs *cgoAllocMap
	refde852d70.pcrSelect, cpcrSelect_allocs = x.Pcrselect.PassValue()
	allocsde852d70.Borrow(cpcrSelect_allocs)

	var cpcrDigest_allocs *cgoAllocMap
	refde852d70.pcrDigest, cpcrDigest_allocs = x.Pcrdigest.PassValue()
	allocsde852d70.Borrow(cpcrDigest_allocs)

	x.refde852d70 = refde852d70
	x.allocsde852d70 = allocsde852d70
	return refde852d70, allocsde852d70

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsQuoteInfo) PassValue() (C.TPMS_QUOTE_INFO, *cgoAllocMap) {
	if x.refde852d70 != nil {
		return *x.refde852d70, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsQuoteInfo) Deref() {
	if x.refde852d70 == nil {
		return
	}
	x.Pcrselect = *NewTpmlPcrSelectionRef(unsafe.Pointer(&x.refde852d70.pcrSelect))
	x.Pcrdigest = *NewTpm2bDigestRef(unsafe.Pointer(&x.refde852d70.pcrDigest))
}

// allocTpmsCommandAuditInfoMemory allocates memory for type C.TPMS_COMMAND_AUDIT_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsCommandAuditInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsCommandAuditInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsCommandAuditInfoValue = unsafe.Sizeof([1]C.TPMS_COMMAND_AUDIT_INFO{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsCommandAuditInfo) Ref() *C.TPMS_COMMAND_AUDIT_INFO {
	if x == nil {
		return nil
	}
	return x.ref73825a84
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsCommandAuditInfo) Free() {
	if x != nil && x.allocs73825a84 != nil {
		x.allocs73825a84.(*cgoAllocMap).Free()
		x.ref73825a84 = nil
	}
}

// NewTpmsCommandAuditInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsCommandAuditInfoRef(ref unsafe.Pointer) *TpmsCommandAuditInfo {
	if ref == nil {
		return nil
	}
	obj := new(TpmsCommandAuditInfo)
	obj.ref73825a84 = (*C.TPMS_COMMAND_AUDIT_INFO)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsCommandAuditInfo) PassRef() (*C.TPMS_COMMAND_AUDIT_INFO, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref73825a84 != nil {
		return x.ref73825a84, nil
	}
	mem73825a84 := allocTpmsCommandAuditInfoMemory(1)
	ref73825a84 := (*C.TPMS_COMMAND_AUDIT_INFO)(mem73825a84)
	allocs73825a84 := new(cgoAllocMap)
	allocs73825a84.Add(mem73825a84)

	var cauditCounter_allocs *cgoAllocMap
	ref73825a84.auditCounter, cauditCounter_allocs = (C.UINT64)(x.Auditcounter), cgoAllocsUnknown
	allocs73825a84.Borrow(cauditCounter_allocs)

	var cdigestAlg_allocs *cgoAllocMap
	ref73825a84.digestAlg, cdigestAlg_allocs = (C.TPM2_ALG_ID)(x.Digestalg), cgoAllocsUnknown
	allocs73825a84.Borrow(cdigestAlg_allocs)

	var cauditDigest_allocs *cgoAllocMap
	ref73825a84.auditDigest, cauditDigest_allocs = x.Auditdigest.PassValue()
	allocs73825a84.Borrow(cauditDigest_allocs)

	var ccommandDigest_allocs *cgoAllocMap
	ref73825a84.commandDigest, ccommandDigest_allocs = x.Commanddigest.PassValue()
	allocs73825a84.Borrow(ccommandDigest_allocs)

	x.ref73825a84 = ref73825a84
	x.allocs73825a84 = allocs73825a84
	return ref73825a84, allocs73825a84

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsCommandAuditInfo) PassValue() (C.TPMS_COMMAND_AUDIT_INFO, *cgoAllocMap) {
	if x.ref73825a84 != nil {
		return *x.ref73825a84, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsCommandAuditInfo) Deref() {
	if x.ref73825a84 == nil {
		return
	}
	x.Auditcounter = (Uint64)(x.ref73825a84.auditCounter)
	x.Digestalg = (Tpm2AlgId)(x.ref73825a84.digestAlg)
	x.Auditdigest = *NewTpm2bDigestRef(unsafe.Pointer(&x.ref73825a84.auditDigest))
	x.Commanddigest = *NewTpm2bDigestRef(unsafe.Pointer(&x.ref73825a84.commandDigest))
}

// allocTpmsSessionAuditInfoMemory allocates memory for type C.TPMS_SESSION_AUDIT_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsSessionAuditInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsSessionAuditInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsSessionAuditInfoValue = unsafe.Sizeof([1]C.TPMS_SESSION_AUDIT_INFO{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsSessionAuditInfo) Ref() *C.TPMS_SESSION_AUDIT_INFO {
	if x == nil {
		return nil
	}
	return x.ref441b918
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsSessionAuditInfo) Free() {
	if x != nil && x.allocs441b918 != nil {
		x.allocs441b918.(*cgoAllocMap).Free()
		x.ref441b918 = nil
	}
}

// NewTpmsSessionAuditInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsSessionAuditInfoRef(ref unsafe.Pointer) *TpmsSessionAuditInfo {
	if ref == nil {
		return nil
	}
	obj := new(TpmsSessionAuditInfo)
	obj.ref441b918 = (*C.TPMS_SESSION_AUDIT_INFO)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsSessionAuditInfo) PassRef() (*C.TPMS_SESSION_AUDIT_INFO, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref441b918 != nil {
		return x.ref441b918, nil
	}
	mem441b918 := allocTpmsSessionAuditInfoMemory(1)
	ref441b918 := (*C.TPMS_SESSION_AUDIT_INFO)(mem441b918)
	allocs441b918 := new(cgoAllocMap)
	allocs441b918.Add(mem441b918)

	var cexclusiveSession_allocs *cgoAllocMap
	ref441b918.exclusiveSession, cexclusiveSession_allocs = (C.TPMI_YES_NO)(x.Exclusivesession), cgoAllocsUnknown
	allocs441b918.Borrow(cexclusiveSession_allocs)

	var csessionDigest_allocs *cgoAllocMap
	ref441b918.sessionDigest, csessionDigest_allocs = x.Sessiondigest.PassValue()
	allocs441b918.Borrow(csessionDigest_allocs)

	x.ref441b918 = ref441b918
	x.allocs441b918 = allocs441b918
	return ref441b918, allocs441b918

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsSessionAuditInfo) PassValue() (C.TPMS_SESSION_AUDIT_INFO, *cgoAllocMap) {
	if x.ref441b918 != nil {
		return *x.ref441b918, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsSessionAuditInfo) Deref() {
	if x.ref441b918 == nil {
		return
	}
	x.Exclusivesession = (TpmiYesNo)(x.ref441b918.exclusiveSession)
	x.Sessiondigest = *NewTpm2bDigestRef(unsafe.Pointer(&x.ref441b918.sessionDigest))
}

// allocTpmsCreationInfoMemory allocates memory for type C.TPMS_CREATION_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsCreationInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsCreationInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsCreationInfoValue = unsafe.Sizeof([1]C.TPMS_CREATION_INFO{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsCreationInfo) Ref() *C.TPMS_CREATION_INFO {
	if x == nil {
		return nil
	}
	return x.ref85c39129
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsCreationInfo) Free() {
	if x != nil && x.allocs85c39129 != nil {
		x.allocs85c39129.(*cgoAllocMap).Free()
		x.ref85c39129 = nil
	}
}

// NewTpmsCreationInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsCreationInfoRef(ref unsafe.Pointer) *TpmsCreationInfo {
	if ref == nil {
		return nil
	}
	obj := new(TpmsCreationInfo)
	obj.ref85c39129 = (*C.TPMS_CREATION_INFO)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsCreationInfo) PassRef() (*C.TPMS_CREATION_INFO, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref85c39129 != nil {
		return x.ref85c39129, nil
	}
	mem85c39129 := allocTpmsCreationInfoMemory(1)
	ref85c39129 := (*C.TPMS_CREATION_INFO)(mem85c39129)
	allocs85c39129 := new(cgoAllocMap)
	allocs85c39129.Add(mem85c39129)

	var cobjectName_allocs *cgoAllocMap
	ref85c39129.objectName, cobjectName_allocs = x.Objectname.PassValue()
	allocs85c39129.Borrow(cobjectName_allocs)

	var ccreationHash_allocs *cgoAllocMap
	ref85c39129.creationHash, ccreationHash_allocs = x.Creationhash.PassValue()
	allocs85c39129.Borrow(ccreationHash_allocs)

	x.ref85c39129 = ref85c39129
	x.allocs85c39129 = allocs85c39129
	return ref85c39129, allocs85c39129

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsCreationInfo) PassValue() (C.TPMS_CREATION_INFO, *cgoAllocMap) {
	if x.ref85c39129 != nil {
		return *x.ref85c39129, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsCreationInfo) Deref() {
	if x.ref85c39129 == nil {
		return
	}
	x.Objectname = *NewTpm2bNameRef(unsafe.Pointer(&x.ref85c39129.objectName))
	x.Creationhash = *NewTpm2bDigestRef(unsafe.Pointer(&x.ref85c39129.creationHash))
}

// allocTpmsNvCertifyInfoMemory allocates memory for type C.TPMS_NV_CERTIFY_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsNvCertifyInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsNvCertifyInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsNvCertifyInfoValue = unsafe.Sizeof([1]C.TPMS_NV_CERTIFY_INFO{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsNvCertifyInfo) Ref() *C.TPMS_NV_CERTIFY_INFO {
	if x == nil {
		return nil
	}
	return x.ref24c11787
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsNvCertifyInfo) Free() {
	if x != nil && x.allocs24c11787 != nil {
		x.allocs24c11787.(*cgoAllocMap).Free()
		x.ref24c11787 = nil
	}
}

// NewTpmsNvCertifyInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsNvCertifyInfoRef(ref unsafe.Pointer) *TpmsNvCertifyInfo {
	if ref == nil {
		return nil
	}
	obj := new(TpmsNvCertifyInfo)
	obj.ref24c11787 = (*C.TPMS_NV_CERTIFY_INFO)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsNvCertifyInfo) PassRef() (*C.TPMS_NV_CERTIFY_INFO, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref24c11787 != nil {
		return x.ref24c11787, nil
	}
	mem24c11787 := allocTpmsNvCertifyInfoMemory(1)
	ref24c11787 := (*C.TPMS_NV_CERTIFY_INFO)(mem24c11787)
	allocs24c11787 := new(cgoAllocMap)
	allocs24c11787.Add(mem24c11787)

	var cindexName_allocs *cgoAllocMap
	ref24c11787.indexName, cindexName_allocs = x.Indexname.PassValue()
	allocs24c11787.Borrow(cindexName_allocs)

	var coffset_allocs *cgoAllocMap
	ref24c11787.offset, coffset_allocs = (C.UINT16)(x.Offset), cgoAllocsUnknown
	allocs24c11787.Borrow(coffset_allocs)

	var cnvContents_allocs *cgoAllocMap
	ref24c11787.nvContents, cnvContents_allocs = x.Nvcontents.PassValue()
	allocs24c11787.Borrow(cnvContents_allocs)

	x.ref24c11787 = ref24c11787
	x.allocs24c11787 = allocs24c11787
	return ref24c11787, allocs24c11787

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsNvCertifyInfo) PassValue() (C.TPMS_NV_CERTIFY_INFO, *cgoAllocMap) {
	if x.ref24c11787 != nil {
		return *x.ref24c11787, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsNvCertifyInfo) Deref() {
	if x.ref24c11787 == nil {
		return
	}
	x.Indexname = *NewTpm2bNameRef(unsafe.Pointer(&x.ref24c11787.indexName))
	x.Offset = (Uint16)(x.ref24c11787.offset)
	x.Nvcontents = *NewTpm2bMaxNvBufferRef(unsafe.Pointer(&x.ref24c11787.nvContents))
}

// allocTpmsAttestMemory allocates memory for type C.TPMS_ATTEST in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsAttestMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsAttestValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsAttestValue = unsafe.Sizeof([1]C.TPMS_ATTEST{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsAttest) Ref() *C.TPMS_ATTEST {
	if x == nil {
		return nil
	}
	return x.reffd24ec4f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsAttest) Free() {
	if x != nil && x.allocsfd24ec4f != nil {
		x.allocsfd24ec4f.(*cgoAllocMap).Free()
		x.reffd24ec4f = nil
	}
}

// NewTpmsAttestRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsAttestRef(ref unsafe.Pointer) *TpmsAttest {
	if ref == nil {
		return nil
	}
	obj := new(TpmsAttest)
	obj.reffd24ec4f = (*C.TPMS_ATTEST)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsAttest) PassRef() (*C.TPMS_ATTEST, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffd24ec4f != nil {
		return x.reffd24ec4f, nil
	}
	memfd24ec4f := allocTpmsAttestMemory(1)
	reffd24ec4f := (*C.TPMS_ATTEST)(memfd24ec4f)
	allocsfd24ec4f := new(cgoAllocMap)
	allocsfd24ec4f.Add(memfd24ec4f)

	var cmagic_allocs *cgoAllocMap
	reffd24ec4f.magic, cmagic_allocs = (C.TPM2_GENERATED)(x.Magic), cgoAllocsUnknown
	allocsfd24ec4f.Borrow(cmagic_allocs)

	var c_type_allocs *cgoAllocMap
	reffd24ec4f._type, c_type_allocs = (C.TPMI_ST_ATTEST)(x.Type), cgoAllocsUnknown
	allocsfd24ec4f.Borrow(c_type_allocs)

	var cqualifiedSigner_allocs *cgoAllocMap
	reffd24ec4f.qualifiedSigner, cqualifiedSigner_allocs = x.Qualifiedsigner.PassValue()
	allocsfd24ec4f.Borrow(cqualifiedSigner_allocs)

	var cextraData_allocs *cgoAllocMap
	reffd24ec4f.extraData, cextraData_allocs = x.Extradata.PassValue()
	allocsfd24ec4f.Borrow(cextraData_allocs)

	var cclockInfo_allocs *cgoAllocMap
	reffd24ec4f.clockInfo, cclockInfo_allocs = x.Clockinfo.PassValue()
	allocsfd24ec4f.Borrow(cclockInfo_allocs)

	var cfirmwareVersion_allocs *cgoAllocMap
	reffd24ec4f.firmwareVersion, cfirmwareVersion_allocs = (C.UINT64)(x.Firmwareversion), cgoAllocsUnknown
	allocsfd24ec4f.Borrow(cfirmwareVersion_allocs)

	var cattested_allocs *cgoAllocMap
	reffd24ec4f.attested, cattested_allocs = *(*C.TPMU_ATTEST)(unsafe.Pointer(&x.Attested)), cgoAllocsUnknown
	allocsfd24ec4f.Borrow(cattested_allocs)

	x.reffd24ec4f = reffd24ec4f
	x.allocsfd24ec4f = allocsfd24ec4f
	return reffd24ec4f, allocsfd24ec4f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsAttest) PassValue() (C.TPMS_ATTEST, *cgoAllocMap) {
	if x.reffd24ec4f != nil {
		return *x.reffd24ec4f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsAttest) Deref() {
	if x.reffd24ec4f == nil {
		return
	}
	x.Magic = (Tpm2Generated)(x.reffd24ec4f.magic)
	x.Type = (TpmiStAttest)(x.reffd24ec4f._type)
	x.Qualifiedsigner = *NewTpm2bNameRef(unsafe.Pointer(&x.reffd24ec4f.qualifiedSigner))
	x.Extradata = *NewTpm2bDataRef(unsafe.Pointer(&x.reffd24ec4f.extraData))
	x.Clockinfo = *NewTpmsClockInfoRef(unsafe.Pointer(&x.reffd24ec4f.clockInfo))
	x.Firmwareversion = (Uint64)(x.reffd24ec4f.firmwareVersion)
	x.Attested = *(*TpmuAttest)(unsafe.Pointer(&x.reffd24ec4f.attested))
}

// allocTpm2bAttestMemory allocates memory for type C.TPM2B_ATTEST in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bAttestMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bAttestValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bAttestValue = unsafe.Sizeof([1]C.TPM2B_ATTEST{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Tpm2bAttest) Ref() *C.TPM2B_ATTEST {
	if x == nil {
		return nil
	}
	return x.ref2f89bed4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Tpm2bAttest) Free() {
	if x != nil && x.allocs2f89bed4 != nil {
		x.allocs2f89bed4.(*cgoAllocMap).Free()
		x.ref2f89bed4 = nil
	}
}

// NewTpm2bAttestRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpm2bAttestRef(ref unsafe.Pointer) *Tpm2bAttest {
	if ref == nil {
		return nil
	}
	obj := new(Tpm2bAttest)
	obj.ref2f89bed4 = (*C.TPM2B_ATTEST)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Tpm2bAttest) PassRef() (*C.TPM2B_ATTEST, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2f89bed4 != nil {
		return x.ref2f89bed4, nil
	}
	mem2f89bed4 := allocTpm2bAttestMemory(1)
	ref2f89bed4 := (*C.TPM2B_ATTEST)(mem2f89bed4)
	allocs2f89bed4 := new(cgoAllocMap)
	allocs2f89bed4.Add(mem2f89bed4)

	var csize_allocs *cgoAllocMap
	ref2f89bed4.size, csize_allocs = (C.UINT16)(x.Size), cgoAllocsUnknown
	allocs2f89bed4.Borrow(csize_allocs)

	var cattestationData_allocs *cgoAllocMap
	ref2f89bed4.attestationData, cattestationData_allocs = *(*[2304]C.BYTE)(unsafe.Pointer(&x.Attestationdata)), cgoAllocsUnknown
	allocs2f89bed4.Borrow(cattestationData_allocs)

	x.ref2f89bed4 = ref2f89bed4
	x.allocs2f89bed4 = allocs2f89bed4
	return ref2f89bed4, allocs2f89bed4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Tpm2bAttest) PassValue() (C.TPM2B_ATTEST, *cgoAllocMap) {
	if x.ref2f89bed4 != nil {
		return *x.ref2f89bed4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Tpm2bAttest) Deref() {
	if x.ref2f89bed4 == nil {
		return
	}
	x.Size = (Uint16)(x.ref2f89bed4.size)
	x.Attestationdata = *(*[2304]Byte)(unsafe.Pointer(&x.ref2f89bed4.attestationData))
}

// allocTpmsAuthCommandMemory allocates memory for type C.TPMS_AUTH_COMMAND in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsAuthCommandMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsAuthCommandValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsAuthCommandValue = unsafe.Sizeof([1]C.TPMS_AUTH_COMMAND{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsAuthCommand) Ref() *C.TPMS_AUTH_COMMAND {
	if x == nil {
		return nil
	}
	return x.refacb3c0e2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsAuthCommand) Free() {
	if x != nil && x.allocsacb3c0e2 != nil {
		x.allocsacb3c0e2.(*cgoAllocMap).Free()
		x.refacb3c0e2 = nil
	}
}

// NewTpmsAuthCommandRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsAuthCommandRef(ref unsafe.Pointer) *TpmsAuthCommand {
	if ref == nil {
		return nil
	}
	obj := new(TpmsAuthCommand)
	obj.refacb3c0e2 = (*C.TPMS_AUTH_COMMAND)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsAuthCommand) PassRef() (*C.TPMS_AUTH_COMMAND, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refacb3c0e2 != nil {
		return x.refacb3c0e2, nil
	}
	memacb3c0e2 := allocTpmsAuthCommandMemory(1)
	refacb3c0e2 := (*C.TPMS_AUTH_COMMAND)(memacb3c0e2)
	allocsacb3c0e2 := new(cgoAllocMap)
	allocsacb3c0e2.Add(memacb3c0e2)

	var csessionHandle_allocs *cgoAllocMap
	refacb3c0e2.sessionHandle, csessionHandle_allocs = (C.TPMI_SH_AUTH_SESSION)(x.Sessionhandle), cgoAllocsUnknown
	allocsacb3c0e2.Borrow(csessionHandle_allocs)

	var cnonce_allocs *cgoAllocMap
	refacb3c0e2.nonce, cnonce_allocs = x.Nonce.PassValue()
	allocsacb3c0e2.Borrow(cnonce_allocs)

	var csessionAttributes_allocs *cgoAllocMap
	refacb3c0e2.sessionAttributes, csessionAttributes_allocs = (C.TPMA_SESSION)(x.Sessionattributes), cgoAllocsUnknown
	allocsacb3c0e2.Borrow(csessionAttributes_allocs)

	var chmac_allocs *cgoAllocMap
	refacb3c0e2.hmac, chmac_allocs = x.Hmac.PassValue()
	allocsacb3c0e2.Borrow(chmac_allocs)

	x.refacb3c0e2 = refacb3c0e2
	x.allocsacb3c0e2 = allocsacb3c0e2
	return refacb3c0e2, allocsacb3c0e2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsAuthCommand) PassValue() (C.TPMS_AUTH_COMMAND, *cgoAllocMap) {
	if x.refacb3c0e2 != nil {
		return *x.refacb3c0e2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsAuthCommand) Deref() {
	if x.refacb3c0e2 == nil {
		return
	}
	x.Sessionhandle = (TpmiShAuthSession)(x.refacb3c0e2.sessionHandle)
	x.Nonce = *NewTpm2bNonceRef(unsafe.Pointer(&x.refacb3c0e2.nonce))
	x.Sessionattributes = (TpmaSession)(x.refacb3c0e2.sessionAttributes)
	x.Hmac = *NewTpm2bAuthRef(unsafe.Pointer(&x.refacb3c0e2.hmac))
}

// allocTpmsAuthResponseMemory allocates memory for type C.TPMS_AUTH_RESPONSE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsAuthResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsAuthResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsAuthResponseValue = unsafe.Sizeof([1]C.TPMS_AUTH_RESPONSE{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsAuthResponse) Ref() *C.TPMS_AUTH_RESPONSE {
	if x == nil {
		return nil
	}
	return x.refca8dc780
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsAuthResponse) Free() {
	if x != nil && x.allocsca8dc780 != nil {
		x.allocsca8dc780.(*cgoAllocMap).Free()
		x.refca8dc780 = nil
	}
}

// NewTpmsAuthResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsAuthResponseRef(ref unsafe.Pointer) *TpmsAuthResponse {
	if ref == nil {
		return nil
	}
	obj := new(TpmsAuthResponse)
	obj.refca8dc780 = (*C.TPMS_AUTH_RESPONSE)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsAuthResponse) PassRef() (*C.TPMS_AUTH_RESPONSE, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refca8dc780 != nil {
		return x.refca8dc780, nil
	}
	memca8dc780 := allocTpmsAuthResponseMemory(1)
	refca8dc780 := (*C.TPMS_AUTH_RESPONSE)(memca8dc780)
	allocsca8dc780 := new(cgoAllocMap)
	allocsca8dc780.Add(memca8dc780)

	var cnonce_allocs *cgoAllocMap
	refca8dc780.nonce, cnonce_allocs = x.Nonce.PassValue()
	allocsca8dc780.Borrow(cnonce_allocs)

	var csessionAttributes_allocs *cgoAllocMap
	refca8dc780.sessionAttributes, csessionAttributes_allocs = (C.TPMA_SESSION)(x.Sessionattributes), cgoAllocsUnknown
	allocsca8dc780.Borrow(csessionAttributes_allocs)

	var chmac_allocs *cgoAllocMap
	refca8dc780.hmac, chmac_allocs = x.Hmac.PassValue()
	allocsca8dc780.Borrow(chmac_allocs)

	x.refca8dc780 = refca8dc780
	x.allocsca8dc780 = allocsca8dc780
	return refca8dc780, allocsca8dc780

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsAuthResponse) PassValue() (C.TPMS_AUTH_RESPONSE, *cgoAllocMap) {
	if x.refca8dc780 != nil {
		return *x.refca8dc780, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsAuthResponse) Deref() {
	if x.refca8dc780 == nil {
		return
	}
	x.Nonce = *NewTpm2bNonceRef(unsafe.Pointer(&x.refca8dc780.nonce))
	x.Sessionattributes = (TpmaSession)(x.refca8dc780.sessionAttributes)
	x.Hmac = *NewTpm2bAuthRef(unsafe.Pointer(&x.refca8dc780.hmac))
}

// allocTpmtSymDefMemory allocates memory for type C.TPMT_SYM_DEF in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtSymDefMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtSymDefValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtSymDefValue = unsafe.Sizeof([1]C.TPMT_SYM_DEF{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmtSymDef) Ref() *C.TPMT_SYM_DEF {
	if x == nil {
		return nil
	}
	return x.ref9b7954d8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmtSymDef) Free() {
	if x != nil && x.allocs9b7954d8 != nil {
		x.allocs9b7954d8.(*cgoAllocMap).Free()
		x.ref9b7954d8 = nil
	}
}

// NewTpmtSymDefRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmtSymDefRef(ref unsafe.Pointer) *TpmtSymDef {
	if ref == nil {
		return nil
	}
	obj := new(TpmtSymDef)
	obj.ref9b7954d8 = (*C.TPMT_SYM_DEF)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmtSymDef) PassRef() (*C.TPMT_SYM_DEF, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9b7954d8 != nil {
		return x.ref9b7954d8, nil
	}
	mem9b7954d8 := allocTpmtSymDefMemory(1)
	ref9b7954d8 := (*C.TPMT_SYM_DEF)(mem9b7954d8)
	allocs9b7954d8 := new(cgoAllocMap)
	allocs9b7954d8.Add(mem9b7954d8)

	var calgorithm_allocs *cgoAllocMap
	ref9b7954d8.algorithm, calgorithm_allocs = (C.TPMI_ALG_SYM)(x.Algorithm), cgoAllocsUnknown
	allocs9b7954d8.Borrow(calgorithm_allocs)

	var ckeyBits_allocs *cgoAllocMap
	ref9b7954d8.keyBits, ckeyBits_allocs = *(*C.TPMU_SYM_KEY_BITS)(unsafe.Pointer(&x.Keybits)), cgoAllocsUnknown
	allocs9b7954d8.Borrow(ckeyBits_allocs)

	var cmode_allocs *cgoAllocMap
	ref9b7954d8.mode, cmode_allocs = *(*C.TPMU_SYM_MODE)(unsafe.Pointer(&x.Mode)), cgoAllocsUnknown
	allocs9b7954d8.Borrow(cmode_allocs)

	x.ref9b7954d8 = ref9b7954d8
	x.allocs9b7954d8 = allocs9b7954d8
	return ref9b7954d8, allocs9b7954d8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmtSymDef) PassValue() (C.TPMT_SYM_DEF, *cgoAllocMap) {
	if x.ref9b7954d8 != nil {
		return *x.ref9b7954d8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmtSymDef) Deref() {
	if x.ref9b7954d8 == nil {
		return
	}
	x.Algorithm = (TpmiAlgSym)(x.ref9b7954d8.algorithm)
	x.Keybits = *(*TpmuSymKeyBits)(unsafe.Pointer(&x.ref9b7954d8.keyBits))
	x.Mode = *(*TpmuSymMode)(unsafe.Pointer(&x.ref9b7954d8.mode))
}

// allocTpmtSymDefObjectMemory allocates memory for type C.TPMT_SYM_DEF_OBJECT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtSymDefObjectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtSymDefObjectValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtSymDefObjectValue = unsafe.Sizeof([1]C.TPMT_SYM_DEF_OBJECT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmtSymDefObject) Ref() *C.TPMT_SYM_DEF_OBJECT {
	if x == nil {
		return nil
	}
	return x.ref30d66831
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmtSymDefObject) Free() {
	if x != nil && x.allocs30d66831 != nil {
		x.allocs30d66831.(*cgoAllocMap).Free()
		x.ref30d66831 = nil
	}
}

// NewTpmtSymDefObjectRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmtSymDefObjectRef(ref unsafe.Pointer) *TpmtSymDefObject {
	if ref == nil {
		return nil
	}
	obj := new(TpmtSymDefObject)
	obj.ref30d66831 = (*C.TPMT_SYM_DEF_OBJECT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmtSymDefObject) PassRef() (*C.TPMT_SYM_DEF_OBJECT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref30d66831 != nil {
		return x.ref30d66831, nil
	}
	mem30d66831 := allocTpmtSymDefObjectMemory(1)
	ref30d66831 := (*C.TPMT_SYM_DEF_OBJECT)(mem30d66831)
	allocs30d66831 := new(cgoAllocMap)
	allocs30d66831.Add(mem30d66831)

	var calgorithm_allocs *cgoAllocMap
	ref30d66831.algorithm, calgorithm_allocs = (C.TPMI_ALG_SYM_OBJECT)(x.Algorithm), cgoAllocsUnknown
	allocs30d66831.Borrow(calgorithm_allocs)

	var ckeyBits_allocs *cgoAllocMap
	ref30d66831.keyBits, ckeyBits_allocs = *(*C.TPMU_SYM_KEY_BITS)(unsafe.Pointer(&x.Keybits)), cgoAllocsUnknown
	allocs30d66831.Borrow(ckeyBits_allocs)

	var cmode_allocs *cgoAllocMap
	ref30d66831.mode, cmode_allocs = *(*C.TPMU_SYM_MODE)(unsafe.Pointer(&x.Mode)), cgoAllocsUnknown
	allocs30d66831.Borrow(cmode_allocs)

	x.ref30d66831 = ref30d66831
	x.allocs30d66831 = allocs30d66831
	return ref30d66831, allocs30d66831

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmtSymDefObject) PassValue() (C.TPMT_SYM_DEF_OBJECT, *cgoAllocMap) {
	if x.ref30d66831 != nil {
		return *x.ref30d66831, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmtSymDefObject) Deref() {
	if x.ref30d66831 == nil {
		return
	}
	x.Algorithm = (TpmiAlgSymObject)(x.ref30d66831.algorithm)
	x.Keybits = *(*TpmuSymKeyBits)(unsafe.Pointer(&x.ref30d66831.keyBits))
	x.Mode = *(*TpmuSymMode)(unsafe.Pointer(&x.ref30d66831.mode))
}

// allocTpm2bSymKeyMemory allocates memory for type C.TPM2B_SYM_KEY in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bSymKeyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bSymKeyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bSymKeyValue = unsafe.Sizeof([1]C.TPM2B_SYM_KEY{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Tpm2bSymKey) Ref() *C.TPM2B_SYM_KEY {
	if x == nil {
		return nil
	}
	return x.ref1e439447
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Tpm2bSymKey) Free() {
	if x != nil && x.allocs1e439447 != nil {
		x.allocs1e439447.(*cgoAllocMap).Free()
		x.ref1e439447 = nil
	}
}

// NewTpm2bSymKeyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpm2bSymKeyRef(ref unsafe.Pointer) *Tpm2bSymKey {
	if ref == nil {
		return nil
	}
	obj := new(Tpm2bSymKey)
	obj.ref1e439447 = (*C.TPM2B_SYM_KEY)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Tpm2bSymKey) PassRef() (*C.TPM2B_SYM_KEY, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1e439447 != nil {
		return x.ref1e439447, nil
	}
	mem1e439447 := allocTpm2bSymKeyMemory(1)
	ref1e439447 := (*C.TPM2B_SYM_KEY)(mem1e439447)
	allocs1e439447 := new(cgoAllocMap)
	allocs1e439447.Add(mem1e439447)

	var csize_allocs *cgoAllocMap
	ref1e439447.size, csize_allocs = (C.UINT16)(x.Size), cgoAllocsUnknown
	allocs1e439447.Borrow(csize_allocs)

	var cbuffer_allocs *cgoAllocMap
	ref1e439447.buffer, cbuffer_allocs = *(*[32]C.BYTE)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocs1e439447.Borrow(cbuffer_allocs)

	x.ref1e439447 = ref1e439447
	x.allocs1e439447 = allocs1e439447
	return ref1e439447, allocs1e439447

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Tpm2bSymKey) PassValue() (C.TPM2B_SYM_KEY, *cgoAllocMap) {
	if x.ref1e439447 != nil {
		return *x.ref1e439447, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Tpm2bSymKey) Deref() {
	if x.ref1e439447 == nil {
		return
	}
	x.Size = (Uint16)(x.ref1e439447.size)
	x.Buffer = *(*[32]Byte)(unsafe.Pointer(&x.ref1e439447.buffer))
}

// allocTpmsSymcipherParmsMemory allocates memory for type C.TPMS_SYMCIPHER_PARMS in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsSymcipherParmsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsSymcipherParmsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsSymcipherParmsValue = unsafe.Sizeof([1]C.TPMS_SYMCIPHER_PARMS{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsSymcipherParms) Ref() *C.TPMS_SYMCIPHER_PARMS {
	if x == nil {
		return nil
	}
	return x.refed33801d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsSymcipherParms) Free() {
	if x != nil && x.allocsed33801d != nil {
		x.allocsed33801d.(*cgoAllocMap).Free()
		x.refed33801d = nil
	}
}

// NewTpmsSymcipherParmsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsSymcipherParmsRef(ref unsafe.Pointer) *TpmsSymcipherParms {
	if ref == nil {
		return nil
	}
	obj := new(TpmsSymcipherParms)
	obj.refed33801d = (*C.TPMS_SYMCIPHER_PARMS)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsSymcipherParms) PassRef() (*C.TPMS_SYMCIPHER_PARMS, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refed33801d != nil {
		return x.refed33801d, nil
	}
	memed33801d := allocTpmsSymcipherParmsMemory(1)
	refed33801d := (*C.TPMS_SYMCIPHER_PARMS)(memed33801d)
	allocsed33801d := new(cgoAllocMap)
	allocsed33801d.Add(memed33801d)

	var csym_allocs *cgoAllocMap
	refed33801d.sym, csym_allocs = x.Sym.PassValue()
	allocsed33801d.Borrow(csym_allocs)

	x.refed33801d = refed33801d
	x.allocsed33801d = allocsed33801d
	return refed33801d, allocsed33801d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsSymcipherParms) PassValue() (C.TPMS_SYMCIPHER_PARMS, *cgoAllocMap) {
	if x.refed33801d != nil {
		return *x.refed33801d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsSymcipherParms) Deref() {
	if x.refed33801d == nil {
		return
	}
	x.Sym = *NewTpmtSymDefObjectRef(unsafe.Pointer(&x.refed33801d.sym))
}

// allocTpm2bSensitiveDataMemory allocates memory for type C.TPM2B_SENSITIVE_DATA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bSensitiveDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bSensitiveDataValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bSensitiveDataValue = unsafe.Sizeof([1]C.TPM2B_SENSITIVE_DATA{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Tpm2bSensitiveData) Ref() *C.TPM2B_SENSITIVE_DATA {
	if x == nil {
		return nil
	}
	return x.refba9ff458
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Tpm2bSensitiveData) Free() {
	if x != nil && x.allocsba9ff458 != nil {
		x.allocsba9ff458.(*cgoAllocMap).Free()
		x.refba9ff458 = nil
	}
}

// NewTpm2bSensitiveDataRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpm2bSensitiveDataRef(ref unsafe.Pointer) *Tpm2bSensitiveData {
	if ref == nil {
		return nil
	}
	obj := new(Tpm2bSensitiveData)
	obj.refba9ff458 = (*C.TPM2B_SENSITIVE_DATA)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Tpm2bSensitiveData) PassRef() (*C.TPM2B_SENSITIVE_DATA, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refba9ff458 != nil {
		return x.refba9ff458, nil
	}
	memba9ff458 := allocTpm2bSensitiveDataMemory(1)
	refba9ff458 := (*C.TPM2B_SENSITIVE_DATA)(memba9ff458)
	allocsba9ff458 := new(cgoAllocMap)
	allocsba9ff458.Add(memba9ff458)

	var csize_allocs *cgoAllocMap
	refba9ff458.size, csize_allocs = (C.UINT16)(x.Size), cgoAllocsUnknown
	allocsba9ff458.Borrow(csize_allocs)

	var cbuffer_allocs *cgoAllocMap
	refba9ff458.buffer, cbuffer_allocs = *(*[256]C.BYTE)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocsba9ff458.Borrow(cbuffer_allocs)

	x.refba9ff458 = refba9ff458
	x.allocsba9ff458 = allocsba9ff458
	return refba9ff458, allocsba9ff458

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Tpm2bSensitiveData) PassValue() (C.TPM2B_SENSITIVE_DATA, *cgoAllocMap) {
	if x.refba9ff458 != nil {
		return *x.refba9ff458, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Tpm2bSensitiveData) Deref() {
	if x.refba9ff458 == nil {
		return
	}
	x.Size = (Uint16)(x.refba9ff458.size)
	x.Buffer = *(*[256]Byte)(unsafe.Pointer(&x.refba9ff458.buffer))
}

// allocTpmsSensitiveCreateMemory allocates memory for type C.TPMS_SENSITIVE_CREATE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsSensitiveCreateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsSensitiveCreateValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsSensitiveCreateValue = unsafe.Sizeof([1]C.TPMS_SENSITIVE_CREATE{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsSensitiveCreate) Ref() *C.TPMS_SENSITIVE_CREATE {
	if x == nil {
		return nil
	}
	return x.refeb1173b9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsSensitiveCreate) Free() {
	if x != nil && x.allocseb1173b9 != nil {
		x.allocseb1173b9.(*cgoAllocMap).Free()
		x.refeb1173b9 = nil
	}
}

// NewTpmsSensitiveCreateRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsSensitiveCreateRef(ref unsafe.Pointer) *TpmsSensitiveCreate {
	if ref == nil {
		return nil
	}
	obj := new(TpmsSensitiveCreate)
	obj.refeb1173b9 = (*C.TPMS_SENSITIVE_CREATE)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsSensitiveCreate) PassRef() (*C.TPMS_SENSITIVE_CREATE, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refeb1173b9 != nil {
		return x.refeb1173b9, nil
	}
	memeb1173b9 := allocTpmsSensitiveCreateMemory(1)
	refeb1173b9 := (*C.TPMS_SENSITIVE_CREATE)(memeb1173b9)
	allocseb1173b9 := new(cgoAllocMap)
	allocseb1173b9.Add(memeb1173b9)

	var cuserAuth_allocs *cgoAllocMap
	refeb1173b9.userAuth, cuserAuth_allocs = x.Userauth.PassValue()
	allocseb1173b9.Borrow(cuserAuth_allocs)

	var cdata_allocs *cgoAllocMap
	refeb1173b9.data, cdata_allocs = x.Data.PassValue()
	allocseb1173b9.Borrow(cdata_allocs)

	x.refeb1173b9 = refeb1173b9
	x.allocseb1173b9 = allocseb1173b9
	return refeb1173b9, allocseb1173b9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsSensitiveCreate) PassValue() (C.TPMS_SENSITIVE_CREATE, *cgoAllocMap) {
	if x.refeb1173b9 != nil {
		return *x.refeb1173b9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsSensitiveCreate) Deref() {
	if x.refeb1173b9 == nil {
		return
	}
	x.Userauth = *NewTpm2bAuthRef(unsafe.Pointer(&x.refeb1173b9.userAuth))
	x.Data = *NewTpm2bSensitiveDataRef(unsafe.Pointer(&x.refeb1173b9.data))
}

// allocTpm2bSensitiveCreateMemory allocates memory for type C.TPM2B_SENSITIVE_CREATE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bSensitiveCreateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bSensitiveCreateValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bSensitiveCreateValue = unsafe.Sizeof([1]C.TPM2B_SENSITIVE_CREATE{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Tpm2bSensitiveCreate) Ref() *C.TPM2B_SENSITIVE_CREATE {
	if x == nil {
		return nil
	}
	return x.ref83ea8966
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Tpm2bSensitiveCreate) Free() {
	if x != nil && x.allocs83ea8966 != nil {
		x.allocs83ea8966.(*cgoAllocMap).Free()
		x.ref83ea8966 = nil
	}
}

// NewTpm2bSensitiveCreateRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpm2bSensitiveCreateRef(ref unsafe.Pointer) *Tpm2bSensitiveCreate {
	if ref == nil {
		return nil
	}
	obj := new(Tpm2bSensitiveCreate)
	obj.ref83ea8966 = (*C.TPM2B_SENSITIVE_CREATE)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Tpm2bSensitiveCreate) PassRef() (*C.TPM2B_SENSITIVE_CREATE, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref83ea8966 != nil {
		return x.ref83ea8966, nil
	}
	mem83ea8966 := allocTpm2bSensitiveCreateMemory(1)
	ref83ea8966 := (*C.TPM2B_SENSITIVE_CREATE)(mem83ea8966)
	allocs83ea8966 := new(cgoAllocMap)
	allocs83ea8966.Add(mem83ea8966)

	var csize_allocs *cgoAllocMap
	ref83ea8966.size, csize_allocs = (C.UINT16)(x.Size), cgoAllocsUnknown
	allocs83ea8966.Borrow(csize_allocs)

	var csensitive_allocs *cgoAllocMap
	ref83ea8966.sensitive, csensitive_allocs = x.Sensitive.PassValue()
	allocs83ea8966.Borrow(csensitive_allocs)

	x.ref83ea8966 = ref83ea8966
	x.allocs83ea8966 = allocs83ea8966
	return ref83ea8966, allocs83ea8966

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Tpm2bSensitiveCreate) PassValue() (C.TPM2B_SENSITIVE_CREATE, *cgoAllocMap) {
	if x.ref83ea8966 != nil {
		return *x.ref83ea8966, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Tpm2bSensitiveCreate) Deref() {
	if x.ref83ea8966 == nil {
		return
	}
	x.Size = (Uint16)(x.ref83ea8966.size)
	x.Sensitive = *NewTpmsSensitiveCreateRef(unsafe.Pointer(&x.ref83ea8966.sensitive))
}

// allocTpmsSchemeHashMemory allocates memory for type C.TPMS_SCHEME_HASH in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsSchemeHashMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsSchemeHashValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsSchemeHashValue = unsafe.Sizeof([1]C.TPMS_SCHEME_HASH{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsSchemeHash) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return x.refe423df90
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsSchemeHash) Free() {
	if x != nil && x.allocse423df90 != nil {
		x.allocse423df90.(*cgoAllocMap).Free()
		x.refe423df90 = nil
	}
}

// NewTpmsSchemeHashRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsSchemeHashRef(ref unsafe.Pointer) *TpmsSchemeHash {
	if ref == nil {
		return nil
	}
	obj := new(TpmsSchemeHash)
	obj.refe423df90 = (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsSchemeHash) PassRef() (*C.TPMS_SCHEME_HASH, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe423df90 != nil {
		return x.refe423df90, nil
	}
	meme423df90 := allocTpmsSchemeHashMemory(1)
	refe423df90 := (*C.TPMS_SCHEME_HASH)(meme423df90)
	allocse423df90 := new(cgoAllocMap)
	allocse423df90.Add(meme423df90)

	var chashAlg_allocs *cgoAllocMap
	refe423df90.hashAlg, chashAlg_allocs = (C.TPMI_ALG_HASH)(x.Hashalg), cgoAllocsUnknown
	allocse423df90.Borrow(chashAlg_allocs)

	x.refe423df90 = refe423df90
	x.allocse423df90 = allocse423df90
	return refe423df90, allocse423df90

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsSchemeHash) PassValue() (C.TPMS_SCHEME_HASH, *cgoAllocMap) {
	if x.refe423df90 != nil {
		return *x.refe423df90, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsSchemeHash) Deref() {
	if x.refe423df90 == nil {
		return
	}
	x.Hashalg = (TpmiAlgHash)(x.refe423df90.hashAlg)
}

// allocTpmsSchemeEcdaaMemory allocates memory for type C.TPMS_SCHEME_ECDAA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsSchemeEcdaaMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsSchemeEcdaaValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsSchemeEcdaaValue = unsafe.Sizeof([1]C.TPMS_SCHEME_ECDAA{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsSchemeEcdaa) Ref() *C.TPMS_SCHEME_ECDAA {
	if x == nil {
		return nil
	}
	return x.refb9002c96
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsSchemeEcdaa) Free() {
	if x != nil && x.allocsb9002c96 != nil {
		x.allocsb9002c96.(*cgoAllocMap).Free()
		x.refb9002c96 = nil
	}
}

// NewTpmsSchemeEcdaaRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsSchemeEcdaaRef(ref unsafe.Pointer) *TpmsSchemeEcdaa {
	if ref == nil {
		return nil
	}
	obj := new(TpmsSchemeEcdaa)
	obj.refb9002c96 = (*C.TPMS_SCHEME_ECDAA)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsSchemeEcdaa) PassRef() (*C.TPMS_SCHEME_ECDAA, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb9002c96 != nil {
		return x.refb9002c96, nil
	}
	memb9002c96 := allocTpmsSchemeEcdaaMemory(1)
	refb9002c96 := (*C.TPMS_SCHEME_ECDAA)(memb9002c96)
	allocsb9002c96 := new(cgoAllocMap)
	allocsb9002c96.Add(memb9002c96)

	var chashAlg_allocs *cgoAllocMap
	refb9002c96.hashAlg, chashAlg_allocs = (C.TPMI_ALG_HASH)(x.Hashalg), cgoAllocsUnknown
	allocsb9002c96.Borrow(chashAlg_allocs)

	var ccount_allocs *cgoAllocMap
	refb9002c96.count, ccount_allocs = (C.UINT16)(x.Count), cgoAllocsUnknown
	allocsb9002c96.Borrow(ccount_allocs)

	x.refb9002c96 = refb9002c96
	x.allocsb9002c96 = allocsb9002c96
	return refb9002c96, allocsb9002c96

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsSchemeEcdaa) PassValue() (C.TPMS_SCHEME_ECDAA, *cgoAllocMap) {
	if x.refb9002c96 != nil {
		return *x.refb9002c96, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsSchemeEcdaa) Deref() {
	if x.refb9002c96 == nil {
		return
	}
	x.Hashalg = (TpmiAlgHash)(x.refb9002c96.hashAlg)
	x.Count = (Uint16)(x.refb9002c96.count)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsSchemeHmac) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return x.refe423df90
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsSchemeHmac) Free() {
	if x != nil && x.allocse423df90 != nil {
		x.allocse423df90.(*cgoAllocMap).Free()
		x.refe423df90 = nil
	}
}

// NewTpmsSchemeHmacRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsSchemeHmacRef(ref unsafe.Pointer) *TpmsSchemeHmac {
	if ref == nil {
		return nil
	}
	obj := new(TpmsSchemeHmac)
	obj.refe423df90 = (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsSchemeHmac) PassRef() (*C.TPMS_SCHEME_HASH, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe423df90 != nil {
		return x.refe423df90, nil
	}
	meme423df90 := allocTpmsSchemeHashMemory(1)
	refe423df90 := (*C.TPMS_SCHEME_HASH)(meme423df90)
	allocse423df90 := new(cgoAllocMap)
	allocse423df90.Add(meme423df90)

	var chashAlg_allocs *cgoAllocMap
	refe423df90.hashAlg, chashAlg_allocs = (C.TPMI_ALG_HASH)(x.Hashalg), cgoAllocsUnknown
	allocse423df90.Borrow(chashAlg_allocs)

	x.refe423df90 = refe423df90
	x.allocse423df90 = allocse423df90
	return refe423df90, allocse423df90

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsSchemeHmac) PassValue() (C.TPMS_SCHEME_HASH, *cgoAllocMap) {
	if x.refe423df90 != nil {
		return *x.refe423df90, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsSchemeHmac) Deref() {
	if x.refe423df90 == nil {
		return
	}
	x.Hashalg = (TpmiAlgHash)(x.refe423df90.hashAlg)
}

// allocTpmsSchemeXorMemory allocates memory for type C.TPMS_SCHEME_XOR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsSchemeXorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsSchemeXorValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsSchemeXorValue = unsafe.Sizeof([1]C.TPMS_SCHEME_XOR{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsSchemeXor) Ref() *C.TPMS_SCHEME_XOR {
	if x == nil {
		return nil
	}
	return x.refd7d8558a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsSchemeXor) Free() {
	if x != nil && x.allocsd7d8558a != nil {
		x.allocsd7d8558a.(*cgoAllocMap).Free()
		x.refd7d8558a = nil
	}
}

// NewTpmsSchemeXorRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsSchemeXorRef(ref unsafe.Pointer) *TpmsSchemeXor {
	if ref == nil {
		return nil
	}
	obj := new(TpmsSchemeXor)
	obj.refd7d8558a = (*C.TPMS_SCHEME_XOR)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsSchemeXor) PassRef() (*C.TPMS_SCHEME_XOR, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd7d8558a != nil {
		return x.refd7d8558a, nil
	}
	memd7d8558a := allocTpmsSchemeXorMemory(1)
	refd7d8558a := (*C.TPMS_SCHEME_XOR)(memd7d8558a)
	allocsd7d8558a := new(cgoAllocMap)
	allocsd7d8558a.Add(memd7d8558a)

	var chashAlg_allocs *cgoAllocMap
	refd7d8558a.hashAlg, chashAlg_allocs = (C.TPMI_ALG_HASH)(x.Hashalg), cgoAllocsUnknown
	allocsd7d8558a.Borrow(chashAlg_allocs)

	var ckdf_allocs *cgoAllocMap
	refd7d8558a.kdf, ckdf_allocs = (C.TPMI_ALG_KDF)(x.Kdf), cgoAllocsUnknown
	allocsd7d8558a.Borrow(ckdf_allocs)

	x.refd7d8558a = refd7d8558a
	x.allocsd7d8558a = allocsd7d8558a
	return refd7d8558a, allocsd7d8558a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsSchemeXor) PassValue() (C.TPMS_SCHEME_XOR, *cgoAllocMap) {
	if x.refd7d8558a != nil {
		return *x.refd7d8558a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsSchemeXor) Deref() {
	if x.refd7d8558a == nil {
		return
	}
	x.Hashalg = (TpmiAlgHash)(x.refd7d8558a.hashAlg)
	x.Kdf = (TpmiAlgKdf)(x.refd7d8558a.kdf)
}

// allocTpmtKeyedhashSchemeMemory allocates memory for type C.TPMT_KEYEDHASH_SCHEME in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtKeyedhashSchemeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtKeyedhashSchemeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtKeyedhashSchemeValue = unsafe.Sizeof([1]C.TPMT_KEYEDHASH_SCHEME{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmtKeyedhashScheme) Ref() *C.TPMT_KEYEDHASH_SCHEME {
	if x == nil {
		return nil
	}
	return x.ref40a5159f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmtKeyedhashScheme) Free() {
	if x != nil && x.allocs40a5159f != nil {
		x.allocs40a5159f.(*cgoAllocMap).Free()
		x.ref40a5159f = nil
	}
}

// NewTpmtKeyedhashSchemeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmtKeyedhashSchemeRef(ref unsafe.Pointer) *TpmtKeyedhashScheme {
	if ref == nil {
		return nil
	}
	obj := new(TpmtKeyedhashScheme)
	obj.ref40a5159f = (*C.TPMT_KEYEDHASH_SCHEME)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmtKeyedhashScheme) PassRef() (*C.TPMT_KEYEDHASH_SCHEME, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref40a5159f != nil {
		return x.ref40a5159f, nil
	}
	mem40a5159f := allocTpmtKeyedhashSchemeMemory(1)
	ref40a5159f := (*C.TPMT_KEYEDHASH_SCHEME)(mem40a5159f)
	allocs40a5159f := new(cgoAllocMap)
	allocs40a5159f.Add(mem40a5159f)

	var cscheme_allocs *cgoAllocMap
	ref40a5159f.scheme, cscheme_allocs = (C.TPMI_ALG_KEYEDHASH_SCHEME)(x.Scheme), cgoAllocsUnknown
	allocs40a5159f.Borrow(cscheme_allocs)

	var cdetails_allocs *cgoAllocMap
	ref40a5159f.details, cdetails_allocs = *(*C.TPMU_SCHEME_KEYEDHASH)(unsafe.Pointer(&x.Details)), cgoAllocsUnknown
	allocs40a5159f.Borrow(cdetails_allocs)

	x.ref40a5159f = ref40a5159f
	x.allocs40a5159f = allocs40a5159f
	return ref40a5159f, allocs40a5159f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmtKeyedhashScheme) PassValue() (C.TPMT_KEYEDHASH_SCHEME, *cgoAllocMap) {
	if x.ref40a5159f != nil {
		return *x.ref40a5159f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmtKeyedhashScheme) Deref() {
	if x.ref40a5159f == nil {
		return
	}
	x.Scheme = (TpmiAlgKeyedhashScheme)(x.ref40a5159f.scheme)
	x.Details = *(*TpmuSchemeKeyedhash)(unsafe.Pointer(&x.ref40a5159f.details))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsSigSchemeRsassa) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return x.refe423df90
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsSigSchemeRsassa) Free() {
	if x != nil && x.allocse423df90 != nil {
		x.allocse423df90.(*cgoAllocMap).Free()
		x.refe423df90 = nil
	}
}

// NewTpmsSigSchemeRsassaRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsSigSchemeRsassaRef(ref unsafe.Pointer) *TpmsSigSchemeRsassa {
	if ref == nil {
		return nil
	}
	obj := new(TpmsSigSchemeRsassa)
	obj.refe423df90 = (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsSigSchemeRsassa) PassRef() (*C.TPMS_SCHEME_HASH, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe423df90 != nil {
		return x.refe423df90, nil
	}
	meme423df90 := allocTpmsSchemeHashMemory(1)
	refe423df90 := (*C.TPMS_SCHEME_HASH)(meme423df90)
	allocse423df90 := new(cgoAllocMap)
	allocse423df90.Add(meme423df90)

	var chashAlg_allocs *cgoAllocMap
	refe423df90.hashAlg, chashAlg_allocs = (C.TPMI_ALG_HASH)(x.Hashalg), cgoAllocsUnknown
	allocse423df90.Borrow(chashAlg_allocs)

	x.refe423df90 = refe423df90
	x.allocse423df90 = allocse423df90
	return refe423df90, allocse423df90

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsSigSchemeRsassa) PassValue() (C.TPMS_SCHEME_HASH, *cgoAllocMap) {
	if x.refe423df90 != nil {
		return *x.refe423df90, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsSigSchemeRsassa) Deref() {
	if x.refe423df90 == nil {
		return
	}
	x.Hashalg = (TpmiAlgHash)(x.refe423df90.hashAlg)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsSigSchemeRsapss) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return x.refe423df90
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsSigSchemeRsapss) Free() {
	if x != nil && x.allocse423df90 != nil {
		x.allocse423df90.(*cgoAllocMap).Free()
		x.refe423df90 = nil
	}
}

// NewTpmsSigSchemeRsapssRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsSigSchemeRsapssRef(ref unsafe.Pointer) *TpmsSigSchemeRsapss {
	if ref == nil {
		return nil
	}
	obj := new(TpmsSigSchemeRsapss)
	obj.refe423df90 = (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsSigSchemeRsapss) PassRef() (*C.TPMS_SCHEME_HASH, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe423df90 != nil {
		return x.refe423df90, nil
	}
	meme423df90 := allocTpmsSchemeHashMemory(1)
	refe423df90 := (*C.TPMS_SCHEME_HASH)(meme423df90)
	allocse423df90 := new(cgoAllocMap)
	allocse423df90.Add(meme423df90)

	var chashAlg_allocs *cgoAllocMap
	refe423df90.hashAlg, chashAlg_allocs = (C.TPMI_ALG_HASH)(x.Hashalg), cgoAllocsUnknown
	allocse423df90.Borrow(chashAlg_allocs)

	x.refe423df90 = refe423df90
	x.allocse423df90 = allocse423df90
	return refe423df90, allocse423df90

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsSigSchemeRsapss) PassValue() (C.TPMS_SCHEME_HASH, *cgoAllocMap) {
	if x.refe423df90 != nil {
		return *x.refe423df90, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsSigSchemeRsapss) Deref() {
	if x.refe423df90 == nil {
		return
	}
	x.Hashalg = (TpmiAlgHash)(x.refe423df90.hashAlg)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsSigSchemeEcdsa) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return x.refe423df90
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsSigSchemeEcdsa) Free() {
	if x != nil && x.allocse423df90 != nil {
		x.allocse423df90.(*cgoAllocMap).Free()
		x.refe423df90 = nil
	}
}

// NewTpmsSigSchemeEcdsaRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsSigSchemeEcdsaRef(ref unsafe.Pointer) *TpmsSigSchemeEcdsa {
	if ref == nil {
		return nil
	}
	obj := new(TpmsSigSchemeEcdsa)
	obj.refe423df90 = (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsSigSchemeEcdsa) PassRef() (*C.TPMS_SCHEME_HASH, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe423df90 != nil {
		return x.refe423df90, nil
	}
	meme423df90 := allocTpmsSchemeHashMemory(1)
	refe423df90 := (*C.TPMS_SCHEME_HASH)(meme423df90)
	allocse423df90 := new(cgoAllocMap)
	allocse423df90.Add(meme423df90)

	var chashAlg_allocs *cgoAllocMap
	refe423df90.hashAlg, chashAlg_allocs = (C.TPMI_ALG_HASH)(x.Hashalg), cgoAllocsUnknown
	allocse423df90.Borrow(chashAlg_allocs)

	x.refe423df90 = refe423df90
	x.allocse423df90 = allocse423df90
	return refe423df90, allocse423df90

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsSigSchemeEcdsa) PassValue() (C.TPMS_SCHEME_HASH, *cgoAllocMap) {
	if x.refe423df90 != nil {
		return *x.refe423df90, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsSigSchemeEcdsa) Deref() {
	if x.refe423df90 == nil {
		return
	}
	x.Hashalg = (TpmiAlgHash)(x.refe423df90.hashAlg)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsSigSchemeSm2) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return x.refe423df90
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsSigSchemeSm2) Free() {
	if x != nil && x.allocse423df90 != nil {
		x.allocse423df90.(*cgoAllocMap).Free()
		x.refe423df90 = nil
	}
}

// NewTpmsSigSchemeSm2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsSigSchemeSm2Ref(ref unsafe.Pointer) *TpmsSigSchemeSm2 {
	if ref == nil {
		return nil
	}
	obj := new(TpmsSigSchemeSm2)
	obj.refe423df90 = (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsSigSchemeSm2) PassRef() (*C.TPMS_SCHEME_HASH, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe423df90 != nil {
		return x.refe423df90, nil
	}
	meme423df90 := allocTpmsSchemeHashMemory(1)
	refe423df90 := (*C.TPMS_SCHEME_HASH)(meme423df90)
	allocse423df90 := new(cgoAllocMap)
	allocse423df90.Add(meme423df90)

	var chashAlg_allocs *cgoAllocMap
	refe423df90.hashAlg, chashAlg_allocs = (C.TPMI_ALG_HASH)(x.Hashalg), cgoAllocsUnknown
	allocse423df90.Borrow(chashAlg_allocs)

	x.refe423df90 = refe423df90
	x.allocse423df90 = allocse423df90
	return refe423df90, allocse423df90

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsSigSchemeSm2) PassValue() (C.TPMS_SCHEME_HASH, *cgoAllocMap) {
	if x.refe423df90 != nil {
		return *x.refe423df90, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsSigSchemeSm2) Deref() {
	if x.refe423df90 == nil {
		return
	}
	x.Hashalg = (TpmiAlgHash)(x.refe423df90.hashAlg)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsSigSchemeEcschnorr) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return x.refe423df90
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsSigSchemeEcschnorr) Free() {
	if x != nil && x.allocse423df90 != nil {
		x.allocse423df90.(*cgoAllocMap).Free()
		x.refe423df90 = nil
	}
}

// NewTpmsSigSchemeEcschnorrRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsSigSchemeEcschnorrRef(ref unsafe.Pointer) *TpmsSigSchemeEcschnorr {
	if ref == nil {
		return nil
	}
	obj := new(TpmsSigSchemeEcschnorr)
	obj.refe423df90 = (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsSigSchemeEcschnorr) PassRef() (*C.TPMS_SCHEME_HASH, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe423df90 != nil {
		return x.refe423df90, nil
	}
	meme423df90 := allocTpmsSchemeHashMemory(1)
	refe423df90 := (*C.TPMS_SCHEME_HASH)(meme423df90)
	allocse423df90 := new(cgoAllocMap)
	allocse423df90.Add(meme423df90)

	var chashAlg_allocs *cgoAllocMap
	refe423df90.hashAlg, chashAlg_allocs = (C.TPMI_ALG_HASH)(x.Hashalg), cgoAllocsUnknown
	allocse423df90.Borrow(chashAlg_allocs)

	x.refe423df90 = refe423df90
	x.allocse423df90 = allocse423df90
	return refe423df90, allocse423df90

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsSigSchemeEcschnorr) PassValue() (C.TPMS_SCHEME_HASH, *cgoAllocMap) {
	if x.refe423df90 != nil {
		return *x.refe423df90, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsSigSchemeEcschnorr) Deref() {
	if x.refe423df90 == nil {
		return
	}
	x.Hashalg = (TpmiAlgHash)(x.refe423df90.hashAlg)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsSigSchemeEcdaa) Ref() *C.TPMS_SCHEME_ECDAA {
	if x == nil {
		return nil
	}
	return x.refb9002c96
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsSigSchemeEcdaa) Free() {
	if x != nil && x.allocsb9002c96 != nil {
		x.allocsb9002c96.(*cgoAllocMap).Free()
		x.refb9002c96 = nil
	}
}

// NewTpmsSigSchemeEcdaaRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsSigSchemeEcdaaRef(ref unsafe.Pointer) *TpmsSigSchemeEcdaa {
	if ref == nil {
		return nil
	}
	obj := new(TpmsSigSchemeEcdaa)
	obj.refb9002c96 = (*C.TPMS_SCHEME_ECDAA)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsSigSchemeEcdaa) PassRef() (*C.TPMS_SCHEME_ECDAA, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb9002c96 != nil {
		return x.refb9002c96, nil
	}
	memb9002c96 := allocTpmsSchemeEcdaaMemory(1)
	refb9002c96 := (*C.TPMS_SCHEME_ECDAA)(memb9002c96)
	allocsb9002c96 := new(cgoAllocMap)
	allocsb9002c96.Add(memb9002c96)

	var chashAlg_allocs *cgoAllocMap
	refb9002c96.hashAlg, chashAlg_allocs = (C.TPMI_ALG_HASH)(x.Hashalg), cgoAllocsUnknown
	allocsb9002c96.Borrow(chashAlg_allocs)

	var ccount_allocs *cgoAllocMap
	refb9002c96.count, ccount_allocs = (C.UINT16)(x.Count), cgoAllocsUnknown
	allocsb9002c96.Borrow(ccount_allocs)

	x.refb9002c96 = refb9002c96
	x.allocsb9002c96 = allocsb9002c96
	return refb9002c96, allocsb9002c96

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsSigSchemeEcdaa) PassValue() (C.TPMS_SCHEME_ECDAA, *cgoAllocMap) {
	if x.refb9002c96 != nil {
		return *x.refb9002c96, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsSigSchemeEcdaa) Deref() {
	if x.refb9002c96 == nil {
		return
	}
	x.Hashalg = (TpmiAlgHash)(x.refb9002c96.hashAlg)
	x.Count = (Uint16)(x.refb9002c96.count)
}

// allocTpmtSigSchemeMemory allocates memory for type C.TPMT_SIG_SCHEME in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtSigSchemeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtSigSchemeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtSigSchemeValue = unsafe.Sizeof([1]C.TPMT_SIG_SCHEME{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmtSigScheme) Ref() *C.TPMT_SIG_SCHEME {
	if x == nil {
		return nil
	}
	return x.reff2a9c9bc
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmtSigScheme) Free() {
	if x != nil && x.allocsf2a9c9bc != nil {
		x.allocsf2a9c9bc.(*cgoAllocMap).Free()
		x.reff2a9c9bc = nil
	}
}

// NewTpmtSigSchemeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmtSigSchemeRef(ref unsafe.Pointer) *TpmtSigScheme {
	if ref == nil {
		return nil
	}
	obj := new(TpmtSigScheme)
	obj.reff2a9c9bc = (*C.TPMT_SIG_SCHEME)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmtSigScheme) PassRef() (*C.TPMT_SIG_SCHEME, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff2a9c9bc != nil {
		return x.reff2a9c9bc, nil
	}
	memf2a9c9bc := allocTpmtSigSchemeMemory(1)
	reff2a9c9bc := (*C.TPMT_SIG_SCHEME)(memf2a9c9bc)
	allocsf2a9c9bc := new(cgoAllocMap)
	allocsf2a9c9bc.Add(memf2a9c9bc)

	var cscheme_allocs *cgoAllocMap
	reff2a9c9bc.scheme, cscheme_allocs = (C.TPMI_ALG_SIG_SCHEME)(x.Scheme), cgoAllocsUnknown
	allocsf2a9c9bc.Borrow(cscheme_allocs)

	var cdetails_allocs *cgoAllocMap
	reff2a9c9bc.details, cdetails_allocs = *(*C.TPMU_SIG_SCHEME)(unsafe.Pointer(&x.Details)), cgoAllocsUnknown
	allocsf2a9c9bc.Borrow(cdetails_allocs)

	x.reff2a9c9bc = reff2a9c9bc
	x.allocsf2a9c9bc = allocsf2a9c9bc
	return reff2a9c9bc, allocsf2a9c9bc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmtSigScheme) PassValue() (C.TPMT_SIG_SCHEME, *cgoAllocMap) {
	if x.reff2a9c9bc != nil {
		return *x.reff2a9c9bc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmtSigScheme) Deref() {
	if x.reff2a9c9bc == nil {
		return
	}
	x.Scheme = (TpmiAlgSigScheme)(x.reff2a9c9bc.scheme)
	x.Details = *(*TpmuSigScheme)(unsafe.Pointer(&x.reff2a9c9bc.details))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsEncSchemeOaep) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return x.refe423df90
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsEncSchemeOaep) Free() {
	if x != nil && x.allocse423df90 != nil {
		x.allocse423df90.(*cgoAllocMap).Free()
		x.refe423df90 = nil
	}
}

// NewTpmsEncSchemeOaepRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsEncSchemeOaepRef(ref unsafe.Pointer) *TpmsEncSchemeOaep {
	if ref == nil {
		return nil
	}
	obj := new(TpmsEncSchemeOaep)
	obj.refe423df90 = (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsEncSchemeOaep) PassRef() (*C.TPMS_SCHEME_HASH, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe423df90 != nil {
		return x.refe423df90, nil
	}
	meme423df90 := allocTpmsSchemeHashMemory(1)
	refe423df90 := (*C.TPMS_SCHEME_HASH)(meme423df90)
	allocse423df90 := new(cgoAllocMap)
	allocse423df90.Add(meme423df90)

	var chashAlg_allocs *cgoAllocMap
	refe423df90.hashAlg, chashAlg_allocs = (C.TPMI_ALG_HASH)(x.Hashalg), cgoAllocsUnknown
	allocse423df90.Borrow(chashAlg_allocs)

	x.refe423df90 = refe423df90
	x.allocse423df90 = allocse423df90
	return refe423df90, allocse423df90

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsEncSchemeOaep) PassValue() (C.TPMS_SCHEME_HASH, *cgoAllocMap) {
	if x.refe423df90 != nil {
		return *x.refe423df90, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsEncSchemeOaep) Deref() {
	if x.refe423df90 == nil {
		return
	}
	x.Hashalg = (TpmiAlgHash)(x.refe423df90.hashAlg)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsEncSchemeRsaes) Ref() *C.TPMS_EMPTY {
	if x == nil {
		return nil
	}
	return x.ref25eb996f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsEncSchemeRsaes) Free() {
	if x != nil && x.allocs25eb996f != nil {
		x.allocs25eb996f.(*cgoAllocMap).Free()
		x.ref25eb996f = nil
	}
}

// NewTpmsEncSchemeRsaesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsEncSchemeRsaesRef(ref unsafe.Pointer) *TpmsEncSchemeRsaes {
	if ref == nil {
		return nil
	}
	obj := new(TpmsEncSchemeRsaes)
	obj.ref25eb996f = (*C.TPMS_EMPTY)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsEncSchemeRsaes) PassRef() (*C.TPMS_EMPTY, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref25eb996f != nil {
		return x.ref25eb996f, nil
	}
	mem25eb996f := allocTpmsEmptyMemory(1)
	ref25eb996f := (*C.TPMS_EMPTY)(mem25eb996f)
	allocs25eb996f := new(cgoAllocMap)
	allocs25eb996f.Add(mem25eb996f)

	var cempty_allocs *cgoAllocMap
	ref25eb996f.empty, cempty_allocs = *(*[1]C.BYTE)(unsafe.Pointer(&x.Empty)), cgoAllocsUnknown
	allocs25eb996f.Borrow(cempty_allocs)

	x.ref25eb996f = ref25eb996f
	x.allocs25eb996f = allocs25eb996f
	return ref25eb996f, allocs25eb996f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsEncSchemeRsaes) PassValue() (C.TPMS_EMPTY, *cgoAllocMap) {
	if x.ref25eb996f != nil {
		return *x.ref25eb996f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsEncSchemeRsaes) Deref() {
	if x.ref25eb996f == nil {
		return
	}
	x.Empty = *(*[1]Byte)(unsafe.Pointer(&x.ref25eb996f.empty))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsKeySchemeEcdh) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return x.refe423df90
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsKeySchemeEcdh) Free() {
	if x != nil && x.allocse423df90 != nil {
		x.allocse423df90.(*cgoAllocMap).Free()
		x.refe423df90 = nil
	}
}

// NewTpmsKeySchemeEcdhRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsKeySchemeEcdhRef(ref unsafe.Pointer) *TpmsKeySchemeEcdh {
	if ref == nil {
		return nil
	}
	obj := new(TpmsKeySchemeEcdh)
	obj.refe423df90 = (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsKeySchemeEcdh) PassRef() (*C.TPMS_SCHEME_HASH, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe423df90 != nil {
		return x.refe423df90, nil
	}
	meme423df90 := allocTpmsSchemeHashMemory(1)
	refe423df90 := (*C.TPMS_SCHEME_HASH)(meme423df90)
	allocse423df90 := new(cgoAllocMap)
	allocse423df90.Add(meme423df90)

	var chashAlg_allocs *cgoAllocMap
	refe423df90.hashAlg, chashAlg_allocs = (C.TPMI_ALG_HASH)(x.Hashalg), cgoAllocsUnknown
	allocse423df90.Borrow(chashAlg_allocs)

	x.refe423df90 = refe423df90
	x.allocse423df90 = allocse423df90
	return refe423df90, allocse423df90

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsKeySchemeEcdh) PassValue() (C.TPMS_SCHEME_HASH, *cgoAllocMap) {
	if x.refe423df90 != nil {
		return *x.refe423df90, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsKeySchemeEcdh) Deref() {
	if x.refe423df90 == nil {
		return
	}
	x.Hashalg = (TpmiAlgHash)(x.refe423df90.hashAlg)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsKeySchemeEcmqv) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return x.refe423df90
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsKeySchemeEcmqv) Free() {
	if x != nil && x.allocse423df90 != nil {
		x.allocse423df90.(*cgoAllocMap).Free()
		x.refe423df90 = nil
	}
}

// NewTpmsKeySchemeEcmqvRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsKeySchemeEcmqvRef(ref unsafe.Pointer) *TpmsKeySchemeEcmqv {
	if ref == nil {
		return nil
	}
	obj := new(TpmsKeySchemeEcmqv)
	obj.refe423df90 = (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsKeySchemeEcmqv) PassRef() (*C.TPMS_SCHEME_HASH, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe423df90 != nil {
		return x.refe423df90, nil
	}
	meme423df90 := allocTpmsSchemeHashMemory(1)
	refe423df90 := (*C.TPMS_SCHEME_HASH)(meme423df90)
	allocse423df90 := new(cgoAllocMap)
	allocse423df90.Add(meme423df90)

	var chashAlg_allocs *cgoAllocMap
	refe423df90.hashAlg, chashAlg_allocs = (C.TPMI_ALG_HASH)(x.Hashalg), cgoAllocsUnknown
	allocse423df90.Borrow(chashAlg_allocs)

	x.refe423df90 = refe423df90
	x.allocse423df90 = allocse423df90
	return refe423df90, allocse423df90

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsKeySchemeEcmqv) PassValue() (C.TPMS_SCHEME_HASH, *cgoAllocMap) {
	if x.refe423df90 != nil {
		return *x.refe423df90, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsKeySchemeEcmqv) Deref() {
	if x.refe423df90 == nil {
		return
	}
	x.Hashalg = (TpmiAlgHash)(x.refe423df90.hashAlg)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsSchemeMgf1) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return x.refe423df90
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsSchemeMgf1) Free() {
	if x != nil && x.allocse423df90 != nil {
		x.allocse423df90.(*cgoAllocMap).Free()
		x.refe423df90 = nil
	}
}

// NewTpmsSchemeMgf1Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsSchemeMgf1Ref(ref unsafe.Pointer) *TpmsSchemeMgf1 {
	if ref == nil {
		return nil
	}
	obj := new(TpmsSchemeMgf1)
	obj.refe423df90 = (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsSchemeMgf1) PassRef() (*C.TPMS_SCHEME_HASH, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe423df90 != nil {
		return x.refe423df90, nil
	}
	meme423df90 := allocTpmsSchemeHashMemory(1)
	refe423df90 := (*C.TPMS_SCHEME_HASH)(meme423df90)
	allocse423df90 := new(cgoAllocMap)
	allocse423df90.Add(meme423df90)

	var chashAlg_allocs *cgoAllocMap
	refe423df90.hashAlg, chashAlg_allocs = (C.TPMI_ALG_HASH)(x.Hashalg), cgoAllocsUnknown
	allocse423df90.Borrow(chashAlg_allocs)

	x.refe423df90 = refe423df90
	x.allocse423df90 = allocse423df90
	return refe423df90, allocse423df90

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsSchemeMgf1) PassValue() (C.TPMS_SCHEME_HASH, *cgoAllocMap) {
	if x.refe423df90 != nil {
		return *x.refe423df90, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsSchemeMgf1) Deref() {
	if x.refe423df90 == nil {
		return
	}
	x.Hashalg = (TpmiAlgHash)(x.refe423df90.hashAlg)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsSchemeKdf1Sp80056a) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return x.refe423df90
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsSchemeKdf1Sp80056a) Free() {
	if x != nil && x.allocse423df90 != nil {
		x.allocse423df90.(*cgoAllocMap).Free()
		x.refe423df90 = nil
	}
}

// NewTpmsSchemeKdf1Sp80056aRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsSchemeKdf1Sp80056aRef(ref unsafe.Pointer) *TpmsSchemeKdf1Sp80056a {
	if ref == nil {
		return nil
	}
	obj := new(TpmsSchemeKdf1Sp80056a)
	obj.refe423df90 = (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsSchemeKdf1Sp80056a) PassRef() (*C.TPMS_SCHEME_HASH, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe423df90 != nil {
		return x.refe423df90, nil
	}
	meme423df90 := allocTpmsSchemeHashMemory(1)
	refe423df90 := (*C.TPMS_SCHEME_HASH)(meme423df90)
	allocse423df90 := new(cgoAllocMap)
	allocse423df90.Add(meme423df90)

	var chashAlg_allocs *cgoAllocMap
	refe423df90.hashAlg, chashAlg_allocs = (C.TPMI_ALG_HASH)(x.Hashalg), cgoAllocsUnknown
	allocse423df90.Borrow(chashAlg_allocs)

	x.refe423df90 = refe423df90
	x.allocse423df90 = allocse423df90
	return refe423df90, allocse423df90

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsSchemeKdf1Sp80056a) PassValue() (C.TPMS_SCHEME_HASH, *cgoAllocMap) {
	if x.refe423df90 != nil {
		return *x.refe423df90, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsSchemeKdf1Sp80056a) Deref() {
	if x.refe423df90 == nil {
		return
	}
	x.Hashalg = (TpmiAlgHash)(x.refe423df90.hashAlg)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsSchemeKdf2) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return x.refe423df90
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsSchemeKdf2) Free() {
	if x != nil && x.allocse423df90 != nil {
		x.allocse423df90.(*cgoAllocMap).Free()
		x.refe423df90 = nil
	}
}

// NewTpmsSchemeKdf2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsSchemeKdf2Ref(ref unsafe.Pointer) *TpmsSchemeKdf2 {
	if ref == nil {
		return nil
	}
	obj := new(TpmsSchemeKdf2)
	obj.refe423df90 = (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsSchemeKdf2) PassRef() (*C.TPMS_SCHEME_HASH, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe423df90 != nil {
		return x.refe423df90, nil
	}
	meme423df90 := allocTpmsSchemeHashMemory(1)
	refe423df90 := (*C.TPMS_SCHEME_HASH)(meme423df90)
	allocse423df90 := new(cgoAllocMap)
	allocse423df90.Add(meme423df90)

	var chashAlg_allocs *cgoAllocMap
	refe423df90.hashAlg, chashAlg_allocs = (C.TPMI_ALG_HASH)(x.Hashalg), cgoAllocsUnknown
	allocse423df90.Borrow(chashAlg_allocs)

	x.refe423df90 = refe423df90
	x.allocse423df90 = allocse423df90
	return refe423df90, allocse423df90

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsSchemeKdf2) PassValue() (C.TPMS_SCHEME_HASH, *cgoAllocMap) {
	if x.refe423df90 != nil {
		return *x.refe423df90, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsSchemeKdf2) Deref() {
	if x.refe423df90 == nil {
		return
	}
	x.Hashalg = (TpmiAlgHash)(x.refe423df90.hashAlg)
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsSchemeKdf1Sp800108) Ref() *C.TPMS_SCHEME_HASH {
	if x == nil {
		return nil
	}
	return x.refe423df90
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsSchemeKdf1Sp800108) Free() {
	if x != nil && x.allocse423df90 != nil {
		x.allocse423df90.(*cgoAllocMap).Free()
		x.refe423df90 = nil
	}
}

// NewTpmsSchemeKdf1Sp800108Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsSchemeKdf1Sp800108Ref(ref unsafe.Pointer) *TpmsSchemeKdf1Sp800108 {
	if ref == nil {
		return nil
	}
	obj := new(TpmsSchemeKdf1Sp800108)
	obj.refe423df90 = (*C.TPMS_SCHEME_HASH)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsSchemeKdf1Sp800108) PassRef() (*C.TPMS_SCHEME_HASH, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe423df90 != nil {
		return x.refe423df90, nil
	}
	meme423df90 := allocTpmsSchemeHashMemory(1)
	refe423df90 := (*C.TPMS_SCHEME_HASH)(meme423df90)
	allocse423df90 := new(cgoAllocMap)
	allocse423df90.Add(meme423df90)

	var chashAlg_allocs *cgoAllocMap
	refe423df90.hashAlg, chashAlg_allocs = (C.TPMI_ALG_HASH)(x.Hashalg), cgoAllocsUnknown
	allocse423df90.Borrow(chashAlg_allocs)

	x.refe423df90 = refe423df90
	x.allocse423df90 = allocse423df90
	return refe423df90, allocse423df90

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsSchemeKdf1Sp800108) PassValue() (C.TPMS_SCHEME_HASH, *cgoAllocMap) {
	if x.refe423df90 != nil {
		return *x.refe423df90, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsSchemeKdf1Sp800108) Deref() {
	if x.refe423df90 == nil {
		return
	}
	x.Hashalg = (TpmiAlgHash)(x.refe423df90.hashAlg)
}

// allocTpmtKdfSchemeMemory allocates memory for type C.TPMT_KDF_SCHEME in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtKdfSchemeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtKdfSchemeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtKdfSchemeValue = unsafe.Sizeof([1]C.TPMT_KDF_SCHEME{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmtKdfScheme) Ref() *C.TPMT_KDF_SCHEME {
	if x == nil {
		return nil
	}
	return x.reffb35ef69
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmtKdfScheme) Free() {
	if x != nil && x.allocsfb35ef69 != nil {
		x.allocsfb35ef69.(*cgoAllocMap).Free()
		x.reffb35ef69 = nil
	}
}

// NewTpmtKdfSchemeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmtKdfSchemeRef(ref unsafe.Pointer) *TpmtKdfScheme {
	if ref == nil {
		return nil
	}
	obj := new(TpmtKdfScheme)
	obj.reffb35ef69 = (*C.TPMT_KDF_SCHEME)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmtKdfScheme) PassRef() (*C.TPMT_KDF_SCHEME, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffb35ef69 != nil {
		return x.reffb35ef69, nil
	}
	memfb35ef69 := allocTpmtKdfSchemeMemory(1)
	reffb35ef69 := (*C.TPMT_KDF_SCHEME)(memfb35ef69)
	allocsfb35ef69 := new(cgoAllocMap)
	allocsfb35ef69.Add(memfb35ef69)

	var cscheme_allocs *cgoAllocMap
	reffb35ef69.scheme, cscheme_allocs = (C.TPMI_ALG_KDF)(x.Scheme), cgoAllocsUnknown
	allocsfb35ef69.Borrow(cscheme_allocs)

	var cdetails_allocs *cgoAllocMap
	reffb35ef69.details, cdetails_allocs = *(*C.TPMU_KDF_SCHEME)(unsafe.Pointer(&x.Details)), cgoAllocsUnknown
	allocsfb35ef69.Borrow(cdetails_allocs)

	x.reffb35ef69 = reffb35ef69
	x.allocsfb35ef69 = allocsfb35ef69
	return reffb35ef69, allocsfb35ef69

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmtKdfScheme) PassValue() (C.TPMT_KDF_SCHEME, *cgoAllocMap) {
	if x.reffb35ef69 != nil {
		return *x.reffb35ef69, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmtKdfScheme) Deref() {
	if x.reffb35ef69 == nil {
		return
	}
	x.Scheme = (TpmiAlgKdf)(x.reffb35ef69.scheme)
	x.Details = *(*TpmuKdfScheme)(unsafe.Pointer(&x.reffb35ef69.details))
}

// allocTpmtAsymSchemeMemory allocates memory for type C.TPMT_ASYM_SCHEME in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtAsymSchemeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtAsymSchemeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtAsymSchemeValue = unsafe.Sizeof([1]C.TPMT_ASYM_SCHEME{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmtAsymScheme) Ref() *C.TPMT_ASYM_SCHEME {
	if x == nil {
		return nil
	}
	return x.refd1d95f1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmtAsymScheme) Free() {
	if x != nil && x.allocsd1d95f1 != nil {
		x.allocsd1d95f1.(*cgoAllocMap).Free()
		x.refd1d95f1 = nil
	}
}

// NewTpmtAsymSchemeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmtAsymSchemeRef(ref unsafe.Pointer) *TpmtAsymScheme {
	if ref == nil {
		return nil
	}
	obj := new(TpmtAsymScheme)
	obj.refd1d95f1 = (*C.TPMT_ASYM_SCHEME)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmtAsymScheme) PassRef() (*C.TPMT_ASYM_SCHEME, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd1d95f1 != nil {
		return x.refd1d95f1, nil
	}
	memd1d95f1 := allocTpmtAsymSchemeMemory(1)
	refd1d95f1 := (*C.TPMT_ASYM_SCHEME)(memd1d95f1)
	allocsd1d95f1 := new(cgoAllocMap)
	allocsd1d95f1.Add(memd1d95f1)

	var cscheme_allocs *cgoAllocMap
	refd1d95f1.scheme, cscheme_allocs = (C.TPMI_ALG_ASYM_SCHEME)(x.Scheme), cgoAllocsUnknown
	allocsd1d95f1.Borrow(cscheme_allocs)

	var cdetails_allocs *cgoAllocMap
	refd1d95f1.details, cdetails_allocs = *(*C.TPMU_ASYM_SCHEME)(unsafe.Pointer(&x.Details)), cgoAllocsUnknown
	allocsd1d95f1.Borrow(cdetails_allocs)

	x.refd1d95f1 = refd1d95f1
	x.allocsd1d95f1 = allocsd1d95f1
	return refd1d95f1, allocsd1d95f1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmtAsymScheme) PassValue() (C.TPMT_ASYM_SCHEME, *cgoAllocMap) {
	if x.refd1d95f1 != nil {
		return *x.refd1d95f1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmtAsymScheme) Deref() {
	if x.refd1d95f1 == nil {
		return
	}
	x.Scheme = (TpmiAlgAsymScheme)(x.refd1d95f1.scheme)
	x.Details = *(*TpmuAsymScheme)(unsafe.Pointer(&x.refd1d95f1.details))
}

// allocTpmtRsaSchemeMemory allocates memory for type C.TPMT_RSA_SCHEME in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtRsaSchemeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtRsaSchemeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtRsaSchemeValue = unsafe.Sizeof([1]C.TPMT_RSA_SCHEME{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmtRsaScheme) Ref() *C.TPMT_RSA_SCHEME {
	if x == nil {
		return nil
	}
	return x.refe2ea63ea
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmtRsaScheme) Free() {
	if x != nil && x.allocse2ea63ea != nil {
		x.allocse2ea63ea.(*cgoAllocMap).Free()
		x.refe2ea63ea = nil
	}
}

// NewTpmtRsaSchemeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmtRsaSchemeRef(ref unsafe.Pointer) *TpmtRsaScheme {
	if ref == nil {
		return nil
	}
	obj := new(TpmtRsaScheme)
	obj.refe2ea63ea = (*C.TPMT_RSA_SCHEME)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmtRsaScheme) PassRef() (*C.TPMT_RSA_SCHEME, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe2ea63ea != nil {
		return x.refe2ea63ea, nil
	}
	meme2ea63ea := allocTpmtRsaSchemeMemory(1)
	refe2ea63ea := (*C.TPMT_RSA_SCHEME)(meme2ea63ea)
	allocse2ea63ea := new(cgoAllocMap)
	allocse2ea63ea.Add(meme2ea63ea)

	var cscheme_allocs *cgoAllocMap
	refe2ea63ea.scheme, cscheme_allocs = (C.TPMI_ALG_RSA_SCHEME)(x.Scheme), cgoAllocsUnknown
	allocse2ea63ea.Borrow(cscheme_allocs)

	var cdetails_allocs *cgoAllocMap
	refe2ea63ea.details, cdetails_allocs = *(*C.TPMU_ASYM_SCHEME)(unsafe.Pointer(&x.Details)), cgoAllocsUnknown
	allocse2ea63ea.Borrow(cdetails_allocs)

	x.refe2ea63ea = refe2ea63ea
	x.allocse2ea63ea = allocse2ea63ea
	return refe2ea63ea, allocse2ea63ea

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmtRsaScheme) PassValue() (C.TPMT_RSA_SCHEME, *cgoAllocMap) {
	if x.refe2ea63ea != nil {
		return *x.refe2ea63ea, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmtRsaScheme) Deref() {
	if x.refe2ea63ea == nil {
		return
	}
	x.Scheme = (TpmiAlgRsaScheme)(x.refe2ea63ea.scheme)
	x.Details = *(*TpmuAsymScheme)(unsafe.Pointer(&x.refe2ea63ea.details))
}

// allocTpmtRsaDecryptMemory allocates memory for type C.TPMT_RSA_DECRYPT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtRsaDecryptMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtRsaDecryptValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtRsaDecryptValue = unsafe.Sizeof([1]C.TPMT_RSA_DECRYPT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmtRsaDecrypt) Ref() *C.TPMT_RSA_DECRYPT {
	if x == nil {
		return nil
	}
	return x.ref1c9d69b7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmtRsaDecrypt) Free() {
	if x != nil && x.allocs1c9d69b7 != nil {
		x.allocs1c9d69b7.(*cgoAllocMap).Free()
		x.ref1c9d69b7 = nil
	}
}

// NewTpmtRsaDecryptRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmtRsaDecryptRef(ref unsafe.Pointer) *TpmtRsaDecrypt {
	if ref == nil {
		return nil
	}
	obj := new(TpmtRsaDecrypt)
	obj.ref1c9d69b7 = (*C.TPMT_RSA_DECRYPT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmtRsaDecrypt) PassRef() (*C.TPMT_RSA_DECRYPT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1c9d69b7 != nil {
		return x.ref1c9d69b7, nil
	}
	mem1c9d69b7 := allocTpmtRsaDecryptMemory(1)
	ref1c9d69b7 := (*C.TPMT_RSA_DECRYPT)(mem1c9d69b7)
	allocs1c9d69b7 := new(cgoAllocMap)
	allocs1c9d69b7.Add(mem1c9d69b7)

	var cscheme_allocs *cgoAllocMap
	ref1c9d69b7.scheme, cscheme_allocs = (C.TPMI_ALG_RSA_DECRYPT)(x.Scheme), cgoAllocsUnknown
	allocs1c9d69b7.Borrow(cscheme_allocs)

	var cdetails_allocs *cgoAllocMap
	ref1c9d69b7.details, cdetails_allocs = *(*C.TPMU_ASYM_SCHEME)(unsafe.Pointer(&x.Details)), cgoAllocsUnknown
	allocs1c9d69b7.Borrow(cdetails_allocs)

	x.ref1c9d69b7 = ref1c9d69b7
	x.allocs1c9d69b7 = allocs1c9d69b7
	return ref1c9d69b7, allocs1c9d69b7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmtRsaDecrypt) PassValue() (C.TPMT_RSA_DECRYPT, *cgoAllocMap) {
	if x.ref1c9d69b7 != nil {
		return *x.ref1c9d69b7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmtRsaDecrypt) Deref() {
	if x.ref1c9d69b7 == nil {
		return
	}
	x.Scheme = (TpmiAlgRsaDecrypt)(x.ref1c9d69b7.scheme)
	x.Details = *(*TpmuAsymScheme)(unsafe.Pointer(&x.ref1c9d69b7.details))
}

// allocTpm2bPublicKeyRsaMemory allocates memory for type C.TPM2B_PUBLIC_KEY_RSA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bPublicKeyRsaMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bPublicKeyRsaValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bPublicKeyRsaValue = unsafe.Sizeof([1]C.TPM2B_PUBLIC_KEY_RSA{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Tpm2bPublicKeyRsa) Ref() *C.TPM2B_PUBLIC_KEY_RSA {
	if x == nil {
		return nil
	}
	return x.ref67f84e1f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Tpm2bPublicKeyRsa) Free() {
	if x != nil && x.allocs67f84e1f != nil {
		x.allocs67f84e1f.(*cgoAllocMap).Free()
		x.ref67f84e1f = nil
	}
}

// NewTpm2bPublicKeyRsaRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpm2bPublicKeyRsaRef(ref unsafe.Pointer) *Tpm2bPublicKeyRsa {
	if ref == nil {
		return nil
	}
	obj := new(Tpm2bPublicKeyRsa)
	obj.ref67f84e1f = (*C.TPM2B_PUBLIC_KEY_RSA)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Tpm2bPublicKeyRsa) PassRef() (*C.TPM2B_PUBLIC_KEY_RSA, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref67f84e1f != nil {
		return x.ref67f84e1f, nil
	}
	mem67f84e1f := allocTpm2bPublicKeyRsaMemory(1)
	ref67f84e1f := (*C.TPM2B_PUBLIC_KEY_RSA)(mem67f84e1f)
	allocs67f84e1f := new(cgoAllocMap)
	allocs67f84e1f.Add(mem67f84e1f)

	var csize_allocs *cgoAllocMap
	ref67f84e1f.size, csize_allocs = (C.UINT16)(x.Size), cgoAllocsUnknown
	allocs67f84e1f.Borrow(csize_allocs)

	var cbuffer_allocs *cgoAllocMap
	ref67f84e1f.buffer, cbuffer_allocs = *(*[512]C.BYTE)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocs67f84e1f.Borrow(cbuffer_allocs)

	x.ref67f84e1f = ref67f84e1f
	x.allocs67f84e1f = allocs67f84e1f
	return ref67f84e1f, allocs67f84e1f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Tpm2bPublicKeyRsa) PassValue() (C.TPM2B_PUBLIC_KEY_RSA, *cgoAllocMap) {
	if x.ref67f84e1f != nil {
		return *x.ref67f84e1f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Tpm2bPublicKeyRsa) Deref() {
	if x.ref67f84e1f == nil {
		return
	}
	x.Size = (Uint16)(x.ref67f84e1f.size)
	x.Buffer = *(*[512]Byte)(unsafe.Pointer(&x.ref67f84e1f.buffer))
}

// allocTpm2bPrivateKeyRsaMemory allocates memory for type C.TPM2B_PRIVATE_KEY_RSA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bPrivateKeyRsaMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bPrivateKeyRsaValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bPrivateKeyRsaValue = unsafe.Sizeof([1]C.TPM2B_PRIVATE_KEY_RSA{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Tpm2bPrivateKeyRsa) Ref() *C.TPM2B_PRIVATE_KEY_RSA {
	if x == nil {
		return nil
	}
	return x.refa4047900
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Tpm2bPrivateKeyRsa) Free() {
	if x != nil && x.allocsa4047900 != nil {
		x.allocsa4047900.(*cgoAllocMap).Free()
		x.refa4047900 = nil
	}
}

// NewTpm2bPrivateKeyRsaRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpm2bPrivateKeyRsaRef(ref unsafe.Pointer) *Tpm2bPrivateKeyRsa {
	if ref == nil {
		return nil
	}
	obj := new(Tpm2bPrivateKeyRsa)
	obj.refa4047900 = (*C.TPM2B_PRIVATE_KEY_RSA)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Tpm2bPrivateKeyRsa) PassRef() (*C.TPM2B_PRIVATE_KEY_RSA, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa4047900 != nil {
		return x.refa4047900, nil
	}
	mema4047900 := allocTpm2bPrivateKeyRsaMemory(1)
	refa4047900 := (*C.TPM2B_PRIVATE_KEY_RSA)(mema4047900)
	allocsa4047900 := new(cgoAllocMap)
	allocsa4047900.Add(mema4047900)

	var csize_allocs *cgoAllocMap
	refa4047900.size, csize_allocs = (C.UINT16)(x.Size), cgoAllocsUnknown
	allocsa4047900.Borrow(csize_allocs)

	var cbuffer_allocs *cgoAllocMap
	refa4047900.buffer, cbuffer_allocs = *(*[256]C.BYTE)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocsa4047900.Borrow(cbuffer_allocs)

	x.refa4047900 = refa4047900
	x.allocsa4047900 = allocsa4047900
	return refa4047900, allocsa4047900

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Tpm2bPrivateKeyRsa) PassValue() (C.TPM2B_PRIVATE_KEY_RSA, *cgoAllocMap) {
	if x.refa4047900 != nil {
		return *x.refa4047900, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Tpm2bPrivateKeyRsa) Deref() {
	if x.refa4047900 == nil {
		return
	}
	x.Size = (Uint16)(x.refa4047900.size)
	x.Buffer = *(*[256]Byte)(unsafe.Pointer(&x.refa4047900.buffer))
}

// allocTpm2bEccParameterMemory allocates memory for type C.TPM2B_ECC_PARAMETER in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bEccParameterMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bEccParameterValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bEccParameterValue = unsafe.Sizeof([1]C.TPM2B_ECC_PARAMETER{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Tpm2bEccParameter) Ref() *C.TPM2B_ECC_PARAMETER {
	if x == nil {
		return nil
	}
	return x.refbb1052f4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Tpm2bEccParameter) Free() {
	if x != nil && x.allocsbb1052f4 != nil {
		x.allocsbb1052f4.(*cgoAllocMap).Free()
		x.refbb1052f4 = nil
	}
}

// NewTpm2bEccParameterRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpm2bEccParameterRef(ref unsafe.Pointer) *Tpm2bEccParameter {
	if ref == nil {
		return nil
	}
	obj := new(Tpm2bEccParameter)
	obj.refbb1052f4 = (*C.TPM2B_ECC_PARAMETER)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Tpm2bEccParameter) PassRef() (*C.TPM2B_ECC_PARAMETER, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbb1052f4 != nil {
		return x.refbb1052f4, nil
	}
	membb1052f4 := allocTpm2bEccParameterMemory(1)
	refbb1052f4 := (*C.TPM2B_ECC_PARAMETER)(membb1052f4)
	allocsbb1052f4 := new(cgoAllocMap)
	allocsbb1052f4.Add(membb1052f4)

	var csize_allocs *cgoAllocMap
	refbb1052f4.size, csize_allocs = (C.UINT16)(x.Size), cgoAllocsUnknown
	allocsbb1052f4.Borrow(csize_allocs)

	var cbuffer_allocs *cgoAllocMap
	refbb1052f4.buffer, cbuffer_allocs = *(*[128]C.BYTE)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocsbb1052f4.Borrow(cbuffer_allocs)

	x.refbb1052f4 = refbb1052f4
	x.allocsbb1052f4 = allocsbb1052f4
	return refbb1052f4, allocsbb1052f4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Tpm2bEccParameter) PassValue() (C.TPM2B_ECC_PARAMETER, *cgoAllocMap) {
	if x.refbb1052f4 != nil {
		return *x.refbb1052f4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Tpm2bEccParameter) Deref() {
	if x.refbb1052f4 == nil {
		return
	}
	x.Size = (Uint16)(x.refbb1052f4.size)
	x.Buffer = *(*[128]Byte)(unsafe.Pointer(&x.refbb1052f4.buffer))
}

// allocTpmsEccPointMemory allocates memory for type C.TPMS_ECC_POINT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsEccPointMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsEccPointValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsEccPointValue = unsafe.Sizeof([1]C.TPMS_ECC_POINT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsEccPoint) Ref() *C.TPMS_ECC_POINT {
	if x == nil {
		return nil
	}
	return x.refdce64ac7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsEccPoint) Free() {
	if x != nil && x.allocsdce64ac7 != nil {
		x.allocsdce64ac7.(*cgoAllocMap).Free()
		x.refdce64ac7 = nil
	}
}

// NewTpmsEccPointRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsEccPointRef(ref unsafe.Pointer) *TpmsEccPoint {
	if ref == nil {
		return nil
	}
	obj := new(TpmsEccPoint)
	obj.refdce64ac7 = (*C.TPMS_ECC_POINT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsEccPoint) PassRef() (*C.TPMS_ECC_POINT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdce64ac7 != nil {
		return x.refdce64ac7, nil
	}
	memdce64ac7 := allocTpmsEccPointMemory(1)
	refdce64ac7 := (*C.TPMS_ECC_POINT)(memdce64ac7)
	allocsdce64ac7 := new(cgoAllocMap)
	allocsdce64ac7.Add(memdce64ac7)

	var cx_allocs *cgoAllocMap
	refdce64ac7.x, cx_allocs = x.X.PassValue()
	allocsdce64ac7.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	refdce64ac7.y, cy_allocs = x.Y.PassValue()
	allocsdce64ac7.Borrow(cy_allocs)

	x.refdce64ac7 = refdce64ac7
	x.allocsdce64ac7 = allocsdce64ac7
	return refdce64ac7, allocsdce64ac7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsEccPoint) PassValue() (C.TPMS_ECC_POINT, *cgoAllocMap) {
	if x.refdce64ac7 != nil {
		return *x.refdce64ac7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsEccPoint) Deref() {
	if x.refdce64ac7 == nil {
		return
	}
	x.X = *NewTpm2bEccParameterRef(unsafe.Pointer(&x.refdce64ac7.x))
	x.Y = *NewTpm2bEccParameterRef(unsafe.Pointer(&x.refdce64ac7.y))
}

// allocTpm2bEccPointMemory allocates memory for type C.TPM2B_ECC_POINT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bEccPointMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bEccPointValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bEccPointValue = unsafe.Sizeof([1]C.TPM2B_ECC_POINT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Tpm2bEccPoint) Ref() *C.TPM2B_ECC_POINT {
	if x == nil {
		return nil
	}
	return x.refd4afd87
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Tpm2bEccPoint) Free() {
	if x != nil && x.allocsd4afd87 != nil {
		x.allocsd4afd87.(*cgoAllocMap).Free()
		x.refd4afd87 = nil
	}
}

// NewTpm2bEccPointRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpm2bEccPointRef(ref unsafe.Pointer) *Tpm2bEccPoint {
	if ref == nil {
		return nil
	}
	obj := new(Tpm2bEccPoint)
	obj.refd4afd87 = (*C.TPM2B_ECC_POINT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Tpm2bEccPoint) PassRef() (*C.TPM2B_ECC_POINT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd4afd87 != nil {
		return x.refd4afd87, nil
	}
	memd4afd87 := allocTpm2bEccPointMemory(1)
	refd4afd87 := (*C.TPM2B_ECC_POINT)(memd4afd87)
	allocsd4afd87 := new(cgoAllocMap)
	allocsd4afd87.Add(memd4afd87)

	var csize_allocs *cgoAllocMap
	refd4afd87.size, csize_allocs = (C.UINT16)(x.Size), cgoAllocsUnknown
	allocsd4afd87.Borrow(csize_allocs)

	var cpoint_allocs *cgoAllocMap
	refd4afd87.point, cpoint_allocs = x.Point.PassValue()
	allocsd4afd87.Borrow(cpoint_allocs)

	x.refd4afd87 = refd4afd87
	x.allocsd4afd87 = allocsd4afd87
	return refd4afd87, allocsd4afd87

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Tpm2bEccPoint) PassValue() (C.TPM2B_ECC_POINT, *cgoAllocMap) {
	if x.refd4afd87 != nil {
		return *x.refd4afd87, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Tpm2bEccPoint) Deref() {
	if x.refd4afd87 == nil {
		return
	}
	x.Size = (Uint16)(x.refd4afd87.size)
	x.Point = *NewTpmsEccPointRef(unsafe.Pointer(&x.refd4afd87.point))
}

// allocTpmtEccSchemeMemory allocates memory for type C.TPMT_ECC_SCHEME in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtEccSchemeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtEccSchemeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtEccSchemeValue = unsafe.Sizeof([1]C.TPMT_ECC_SCHEME{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmtEccScheme) Ref() *C.TPMT_ECC_SCHEME {
	if x == nil {
		return nil
	}
	return x.refc97dbc77
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmtEccScheme) Free() {
	if x != nil && x.allocsc97dbc77 != nil {
		x.allocsc97dbc77.(*cgoAllocMap).Free()
		x.refc97dbc77 = nil
	}
}

// NewTpmtEccSchemeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmtEccSchemeRef(ref unsafe.Pointer) *TpmtEccScheme {
	if ref == nil {
		return nil
	}
	obj := new(TpmtEccScheme)
	obj.refc97dbc77 = (*C.TPMT_ECC_SCHEME)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmtEccScheme) PassRef() (*C.TPMT_ECC_SCHEME, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc97dbc77 != nil {
		return x.refc97dbc77, nil
	}
	memc97dbc77 := allocTpmtEccSchemeMemory(1)
	refc97dbc77 := (*C.TPMT_ECC_SCHEME)(memc97dbc77)
	allocsc97dbc77 := new(cgoAllocMap)
	allocsc97dbc77.Add(memc97dbc77)

	var cscheme_allocs *cgoAllocMap
	refc97dbc77.scheme, cscheme_allocs = (C.TPMI_ALG_ECC_SCHEME)(x.Scheme), cgoAllocsUnknown
	allocsc97dbc77.Borrow(cscheme_allocs)

	var cdetails_allocs *cgoAllocMap
	refc97dbc77.details, cdetails_allocs = *(*C.TPMU_ASYM_SCHEME)(unsafe.Pointer(&x.Details)), cgoAllocsUnknown
	allocsc97dbc77.Borrow(cdetails_allocs)

	x.refc97dbc77 = refc97dbc77
	x.allocsc97dbc77 = allocsc97dbc77
	return refc97dbc77, allocsc97dbc77

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmtEccScheme) PassValue() (C.TPMT_ECC_SCHEME, *cgoAllocMap) {
	if x.refc97dbc77 != nil {
		return *x.refc97dbc77, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmtEccScheme) Deref() {
	if x.refc97dbc77 == nil {
		return
	}
	x.Scheme = (TpmiAlgEccScheme)(x.refc97dbc77.scheme)
	x.Details = *(*TpmuAsymScheme)(unsafe.Pointer(&x.refc97dbc77.details))
}

// allocTpmsAlgorithmDetailEccMemory allocates memory for type C.TPMS_ALGORITHM_DETAIL_ECC in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsAlgorithmDetailEccMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsAlgorithmDetailEccValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsAlgorithmDetailEccValue = unsafe.Sizeof([1]C.TPMS_ALGORITHM_DETAIL_ECC{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsAlgorithmDetailEcc) Ref() *C.TPMS_ALGORITHM_DETAIL_ECC {
	if x == nil {
		return nil
	}
	return x.ref9936fbe0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsAlgorithmDetailEcc) Free() {
	if x != nil && x.allocs9936fbe0 != nil {
		x.allocs9936fbe0.(*cgoAllocMap).Free()
		x.ref9936fbe0 = nil
	}
}

// NewTpmsAlgorithmDetailEccRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsAlgorithmDetailEccRef(ref unsafe.Pointer) *TpmsAlgorithmDetailEcc {
	if ref == nil {
		return nil
	}
	obj := new(TpmsAlgorithmDetailEcc)
	obj.ref9936fbe0 = (*C.TPMS_ALGORITHM_DETAIL_ECC)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsAlgorithmDetailEcc) PassRef() (*C.TPMS_ALGORITHM_DETAIL_ECC, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9936fbe0 != nil {
		return x.ref9936fbe0, nil
	}
	mem9936fbe0 := allocTpmsAlgorithmDetailEccMemory(1)
	ref9936fbe0 := (*C.TPMS_ALGORITHM_DETAIL_ECC)(mem9936fbe0)
	allocs9936fbe0 := new(cgoAllocMap)
	allocs9936fbe0.Add(mem9936fbe0)

	var ccurveID_allocs *cgoAllocMap
	ref9936fbe0.curveID, ccurveID_allocs = (C.TPM2_ECC_CURVE)(x.Curveid), cgoAllocsUnknown
	allocs9936fbe0.Borrow(ccurveID_allocs)

	var ckeySize_allocs *cgoAllocMap
	ref9936fbe0.keySize, ckeySize_allocs = (C.UINT16)(x.Keysize), cgoAllocsUnknown
	allocs9936fbe0.Borrow(ckeySize_allocs)

	var ckdf_allocs *cgoAllocMap
	ref9936fbe0.kdf, ckdf_allocs = x.Kdf.PassValue()
	allocs9936fbe0.Borrow(ckdf_allocs)

	var csign_allocs *cgoAllocMap
	ref9936fbe0.sign, csign_allocs = x.Sign.PassValue()
	allocs9936fbe0.Borrow(csign_allocs)

	var cp_allocs *cgoAllocMap
	ref9936fbe0.p, cp_allocs = x.P.PassValue()
	allocs9936fbe0.Borrow(cp_allocs)

	var ca_allocs *cgoAllocMap
	ref9936fbe0.a, ca_allocs = x.A.PassValue()
	allocs9936fbe0.Borrow(ca_allocs)

	var cb_allocs *cgoAllocMap
	ref9936fbe0.b, cb_allocs = x.B.PassValue()
	allocs9936fbe0.Borrow(cb_allocs)

	var cgX_allocs *cgoAllocMap
	ref9936fbe0.gX, cgX_allocs = x.Gx.PassValue()
	allocs9936fbe0.Borrow(cgX_allocs)

	var cgY_allocs *cgoAllocMap
	ref9936fbe0.gY, cgY_allocs = x.Gy.PassValue()
	allocs9936fbe0.Borrow(cgY_allocs)

	var cn_allocs *cgoAllocMap
	ref9936fbe0.n, cn_allocs = x.N.PassValue()
	allocs9936fbe0.Borrow(cn_allocs)

	var ch_allocs *cgoAllocMap
	ref9936fbe0.h, ch_allocs = x.H.PassValue()
	allocs9936fbe0.Borrow(ch_allocs)

	x.ref9936fbe0 = ref9936fbe0
	x.allocs9936fbe0 = allocs9936fbe0
	return ref9936fbe0, allocs9936fbe0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsAlgorithmDetailEcc) PassValue() (C.TPMS_ALGORITHM_DETAIL_ECC, *cgoAllocMap) {
	if x.ref9936fbe0 != nil {
		return *x.ref9936fbe0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsAlgorithmDetailEcc) Deref() {
	if x.ref9936fbe0 == nil {
		return
	}
	x.Curveid = (Tpm2EccCurve)(x.ref9936fbe0.curveID)
	x.Keysize = (Uint16)(x.ref9936fbe0.keySize)
	x.Kdf = *NewTpmtKdfSchemeRef(unsafe.Pointer(&x.ref9936fbe0.kdf))
	x.Sign = *NewTpmtEccSchemeRef(unsafe.Pointer(&x.ref9936fbe0.sign))
	x.P = *NewTpm2bEccParameterRef(unsafe.Pointer(&x.ref9936fbe0.p))
	x.A = *NewTpm2bEccParameterRef(unsafe.Pointer(&x.ref9936fbe0.a))
	x.B = *NewTpm2bEccParameterRef(unsafe.Pointer(&x.ref9936fbe0.b))
	x.Gx = *NewTpm2bEccParameterRef(unsafe.Pointer(&x.ref9936fbe0.gX))
	x.Gy = *NewTpm2bEccParameterRef(unsafe.Pointer(&x.ref9936fbe0.gY))
	x.N = *NewTpm2bEccParameterRef(unsafe.Pointer(&x.ref9936fbe0.n))
	x.H = *NewTpm2bEccParameterRef(unsafe.Pointer(&x.ref9936fbe0.h))
}

// allocTpmsSignatureRsaMemory allocates memory for type C.TPMS_SIGNATURE_RSA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsSignatureRsaMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsSignatureRsaValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsSignatureRsaValue = unsafe.Sizeof([1]C.TPMS_SIGNATURE_RSA{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsSignatureRsa) Ref() *C.TPMS_SIGNATURE_RSA {
	if x == nil {
		return nil
	}
	return x.refc969a88e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsSignatureRsa) Free() {
	if x != nil && x.allocsc969a88e != nil {
		x.allocsc969a88e.(*cgoAllocMap).Free()
		x.refc969a88e = nil
	}
}

// NewTpmsSignatureRsaRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsSignatureRsaRef(ref unsafe.Pointer) *TpmsSignatureRsa {
	if ref == nil {
		return nil
	}
	obj := new(TpmsSignatureRsa)
	obj.refc969a88e = (*C.TPMS_SIGNATURE_RSA)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsSignatureRsa) PassRef() (*C.TPMS_SIGNATURE_RSA, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc969a88e != nil {
		return x.refc969a88e, nil
	}
	memc969a88e := allocTpmsSignatureRsaMemory(1)
	refc969a88e := (*C.TPMS_SIGNATURE_RSA)(memc969a88e)
	allocsc969a88e := new(cgoAllocMap)
	allocsc969a88e.Add(memc969a88e)

	var chash_allocs *cgoAllocMap
	refc969a88e.hash, chash_allocs = (C.TPMI_ALG_HASH)(x.Hash), cgoAllocsUnknown
	allocsc969a88e.Borrow(chash_allocs)

	var csig_allocs *cgoAllocMap
	refc969a88e.sig, csig_allocs = x.Sig.PassValue()
	allocsc969a88e.Borrow(csig_allocs)

	x.refc969a88e = refc969a88e
	x.allocsc969a88e = allocsc969a88e
	return refc969a88e, allocsc969a88e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsSignatureRsa) PassValue() (C.TPMS_SIGNATURE_RSA, *cgoAllocMap) {
	if x.refc969a88e != nil {
		return *x.refc969a88e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsSignatureRsa) Deref() {
	if x.refc969a88e == nil {
		return
	}
	x.Hash = (TpmiAlgHash)(x.refc969a88e.hash)
	x.Sig = *NewTpm2bPublicKeyRsaRef(unsafe.Pointer(&x.refc969a88e.sig))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsSignatureRsassa) Ref() *C.TPMS_SIGNATURE_RSA {
	if x == nil {
		return nil
	}
	return x.refc969a88e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsSignatureRsassa) Free() {
	if x != nil && x.allocsc969a88e != nil {
		x.allocsc969a88e.(*cgoAllocMap).Free()
		x.refc969a88e = nil
	}
}

// NewTpmsSignatureRsassaRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsSignatureRsassaRef(ref unsafe.Pointer) *TpmsSignatureRsassa {
	if ref == nil {
		return nil
	}
	obj := new(TpmsSignatureRsassa)
	obj.refc969a88e = (*C.TPMS_SIGNATURE_RSA)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsSignatureRsassa) PassRef() (*C.TPMS_SIGNATURE_RSA, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc969a88e != nil {
		return x.refc969a88e, nil
	}
	memc969a88e := allocTpmsSignatureRsaMemory(1)
	refc969a88e := (*C.TPMS_SIGNATURE_RSA)(memc969a88e)
	allocsc969a88e := new(cgoAllocMap)
	allocsc969a88e.Add(memc969a88e)

	var chash_allocs *cgoAllocMap
	refc969a88e.hash, chash_allocs = (C.TPMI_ALG_HASH)(x.Hash), cgoAllocsUnknown
	allocsc969a88e.Borrow(chash_allocs)

	var csig_allocs *cgoAllocMap
	refc969a88e.sig, csig_allocs = x.Sig.PassValue()
	allocsc969a88e.Borrow(csig_allocs)

	x.refc969a88e = refc969a88e
	x.allocsc969a88e = allocsc969a88e
	return refc969a88e, allocsc969a88e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsSignatureRsassa) PassValue() (C.TPMS_SIGNATURE_RSA, *cgoAllocMap) {
	if x.refc969a88e != nil {
		return *x.refc969a88e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsSignatureRsassa) Deref() {
	if x.refc969a88e == nil {
		return
	}
	x.Hash = (TpmiAlgHash)(x.refc969a88e.hash)
	x.Sig = *NewTpm2bPublicKeyRsaRef(unsafe.Pointer(&x.refc969a88e.sig))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsSignatureRsapss) Ref() *C.TPMS_SIGNATURE_RSA {
	if x == nil {
		return nil
	}
	return x.refc969a88e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsSignatureRsapss) Free() {
	if x != nil && x.allocsc969a88e != nil {
		x.allocsc969a88e.(*cgoAllocMap).Free()
		x.refc969a88e = nil
	}
}

// NewTpmsSignatureRsapssRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsSignatureRsapssRef(ref unsafe.Pointer) *TpmsSignatureRsapss {
	if ref == nil {
		return nil
	}
	obj := new(TpmsSignatureRsapss)
	obj.refc969a88e = (*C.TPMS_SIGNATURE_RSA)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsSignatureRsapss) PassRef() (*C.TPMS_SIGNATURE_RSA, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc969a88e != nil {
		return x.refc969a88e, nil
	}
	memc969a88e := allocTpmsSignatureRsaMemory(1)
	refc969a88e := (*C.TPMS_SIGNATURE_RSA)(memc969a88e)
	allocsc969a88e := new(cgoAllocMap)
	allocsc969a88e.Add(memc969a88e)

	var chash_allocs *cgoAllocMap
	refc969a88e.hash, chash_allocs = (C.TPMI_ALG_HASH)(x.Hash), cgoAllocsUnknown
	allocsc969a88e.Borrow(chash_allocs)

	var csig_allocs *cgoAllocMap
	refc969a88e.sig, csig_allocs = x.Sig.PassValue()
	allocsc969a88e.Borrow(csig_allocs)

	x.refc969a88e = refc969a88e
	x.allocsc969a88e = allocsc969a88e
	return refc969a88e, allocsc969a88e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsSignatureRsapss) PassValue() (C.TPMS_SIGNATURE_RSA, *cgoAllocMap) {
	if x.refc969a88e != nil {
		return *x.refc969a88e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsSignatureRsapss) Deref() {
	if x.refc969a88e == nil {
		return
	}
	x.Hash = (TpmiAlgHash)(x.refc969a88e.hash)
	x.Sig = *NewTpm2bPublicKeyRsaRef(unsafe.Pointer(&x.refc969a88e.sig))
}

// allocTpmsSignatureEccMemory allocates memory for type C.TPMS_SIGNATURE_ECC in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsSignatureEccMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsSignatureEccValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsSignatureEccValue = unsafe.Sizeof([1]C.TPMS_SIGNATURE_ECC{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsSignatureEcc) Ref() *C.TPMS_SIGNATURE_ECC {
	if x == nil {
		return nil
	}
	return x.ref74cc6e06
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsSignatureEcc) Free() {
	if x != nil && x.allocs74cc6e06 != nil {
		x.allocs74cc6e06.(*cgoAllocMap).Free()
		x.ref74cc6e06 = nil
	}
}

// NewTpmsSignatureEccRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsSignatureEccRef(ref unsafe.Pointer) *TpmsSignatureEcc {
	if ref == nil {
		return nil
	}
	obj := new(TpmsSignatureEcc)
	obj.ref74cc6e06 = (*C.TPMS_SIGNATURE_ECC)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsSignatureEcc) PassRef() (*C.TPMS_SIGNATURE_ECC, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref74cc6e06 != nil {
		return x.ref74cc6e06, nil
	}
	mem74cc6e06 := allocTpmsSignatureEccMemory(1)
	ref74cc6e06 := (*C.TPMS_SIGNATURE_ECC)(mem74cc6e06)
	allocs74cc6e06 := new(cgoAllocMap)
	allocs74cc6e06.Add(mem74cc6e06)

	var chash_allocs *cgoAllocMap
	ref74cc6e06.hash, chash_allocs = (C.TPMI_ALG_HASH)(x.Hash), cgoAllocsUnknown
	allocs74cc6e06.Borrow(chash_allocs)

	var csignatureR_allocs *cgoAllocMap
	ref74cc6e06.signatureR, csignatureR_allocs = x.Signaturer.PassValue()
	allocs74cc6e06.Borrow(csignatureR_allocs)

	var csignatureS_allocs *cgoAllocMap
	ref74cc6e06.signatureS, csignatureS_allocs = x.Signatures.PassValue()
	allocs74cc6e06.Borrow(csignatureS_allocs)

	x.ref74cc6e06 = ref74cc6e06
	x.allocs74cc6e06 = allocs74cc6e06
	return ref74cc6e06, allocs74cc6e06

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsSignatureEcc) PassValue() (C.TPMS_SIGNATURE_ECC, *cgoAllocMap) {
	if x.ref74cc6e06 != nil {
		return *x.ref74cc6e06, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsSignatureEcc) Deref() {
	if x.ref74cc6e06 == nil {
		return
	}
	x.Hash = (TpmiAlgHash)(x.ref74cc6e06.hash)
	x.Signaturer = *NewTpm2bEccParameterRef(unsafe.Pointer(&x.ref74cc6e06.signatureR))
	x.Signatures = *NewTpm2bEccParameterRef(unsafe.Pointer(&x.ref74cc6e06.signatureS))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsSignatureEcdsa) Ref() *C.TPMS_SIGNATURE_ECC {
	if x == nil {
		return nil
	}
	return x.ref74cc6e06
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsSignatureEcdsa) Free() {
	if x != nil && x.allocs74cc6e06 != nil {
		x.allocs74cc6e06.(*cgoAllocMap).Free()
		x.ref74cc6e06 = nil
	}
}

// NewTpmsSignatureEcdsaRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsSignatureEcdsaRef(ref unsafe.Pointer) *TpmsSignatureEcdsa {
	if ref == nil {
		return nil
	}
	obj := new(TpmsSignatureEcdsa)
	obj.ref74cc6e06 = (*C.TPMS_SIGNATURE_ECC)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsSignatureEcdsa) PassRef() (*C.TPMS_SIGNATURE_ECC, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref74cc6e06 != nil {
		return x.ref74cc6e06, nil
	}
	mem74cc6e06 := allocTpmsSignatureEccMemory(1)
	ref74cc6e06 := (*C.TPMS_SIGNATURE_ECC)(mem74cc6e06)
	allocs74cc6e06 := new(cgoAllocMap)
	allocs74cc6e06.Add(mem74cc6e06)

	var chash_allocs *cgoAllocMap
	ref74cc6e06.hash, chash_allocs = (C.TPMI_ALG_HASH)(x.Hash), cgoAllocsUnknown
	allocs74cc6e06.Borrow(chash_allocs)

	var csignatureR_allocs *cgoAllocMap
	ref74cc6e06.signatureR, csignatureR_allocs = x.Signaturer.PassValue()
	allocs74cc6e06.Borrow(csignatureR_allocs)

	var csignatureS_allocs *cgoAllocMap
	ref74cc6e06.signatureS, csignatureS_allocs = x.Signatures.PassValue()
	allocs74cc6e06.Borrow(csignatureS_allocs)

	x.ref74cc6e06 = ref74cc6e06
	x.allocs74cc6e06 = allocs74cc6e06
	return ref74cc6e06, allocs74cc6e06

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsSignatureEcdsa) PassValue() (C.TPMS_SIGNATURE_ECC, *cgoAllocMap) {
	if x.ref74cc6e06 != nil {
		return *x.ref74cc6e06, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsSignatureEcdsa) Deref() {
	if x.ref74cc6e06 == nil {
		return
	}
	x.Hash = (TpmiAlgHash)(x.ref74cc6e06.hash)
	x.Signaturer = *NewTpm2bEccParameterRef(unsafe.Pointer(&x.ref74cc6e06.signatureR))
	x.Signatures = *NewTpm2bEccParameterRef(unsafe.Pointer(&x.ref74cc6e06.signatureS))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsSignatureEcdaa) Ref() *C.TPMS_SIGNATURE_ECC {
	if x == nil {
		return nil
	}
	return x.ref74cc6e06
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsSignatureEcdaa) Free() {
	if x != nil && x.allocs74cc6e06 != nil {
		x.allocs74cc6e06.(*cgoAllocMap).Free()
		x.ref74cc6e06 = nil
	}
}

// NewTpmsSignatureEcdaaRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsSignatureEcdaaRef(ref unsafe.Pointer) *TpmsSignatureEcdaa {
	if ref == nil {
		return nil
	}
	obj := new(TpmsSignatureEcdaa)
	obj.ref74cc6e06 = (*C.TPMS_SIGNATURE_ECC)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsSignatureEcdaa) PassRef() (*C.TPMS_SIGNATURE_ECC, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref74cc6e06 != nil {
		return x.ref74cc6e06, nil
	}
	mem74cc6e06 := allocTpmsSignatureEccMemory(1)
	ref74cc6e06 := (*C.TPMS_SIGNATURE_ECC)(mem74cc6e06)
	allocs74cc6e06 := new(cgoAllocMap)
	allocs74cc6e06.Add(mem74cc6e06)

	var chash_allocs *cgoAllocMap
	ref74cc6e06.hash, chash_allocs = (C.TPMI_ALG_HASH)(x.Hash), cgoAllocsUnknown
	allocs74cc6e06.Borrow(chash_allocs)

	var csignatureR_allocs *cgoAllocMap
	ref74cc6e06.signatureR, csignatureR_allocs = x.Signaturer.PassValue()
	allocs74cc6e06.Borrow(csignatureR_allocs)

	var csignatureS_allocs *cgoAllocMap
	ref74cc6e06.signatureS, csignatureS_allocs = x.Signatures.PassValue()
	allocs74cc6e06.Borrow(csignatureS_allocs)

	x.ref74cc6e06 = ref74cc6e06
	x.allocs74cc6e06 = allocs74cc6e06
	return ref74cc6e06, allocs74cc6e06

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsSignatureEcdaa) PassValue() (C.TPMS_SIGNATURE_ECC, *cgoAllocMap) {
	if x.ref74cc6e06 != nil {
		return *x.ref74cc6e06, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsSignatureEcdaa) Deref() {
	if x.ref74cc6e06 == nil {
		return
	}
	x.Hash = (TpmiAlgHash)(x.ref74cc6e06.hash)
	x.Signaturer = *NewTpm2bEccParameterRef(unsafe.Pointer(&x.ref74cc6e06.signatureR))
	x.Signatures = *NewTpm2bEccParameterRef(unsafe.Pointer(&x.ref74cc6e06.signatureS))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsSignatureSm2) Ref() *C.TPMS_SIGNATURE_ECC {
	if x == nil {
		return nil
	}
	return x.ref74cc6e06
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsSignatureSm2) Free() {
	if x != nil && x.allocs74cc6e06 != nil {
		x.allocs74cc6e06.(*cgoAllocMap).Free()
		x.ref74cc6e06 = nil
	}
}

// NewTpmsSignatureSm2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsSignatureSm2Ref(ref unsafe.Pointer) *TpmsSignatureSm2 {
	if ref == nil {
		return nil
	}
	obj := new(TpmsSignatureSm2)
	obj.ref74cc6e06 = (*C.TPMS_SIGNATURE_ECC)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsSignatureSm2) PassRef() (*C.TPMS_SIGNATURE_ECC, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref74cc6e06 != nil {
		return x.ref74cc6e06, nil
	}
	mem74cc6e06 := allocTpmsSignatureEccMemory(1)
	ref74cc6e06 := (*C.TPMS_SIGNATURE_ECC)(mem74cc6e06)
	allocs74cc6e06 := new(cgoAllocMap)
	allocs74cc6e06.Add(mem74cc6e06)

	var chash_allocs *cgoAllocMap
	ref74cc6e06.hash, chash_allocs = (C.TPMI_ALG_HASH)(x.Hash), cgoAllocsUnknown
	allocs74cc6e06.Borrow(chash_allocs)

	var csignatureR_allocs *cgoAllocMap
	ref74cc6e06.signatureR, csignatureR_allocs = x.Signaturer.PassValue()
	allocs74cc6e06.Borrow(csignatureR_allocs)

	var csignatureS_allocs *cgoAllocMap
	ref74cc6e06.signatureS, csignatureS_allocs = x.Signatures.PassValue()
	allocs74cc6e06.Borrow(csignatureS_allocs)

	x.ref74cc6e06 = ref74cc6e06
	x.allocs74cc6e06 = allocs74cc6e06
	return ref74cc6e06, allocs74cc6e06

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsSignatureSm2) PassValue() (C.TPMS_SIGNATURE_ECC, *cgoAllocMap) {
	if x.ref74cc6e06 != nil {
		return *x.ref74cc6e06, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsSignatureSm2) Deref() {
	if x.ref74cc6e06 == nil {
		return
	}
	x.Hash = (TpmiAlgHash)(x.ref74cc6e06.hash)
	x.Signaturer = *NewTpm2bEccParameterRef(unsafe.Pointer(&x.ref74cc6e06.signatureR))
	x.Signatures = *NewTpm2bEccParameterRef(unsafe.Pointer(&x.ref74cc6e06.signatureS))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsSignatureEcschnorr) Ref() *C.TPMS_SIGNATURE_ECC {
	if x == nil {
		return nil
	}
	return x.ref74cc6e06
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsSignatureEcschnorr) Free() {
	if x != nil && x.allocs74cc6e06 != nil {
		x.allocs74cc6e06.(*cgoAllocMap).Free()
		x.ref74cc6e06 = nil
	}
}

// NewTpmsSignatureEcschnorrRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsSignatureEcschnorrRef(ref unsafe.Pointer) *TpmsSignatureEcschnorr {
	if ref == nil {
		return nil
	}
	obj := new(TpmsSignatureEcschnorr)
	obj.ref74cc6e06 = (*C.TPMS_SIGNATURE_ECC)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsSignatureEcschnorr) PassRef() (*C.TPMS_SIGNATURE_ECC, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref74cc6e06 != nil {
		return x.ref74cc6e06, nil
	}
	mem74cc6e06 := allocTpmsSignatureEccMemory(1)
	ref74cc6e06 := (*C.TPMS_SIGNATURE_ECC)(mem74cc6e06)
	allocs74cc6e06 := new(cgoAllocMap)
	allocs74cc6e06.Add(mem74cc6e06)

	var chash_allocs *cgoAllocMap
	ref74cc6e06.hash, chash_allocs = (C.TPMI_ALG_HASH)(x.Hash), cgoAllocsUnknown
	allocs74cc6e06.Borrow(chash_allocs)

	var csignatureR_allocs *cgoAllocMap
	ref74cc6e06.signatureR, csignatureR_allocs = x.Signaturer.PassValue()
	allocs74cc6e06.Borrow(csignatureR_allocs)

	var csignatureS_allocs *cgoAllocMap
	ref74cc6e06.signatureS, csignatureS_allocs = x.Signatures.PassValue()
	allocs74cc6e06.Borrow(csignatureS_allocs)

	x.ref74cc6e06 = ref74cc6e06
	x.allocs74cc6e06 = allocs74cc6e06
	return ref74cc6e06, allocs74cc6e06

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsSignatureEcschnorr) PassValue() (C.TPMS_SIGNATURE_ECC, *cgoAllocMap) {
	if x.ref74cc6e06 != nil {
		return *x.ref74cc6e06, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsSignatureEcschnorr) Deref() {
	if x.ref74cc6e06 == nil {
		return
	}
	x.Hash = (TpmiAlgHash)(x.ref74cc6e06.hash)
	x.Signaturer = *NewTpm2bEccParameterRef(unsafe.Pointer(&x.ref74cc6e06.signatureR))
	x.Signatures = *NewTpm2bEccParameterRef(unsafe.Pointer(&x.ref74cc6e06.signatureS))
}

// allocTpmtSignatureMemory allocates memory for type C.TPMT_SIGNATURE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtSignatureMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtSignatureValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtSignatureValue = unsafe.Sizeof([1]C.TPMT_SIGNATURE{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmtSignature) Ref() *C.TPMT_SIGNATURE {
	if x == nil {
		return nil
	}
	return x.refc461c44d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmtSignature) Free() {
	if x != nil && x.allocsc461c44d != nil {
		x.allocsc461c44d.(*cgoAllocMap).Free()
		x.refc461c44d = nil
	}
}

// NewTpmtSignatureRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmtSignatureRef(ref unsafe.Pointer) *TpmtSignature {
	if ref == nil {
		return nil
	}
	obj := new(TpmtSignature)
	obj.refc461c44d = (*C.TPMT_SIGNATURE)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmtSignature) PassRef() (*C.TPMT_SIGNATURE, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc461c44d != nil {
		return x.refc461c44d, nil
	}
	memc461c44d := allocTpmtSignatureMemory(1)
	refc461c44d := (*C.TPMT_SIGNATURE)(memc461c44d)
	allocsc461c44d := new(cgoAllocMap)
	allocsc461c44d.Add(memc461c44d)

	var csigAlg_allocs *cgoAllocMap
	refc461c44d.sigAlg, csigAlg_allocs = (C.TPMI_ALG_SIG_SCHEME)(x.Sigalg), cgoAllocsUnknown
	allocsc461c44d.Borrow(csigAlg_allocs)

	var csignature_allocs *cgoAllocMap
	refc461c44d.signature, csignature_allocs = *(*C.TPMU_SIGNATURE)(unsafe.Pointer(&x.Signature)), cgoAllocsUnknown
	allocsc461c44d.Borrow(csignature_allocs)

	x.refc461c44d = refc461c44d
	x.allocsc461c44d = allocsc461c44d
	return refc461c44d, allocsc461c44d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmtSignature) PassValue() (C.TPMT_SIGNATURE, *cgoAllocMap) {
	if x.refc461c44d != nil {
		return *x.refc461c44d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmtSignature) Deref() {
	if x.refc461c44d == nil {
		return
	}
	x.Sigalg = (TpmiAlgSigScheme)(x.refc461c44d.sigAlg)
	x.Signature = *(*TpmuSignature)(unsafe.Pointer(&x.refc461c44d.signature))
}

// allocTpm2bEncryptedSecretMemory allocates memory for type C.TPM2B_ENCRYPTED_SECRET in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bEncryptedSecretMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bEncryptedSecretValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bEncryptedSecretValue = unsafe.Sizeof([1]C.TPM2B_ENCRYPTED_SECRET{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Tpm2bEncryptedSecret) Ref() *C.TPM2B_ENCRYPTED_SECRET {
	if x == nil {
		return nil
	}
	return x.ref66c6332e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Tpm2bEncryptedSecret) Free() {
	if x != nil && x.allocs66c6332e != nil {
		x.allocs66c6332e.(*cgoAllocMap).Free()
		x.ref66c6332e = nil
	}
}

// NewTpm2bEncryptedSecretRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpm2bEncryptedSecretRef(ref unsafe.Pointer) *Tpm2bEncryptedSecret {
	if ref == nil {
		return nil
	}
	obj := new(Tpm2bEncryptedSecret)
	obj.ref66c6332e = (*C.TPM2B_ENCRYPTED_SECRET)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Tpm2bEncryptedSecret) PassRef() (*C.TPM2B_ENCRYPTED_SECRET, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref66c6332e != nil {
		return x.ref66c6332e, nil
	}
	mem66c6332e := allocTpm2bEncryptedSecretMemory(1)
	ref66c6332e := (*C.TPM2B_ENCRYPTED_SECRET)(mem66c6332e)
	allocs66c6332e := new(cgoAllocMap)
	allocs66c6332e.Add(mem66c6332e)

	var csize_allocs *cgoAllocMap
	ref66c6332e.size, csize_allocs = (C.UINT16)(x.Size), cgoAllocsUnknown
	allocs66c6332e.Borrow(csize_allocs)

	var csecret_allocs *cgoAllocMap
	ref66c6332e.secret, csecret_allocs = *(*[512]C.BYTE)(unsafe.Pointer(&x.Secret)), cgoAllocsUnknown
	allocs66c6332e.Borrow(csecret_allocs)

	x.ref66c6332e = ref66c6332e
	x.allocs66c6332e = allocs66c6332e
	return ref66c6332e, allocs66c6332e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Tpm2bEncryptedSecret) PassValue() (C.TPM2B_ENCRYPTED_SECRET, *cgoAllocMap) {
	if x.ref66c6332e != nil {
		return *x.ref66c6332e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Tpm2bEncryptedSecret) Deref() {
	if x.ref66c6332e == nil {
		return
	}
	x.Size = (Uint16)(x.ref66c6332e.size)
	x.Secret = *(*[512]Byte)(unsafe.Pointer(&x.ref66c6332e.secret))
}

// allocTpmsKeyedhashParmsMemory allocates memory for type C.TPMS_KEYEDHASH_PARMS in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsKeyedhashParmsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsKeyedhashParmsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsKeyedhashParmsValue = unsafe.Sizeof([1]C.TPMS_KEYEDHASH_PARMS{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsKeyedhashParms) Ref() *C.TPMS_KEYEDHASH_PARMS {
	if x == nil {
		return nil
	}
	return x.ref9b28d654
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsKeyedhashParms) Free() {
	if x != nil && x.allocs9b28d654 != nil {
		x.allocs9b28d654.(*cgoAllocMap).Free()
		x.ref9b28d654 = nil
	}
}

// NewTpmsKeyedhashParmsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsKeyedhashParmsRef(ref unsafe.Pointer) *TpmsKeyedhashParms {
	if ref == nil {
		return nil
	}
	obj := new(TpmsKeyedhashParms)
	obj.ref9b28d654 = (*C.TPMS_KEYEDHASH_PARMS)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsKeyedhashParms) PassRef() (*C.TPMS_KEYEDHASH_PARMS, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9b28d654 != nil {
		return x.ref9b28d654, nil
	}
	mem9b28d654 := allocTpmsKeyedhashParmsMemory(1)
	ref9b28d654 := (*C.TPMS_KEYEDHASH_PARMS)(mem9b28d654)
	allocs9b28d654 := new(cgoAllocMap)
	allocs9b28d654.Add(mem9b28d654)

	var cscheme_allocs *cgoAllocMap
	ref9b28d654.scheme, cscheme_allocs = x.Scheme.PassValue()
	allocs9b28d654.Borrow(cscheme_allocs)

	x.ref9b28d654 = ref9b28d654
	x.allocs9b28d654 = allocs9b28d654
	return ref9b28d654, allocs9b28d654

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsKeyedhashParms) PassValue() (C.TPMS_KEYEDHASH_PARMS, *cgoAllocMap) {
	if x.ref9b28d654 != nil {
		return *x.ref9b28d654, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsKeyedhashParms) Deref() {
	if x.ref9b28d654 == nil {
		return
	}
	x.Scheme = *NewTpmtKeyedhashSchemeRef(unsafe.Pointer(&x.ref9b28d654.scheme))
}

// allocTpmsAsymParmsMemory allocates memory for type C.TPMS_ASYM_PARMS in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsAsymParmsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsAsymParmsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsAsymParmsValue = unsafe.Sizeof([1]C.TPMS_ASYM_PARMS{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsAsymParms) Ref() *C.TPMS_ASYM_PARMS {
	if x == nil {
		return nil
	}
	return x.refc5c375f0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsAsymParms) Free() {
	if x != nil && x.allocsc5c375f0 != nil {
		x.allocsc5c375f0.(*cgoAllocMap).Free()
		x.refc5c375f0 = nil
	}
}

// NewTpmsAsymParmsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsAsymParmsRef(ref unsafe.Pointer) *TpmsAsymParms {
	if ref == nil {
		return nil
	}
	obj := new(TpmsAsymParms)
	obj.refc5c375f0 = (*C.TPMS_ASYM_PARMS)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsAsymParms) PassRef() (*C.TPMS_ASYM_PARMS, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc5c375f0 != nil {
		return x.refc5c375f0, nil
	}
	memc5c375f0 := allocTpmsAsymParmsMemory(1)
	refc5c375f0 := (*C.TPMS_ASYM_PARMS)(memc5c375f0)
	allocsc5c375f0 := new(cgoAllocMap)
	allocsc5c375f0.Add(memc5c375f0)

	var csymmetric_allocs *cgoAllocMap
	refc5c375f0.symmetric, csymmetric_allocs = x.Symmetric.PassValue()
	allocsc5c375f0.Borrow(csymmetric_allocs)

	var cscheme_allocs *cgoAllocMap
	refc5c375f0.scheme, cscheme_allocs = x.Scheme.PassValue()
	allocsc5c375f0.Borrow(cscheme_allocs)

	x.refc5c375f0 = refc5c375f0
	x.allocsc5c375f0 = allocsc5c375f0
	return refc5c375f0, allocsc5c375f0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsAsymParms) PassValue() (C.TPMS_ASYM_PARMS, *cgoAllocMap) {
	if x.refc5c375f0 != nil {
		return *x.refc5c375f0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsAsymParms) Deref() {
	if x.refc5c375f0 == nil {
		return
	}
	x.Symmetric = *NewTpmtSymDefObjectRef(unsafe.Pointer(&x.refc5c375f0.symmetric))
	x.Scheme = *NewTpmtAsymSchemeRef(unsafe.Pointer(&x.refc5c375f0.scheme))
}

// allocTpmsRsaParmsMemory allocates memory for type C.TPMS_RSA_PARMS in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsRsaParmsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsRsaParmsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsRsaParmsValue = unsafe.Sizeof([1]C.TPMS_RSA_PARMS{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsRsaParms) Ref() *C.TPMS_RSA_PARMS {
	if x == nil {
		return nil
	}
	return x.refba86b8bf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsRsaParms) Free() {
	if x != nil && x.allocsba86b8bf != nil {
		x.allocsba86b8bf.(*cgoAllocMap).Free()
		x.refba86b8bf = nil
	}
}

// NewTpmsRsaParmsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsRsaParmsRef(ref unsafe.Pointer) *TpmsRsaParms {
	if ref == nil {
		return nil
	}
	obj := new(TpmsRsaParms)
	obj.refba86b8bf = (*C.TPMS_RSA_PARMS)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsRsaParms) PassRef() (*C.TPMS_RSA_PARMS, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refba86b8bf != nil {
		return x.refba86b8bf, nil
	}
	memba86b8bf := allocTpmsRsaParmsMemory(1)
	refba86b8bf := (*C.TPMS_RSA_PARMS)(memba86b8bf)
	allocsba86b8bf := new(cgoAllocMap)
	allocsba86b8bf.Add(memba86b8bf)

	var csymmetric_allocs *cgoAllocMap
	refba86b8bf.symmetric, csymmetric_allocs = x.Symmetric.PassValue()
	allocsba86b8bf.Borrow(csymmetric_allocs)

	var cscheme_allocs *cgoAllocMap
	refba86b8bf.scheme, cscheme_allocs = x.Scheme.PassValue()
	allocsba86b8bf.Borrow(cscheme_allocs)

	var ckeyBits_allocs *cgoAllocMap
	refba86b8bf.keyBits, ckeyBits_allocs = (C.TPMI_RSA_KEY_BITS)(x.Keybits), cgoAllocsUnknown
	allocsba86b8bf.Borrow(ckeyBits_allocs)

	var cexponent_allocs *cgoAllocMap
	refba86b8bf.exponent, cexponent_allocs = (C.UINT32)(x.Exponent), cgoAllocsUnknown
	allocsba86b8bf.Borrow(cexponent_allocs)

	x.refba86b8bf = refba86b8bf
	x.allocsba86b8bf = allocsba86b8bf
	return refba86b8bf, allocsba86b8bf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsRsaParms) PassValue() (C.TPMS_RSA_PARMS, *cgoAllocMap) {
	if x.refba86b8bf != nil {
		return *x.refba86b8bf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsRsaParms) Deref() {
	if x.refba86b8bf == nil {
		return
	}
	x.Symmetric = *NewTpmtSymDefObjectRef(unsafe.Pointer(&x.refba86b8bf.symmetric))
	x.Scheme = *NewTpmtRsaSchemeRef(unsafe.Pointer(&x.refba86b8bf.scheme))
	x.Keybits = (TpmiRsaKeyBits)(x.refba86b8bf.keyBits)
	x.Exponent = (Uint32)(x.refba86b8bf.exponent)
}

// allocTpmsEccParmsMemory allocates memory for type C.TPMS_ECC_PARMS in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsEccParmsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsEccParmsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsEccParmsValue = unsafe.Sizeof([1]C.TPMS_ECC_PARMS{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsEccParms) Ref() *C.TPMS_ECC_PARMS {
	if x == nil {
		return nil
	}
	return x.ref9903b705
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsEccParms) Free() {
	if x != nil && x.allocs9903b705 != nil {
		x.allocs9903b705.(*cgoAllocMap).Free()
		x.ref9903b705 = nil
	}
}

// NewTpmsEccParmsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsEccParmsRef(ref unsafe.Pointer) *TpmsEccParms {
	if ref == nil {
		return nil
	}
	obj := new(TpmsEccParms)
	obj.ref9903b705 = (*C.TPMS_ECC_PARMS)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsEccParms) PassRef() (*C.TPMS_ECC_PARMS, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9903b705 != nil {
		return x.ref9903b705, nil
	}
	mem9903b705 := allocTpmsEccParmsMemory(1)
	ref9903b705 := (*C.TPMS_ECC_PARMS)(mem9903b705)
	allocs9903b705 := new(cgoAllocMap)
	allocs9903b705.Add(mem9903b705)

	var csymmetric_allocs *cgoAllocMap
	ref9903b705.symmetric, csymmetric_allocs = x.Symmetric.PassValue()
	allocs9903b705.Borrow(csymmetric_allocs)

	var cscheme_allocs *cgoAllocMap
	ref9903b705.scheme, cscheme_allocs = x.Scheme.PassValue()
	allocs9903b705.Borrow(cscheme_allocs)

	var ccurveID_allocs *cgoAllocMap
	ref9903b705.curveID, ccurveID_allocs = (C.TPMI_ECC_CURVE)(x.Curveid), cgoAllocsUnknown
	allocs9903b705.Borrow(ccurveID_allocs)

	var ckdf_allocs *cgoAllocMap
	ref9903b705.kdf, ckdf_allocs = x.Kdf.PassValue()
	allocs9903b705.Borrow(ckdf_allocs)

	x.ref9903b705 = ref9903b705
	x.allocs9903b705 = allocs9903b705
	return ref9903b705, allocs9903b705

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsEccParms) PassValue() (C.TPMS_ECC_PARMS, *cgoAllocMap) {
	if x.ref9903b705 != nil {
		return *x.ref9903b705, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsEccParms) Deref() {
	if x.ref9903b705 == nil {
		return
	}
	x.Symmetric = *NewTpmtSymDefObjectRef(unsafe.Pointer(&x.ref9903b705.symmetric))
	x.Scheme = *NewTpmtEccSchemeRef(unsafe.Pointer(&x.ref9903b705.scheme))
	x.Curveid = (TpmiEccCurve)(x.ref9903b705.curveID)
	x.Kdf = *NewTpmtKdfSchemeRef(unsafe.Pointer(&x.ref9903b705.kdf))
}

// allocTpmtPublicParmsMemory allocates memory for type C.TPMT_PUBLIC_PARMS in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtPublicParmsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtPublicParmsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtPublicParmsValue = unsafe.Sizeof([1]C.TPMT_PUBLIC_PARMS{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmtPublicParms) Ref() *C.TPMT_PUBLIC_PARMS {
	if x == nil {
		return nil
	}
	return x.reff4a57683
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmtPublicParms) Free() {
	if x != nil && x.allocsf4a57683 != nil {
		x.allocsf4a57683.(*cgoAllocMap).Free()
		x.reff4a57683 = nil
	}
}

// NewTpmtPublicParmsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmtPublicParmsRef(ref unsafe.Pointer) *TpmtPublicParms {
	if ref == nil {
		return nil
	}
	obj := new(TpmtPublicParms)
	obj.reff4a57683 = (*C.TPMT_PUBLIC_PARMS)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmtPublicParms) PassRef() (*C.TPMT_PUBLIC_PARMS, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff4a57683 != nil {
		return x.reff4a57683, nil
	}
	memf4a57683 := allocTpmtPublicParmsMemory(1)
	reff4a57683 := (*C.TPMT_PUBLIC_PARMS)(memf4a57683)
	allocsf4a57683 := new(cgoAllocMap)
	allocsf4a57683.Add(memf4a57683)

	var c_type_allocs *cgoAllocMap
	reff4a57683._type, c_type_allocs = (C.TPMI_ALG_PUBLIC)(x.Type), cgoAllocsUnknown
	allocsf4a57683.Borrow(c_type_allocs)

	var cparameters_allocs *cgoAllocMap
	reff4a57683.parameters, cparameters_allocs = *(*C.TPMU_PUBLIC_PARMS)(unsafe.Pointer(&x.Parameters)), cgoAllocsUnknown
	allocsf4a57683.Borrow(cparameters_allocs)

	x.reff4a57683 = reff4a57683
	x.allocsf4a57683 = allocsf4a57683
	return reff4a57683, allocsf4a57683

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmtPublicParms) PassValue() (C.TPMT_PUBLIC_PARMS, *cgoAllocMap) {
	if x.reff4a57683 != nil {
		return *x.reff4a57683, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmtPublicParms) Deref() {
	if x.reff4a57683 == nil {
		return
	}
	x.Type = (TpmiAlgPublic)(x.reff4a57683._type)
	x.Parameters = *(*TpmuPublicParms)(unsafe.Pointer(&x.reff4a57683.parameters))
}

// allocTpmtPublicMemory allocates memory for type C.TPMT_PUBLIC in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtPublicMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtPublicValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtPublicValue = unsafe.Sizeof([1]C.TPMT_PUBLIC{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmtPublic) Ref() *C.TPMT_PUBLIC {
	if x == nil {
		return nil
	}
	return x.ref4b565108
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmtPublic) Free() {
	if x != nil && x.allocs4b565108 != nil {
		x.allocs4b565108.(*cgoAllocMap).Free()
		x.ref4b565108 = nil
	}
}

// NewTpmtPublicRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmtPublicRef(ref unsafe.Pointer) *TpmtPublic {
	if ref == nil {
		return nil
	}
	obj := new(TpmtPublic)
	obj.ref4b565108 = (*C.TPMT_PUBLIC)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmtPublic) PassRef() (*C.TPMT_PUBLIC, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4b565108 != nil {
		return x.ref4b565108, nil
	}
	mem4b565108 := allocTpmtPublicMemory(1)
	ref4b565108 := (*C.TPMT_PUBLIC)(mem4b565108)
	allocs4b565108 := new(cgoAllocMap)
	allocs4b565108.Add(mem4b565108)

	var c_type_allocs *cgoAllocMap
	ref4b565108._type, c_type_allocs = (C.TPMI_ALG_PUBLIC)(x.Type), cgoAllocsUnknown
	allocs4b565108.Borrow(c_type_allocs)

	var cnameAlg_allocs *cgoAllocMap
	ref4b565108.nameAlg, cnameAlg_allocs = (C.TPMI_ALG_HASH)(x.Namealg), cgoAllocsUnknown
	allocs4b565108.Borrow(cnameAlg_allocs)

	var cobjectAttributes_allocs *cgoAllocMap
	ref4b565108.objectAttributes, cobjectAttributes_allocs = (C.TPMA_OBJECT)(x.Objectattributes), cgoAllocsUnknown
	allocs4b565108.Borrow(cobjectAttributes_allocs)

	var cauthPolicy_allocs *cgoAllocMap
	ref4b565108.authPolicy, cauthPolicy_allocs = x.Authpolicy.PassValue()
	allocs4b565108.Borrow(cauthPolicy_allocs)

	var cparameters_allocs *cgoAllocMap
	ref4b565108.parameters, cparameters_allocs = *(*C.TPMU_PUBLIC_PARMS)(unsafe.Pointer(&x.Parameters)), cgoAllocsUnknown
	allocs4b565108.Borrow(cparameters_allocs)

	var cunique_allocs *cgoAllocMap
	ref4b565108.unique, cunique_allocs = *(*C.TPMU_PUBLIC_ID)(unsafe.Pointer(&x.Unique)), cgoAllocsUnknown
	allocs4b565108.Borrow(cunique_allocs)

	x.ref4b565108 = ref4b565108
	x.allocs4b565108 = allocs4b565108
	return ref4b565108, allocs4b565108

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmtPublic) PassValue() (C.TPMT_PUBLIC, *cgoAllocMap) {
	if x.ref4b565108 != nil {
		return *x.ref4b565108, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmtPublic) Deref() {
	if x.ref4b565108 == nil {
		return
	}
	x.Type = (TpmiAlgPublic)(x.ref4b565108._type)
	x.Namealg = (TpmiAlgHash)(x.ref4b565108.nameAlg)
	x.Objectattributes = (TpmaObject)(x.ref4b565108.objectAttributes)
	x.Authpolicy = *NewTpm2bDigestRef(unsafe.Pointer(&x.ref4b565108.authPolicy))
	x.Parameters = *(*TpmuPublicParms)(unsafe.Pointer(&x.ref4b565108.parameters))
	x.Unique = *(*TpmuPublicId)(unsafe.Pointer(&x.ref4b565108.unique))
}

// allocTpm2bPublicMemory allocates memory for type C.TPM2B_PUBLIC in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bPublicMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bPublicValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bPublicValue = unsafe.Sizeof([1]C.TPM2B_PUBLIC{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Tpm2bPublic) Ref() *C.TPM2B_PUBLIC {
	if x == nil {
		return nil
	}
	return x.ref933e0a8a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Tpm2bPublic) Free() {
	if x != nil && x.allocs933e0a8a != nil {
		x.allocs933e0a8a.(*cgoAllocMap).Free()
		x.ref933e0a8a = nil
	}
}

// NewTpm2bPublicRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpm2bPublicRef(ref unsafe.Pointer) *Tpm2bPublic {
	if ref == nil {
		return nil
	}
	obj := new(Tpm2bPublic)
	obj.ref933e0a8a = (*C.TPM2B_PUBLIC)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Tpm2bPublic) PassRef() (*C.TPM2B_PUBLIC, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref933e0a8a != nil {
		return x.ref933e0a8a, nil
	}
	mem933e0a8a := allocTpm2bPublicMemory(1)
	ref933e0a8a := (*C.TPM2B_PUBLIC)(mem933e0a8a)
	allocs933e0a8a := new(cgoAllocMap)
	allocs933e0a8a.Add(mem933e0a8a)

	var csize_allocs *cgoAllocMap
	ref933e0a8a.size, csize_allocs = (C.UINT16)(x.Size), cgoAllocsUnknown
	allocs933e0a8a.Borrow(csize_allocs)

	var cpublicArea_allocs *cgoAllocMap
	ref933e0a8a.publicArea, cpublicArea_allocs = x.Publicarea.PassValue()
	allocs933e0a8a.Borrow(cpublicArea_allocs)

	x.ref933e0a8a = ref933e0a8a
	x.allocs933e0a8a = allocs933e0a8a
	return ref933e0a8a, allocs933e0a8a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Tpm2bPublic) PassValue() (C.TPM2B_PUBLIC, *cgoAllocMap) {
	if x.ref933e0a8a != nil {
		return *x.ref933e0a8a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Tpm2bPublic) Deref() {
	if x.ref933e0a8a == nil {
		return
	}
	x.Size = (Uint16)(x.ref933e0a8a.size)
	x.Publicarea = *NewTpmtPublicRef(unsafe.Pointer(&x.ref933e0a8a.publicArea))
}

// allocTpm2bTemplateMemory allocates memory for type C.TPM2B_TEMPLATE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bTemplateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bTemplateValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bTemplateValue = unsafe.Sizeof([1]C.TPM2B_TEMPLATE{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Tpm2bTemplate) Ref() *C.TPM2B_TEMPLATE {
	if x == nil {
		return nil
	}
	return x.ref3b894b6f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Tpm2bTemplate) Free() {
	if x != nil && x.allocs3b894b6f != nil {
		x.allocs3b894b6f.(*cgoAllocMap).Free()
		x.ref3b894b6f = nil
	}
}

// NewTpm2bTemplateRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpm2bTemplateRef(ref unsafe.Pointer) *Tpm2bTemplate {
	if ref == nil {
		return nil
	}
	obj := new(Tpm2bTemplate)
	obj.ref3b894b6f = (*C.TPM2B_TEMPLATE)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Tpm2bTemplate) PassRef() (*C.TPM2B_TEMPLATE, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3b894b6f != nil {
		return x.ref3b894b6f, nil
	}
	mem3b894b6f := allocTpm2bTemplateMemory(1)
	ref3b894b6f := (*C.TPM2B_TEMPLATE)(mem3b894b6f)
	allocs3b894b6f := new(cgoAllocMap)
	allocs3b894b6f.Add(mem3b894b6f)

	var csize_allocs *cgoAllocMap
	ref3b894b6f.size, csize_allocs = (C.UINT16)(x.Size), cgoAllocsUnknown
	allocs3b894b6f.Borrow(csize_allocs)

	var cbuffer_allocs *cgoAllocMap
	ref3b894b6f.buffer, cbuffer_allocs = *(*[612]C.BYTE)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocs3b894b6f.Borrow(cbuffer_allocs)

	x.ref3b894b6f = ref3b894b6f
	x.allocs3b894b6f = allocs3b894b6f
	return ref3b894b6f, allocs3b894b6f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Tpm2bTemplate) PassValue() (C.TPM2B_TEMPLATE, *cgoAllocMap) {
	if x.ref3b894b6f != nil {
		return *x.ref3b894b6f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Tpm2bTemplate) Deref() {
	if x.ref3b894b6f == nil {
		return
	}
	x.Size = (Uint16)(x.ref3b894b6f.size)
	x.Buffer = *(*[612]Byte)(unsafe.Pointer(&x.ref3b894b6f.buffer))
}

// allocTpm2bPrivateVendorSpecificMemory allocates memory for type C.TPM2B_PRIVATE_VENDOR_SPECIFIC in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bPrivateVendorSpecificMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bPrivateVendorSpecificValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bPrivateVendorSpecificValue = unsafe.Sizeof([1]C.TPM2B_PRIVATE_VENDOR_SPECIFIC{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Tpm2bPrivateVendorSpecific) Ref() *C.TPM2B_PRIVATE_VENDOR_SPECIFIC {
	if x == nil {
		return nil
	}
	return x.ref40be884
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Tpm2bPrivateVendorSpecific) Free() {
	if x != nil && x.allocs40be884 != nil {
		x.allocs40be884.(*cgoAllocMap).Free()
		x.ref40be884 = nil
	}
}

// NewTpm2bPrivateVendorSpecificRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpm2bPrivateVendorSpecificRef(ref unsafe.Pointer) *Tpm2bPrivateVendorSpecific {
	if ref == nil {
		return nil
	}
	obj := new(Tpm2bPrivateVendorSpecific)
	obj.ref40be884 = (*C.TPM2B_PRIVATE_VENDOR_SPECIFIC)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Tpm2bPrivateVendorSpecific) PassRef() (*C.TPM2B_PRIVATE_VENDOR_SPECIFIC, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref40be884 != nil {
		return x.ref40be884, nil
	}
	mem40be884 := allocTpm2bPrivateVendorSpecificMemory(1)
	ref40be884 := (*C.TPM2B_PRIVATE_VENDOR_SPECIFIC)(mem40be884)
	allocs40be884 := new(cgoAllocMap)
	allocs40be884.Add(mem40be884)

	var csize_allocs *cgoAllocMap
	ref40be884.size, csize_allocs = (C.UINT16)(x.Size), cgoAllocsUnknown
	allocs40be884.Borrow(csize_allocs)

	var cbuffer_allocs *cgoAllocMap
	ref40be884.buffer, cbuffer_allocs = *(*[1280]C.BYTE)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocs40be884.Borrow(cbuffer_allocs)

	x.ref40be884 = ref40be884
	x.allocs40be884 = allocs40be884
	return ref40be884, allocs40be884

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Tpm2bPrivateVendorSpecific) PassValue() (C.TPM2B_PRIVATE_VENDOR_SPECIFIC, *cgoAllocMap) {
	if x.ref40be884 != nil {
		return *x.ref40be884, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Tpm2bPrivateVendorSpecific) Deref() {
	if x.ref40be884 == nil {
		return
	}
	x.Size = (Uint16)(x.ref40be884.size)
	x.Buffer = *(*[1280]Byte)(unsafe.Pointer(&x.ref40be884.buffer))
}

// allocTpmtSensitiveMemory allocates memory for type C.TPMT_SENSITIVE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmtSensitiveMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmtSensitiveValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmtSensitiveValue = unsafe.Sizeof([1]C.TPMT_SENSITIVE{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmtSensitive) Ref() *C.TPMT_SENSITIVE {
	if x == nil {
		return nil
	}
	return x.reff83e5145
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmtSensitive) Free() {
	if x != nil && x.allocsf83e5145 != nil {
		x.allocsf83e5145.(*cgoAllocMap).Free()
		x.reff83e5145 = nil
	}
}

// NewTpmtSensitiveRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmtSensitiveRef(ref unsafe.Pointer) *TpmtSensitive {
	if ref == nil {
		return nil
	}
	obj := new(TpmtSensitive)
	obj.reff83e5145 = (*C.TPMT_SENSITIVE)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmtSensitive) PassRef() (*C.TPMT_SENSITIVE, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff83e5145 != nil {
		return x.reff83e5145, nil
	}
	memf83e5145 := allocTpmtSensitiveMemory(1)
	reff83e5145 := (*C.TPMT_SENSITIVE)(memf83e5145)
	allocsf83e5145 := new(cgoAllocMap)
	allocsf83e5145.Add(memf83e5145)

	var csensitiveType_allocs *cgoAllocMap
	reff83e5145.sensitiveType, csensitiveType_allocs = (C.TPMI_ALG_PUBLIC)(x.Sensitivetype), cgoAllocsUnknown
	allocsf83e5145.Borrow(csensitiveType_allocs)

	var cauthValue_allocs *cgoAllocMap
	reff83e5145.authValue, cauthValue_allocs = x.Authvalue.PassValue()
	allocsf83e5145.Borrow(cauthValue_allocs)

	var cseedValue_allocs *cgoAllocMap
	reff83e5145.seedValue, cseedValue_allocs = x.Seedvalue.PassValue()
	allocsf83e5145.Borrow(cseedValue_allocs)

	var csensitive_allocs *cgoAllocMap
	reff83e5145.sensitive, csensitive_allocs = *(*C.TPMU_SENSITIVE_COMPOSITE)(unsafe.Pointer(&x.Sensitive)), cgoAllocsUnknown
	allocsf83e5145.Borrow(csensitive_allocs)

	x.reff83e5145 = reff83e5145
	x.allocsf83e5145 = allocsf83e5145
	return reff83e5145, allocsf83e5145

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmtSensitive) PassValue() (C.TPMT_SENSITIVE, *cgoAllocMap) {
	if x.reff83e5145 != nil {
		return *x.reff83e5145, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmtSensitive) Deref() {
	if x.reff83e5145 == nil {
		return
	}
	x.Sensitivetype = (TpmiAlgPublic)(x.reff83e5145.sensitiveType)
	x.Authvalue = *NewTpm2bAuthRef(unsafe.Pointer(&x.reff83e5145.authValue))
	x.Seedvalue = *NewTpm2bDigestRef(unsafe.Pointer(&x.reff83e5145.seedValue))
	x.Sensitive = *(*TpmuSensitiveComposite)(unsafe.Pointer(&x.reff83e5145.sensitive))
}

// allocTpm2bSensitiveMemory allocates memory for type C.TPM2B_SENSITIVE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bSensitiveMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bSensitiveValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bSensitiveValue = unsafe.Sizeof([1]C.TPM2B_SENSITIVE{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Tpm2bSensitive) Ref() *C.TPM2B_SENSITIVE {
	if x == nil {
		return nil
	}
	return x.refa9f386
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Tpm2bSensitive) Free() {
	if x != nil && x.allocsa9f386 != nil {
		x.allocsa9f386.(*cgoAllocMap).Free()
		x.refa9f386 = nil
	}
}

// NewTpm2bSensitiveRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpm2bSensitiveRef(ref unsafe.Pointer) *Tpm2bSensitive {
	if ref == nil {
		return nil
	}
	obj := new(Tpm2bSensitive)
	obj.refa9f386 = (*C.TPM2B_SENSITIVE)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Tpm2bSensitive) PassRef() (*C.TPM2B_SENSITIVE, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa9f386 != nil {
		return x.refa9f386, nil
	}
	mema9f386 := allocTpm2bSensitiveMemory(1)
	refa9f386 := (*C.TPM2B_SENSITIVE)(mema9f386)
	allocsa9f386 := new(cgoAllocMap)
	allocsa9f386.Add(mema9f386)

	var csize_allocs *cgoAllocMap
	refa9f386.size, csize_allocs = (C.UINT16)(x.Size), cgoAllocsUnknown
	allocsa9f386.Borrow(csize_allocs)

	var csensitiveArea_allocs *cgoAllocMap
	refa9f386.sensitiveArea, csensitiveArea_allocs = x.Sensitivearea.PassValue()
	allocsa9f386.Borrow(csensitiveArea_allocs)

	x.refa9f386 = refa9f386
	x.allocsa9f386 = allocsa9f386
	return refa9f386, allocsa9f386

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Tpm2bSensitive) PassValue() (C.TPM2B_SENSITIVE, *cgoAllocMap) {
	if x.refa9f386 != nil {
		return *x.refa9f386, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Tpm2bSensitive) Deref() {
	if x.refa9f386 == nil {
		return
	}
	x.Size = (Uint16)(x.refa9f386.size)
	x.Sensitivearea = *NewTpmtSensitiveRef(unsafe.Pointer(&x.refa9f386.sensitiveArea))
}

// Ref returns a reference to C object as it is.
func (x *Private) Ref() *C._PRIVATE {
	if x == nil {
		return nil
	}
	return (*C._PRIVATE)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Private) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPrivateRef converts the C object reference into a raw struct reference without wrapping.
func NewPrivateRef(ref unsafe.Pointer) *Private {
	return (*Private)(ref)
}

// NewPrivate allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPrivate() *Private {
	return (*Private)(allocPrivateMemory(1))
}

// allocPrivateMemory allocates memory for type C._PRIVATE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPrivateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPrivateValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPrivateValue = unsafe.Sizeof([1]C._PRIVATE{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Private) PassRef() *C._PRIVATE {
	if x == nil {
		x = (*Private)(allocPrivateMemory(1))
	}
	return (*C._PRIVATE)(unsafe.Pointer(x))
}

// allocTpm2bPrivateMemory allocates memory for type C.TPM2B_PRIVATE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bPrivateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bPrivateValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bPrivateValue = unsafe.Sizeof([1]C.TPM2B_PRIVATE{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Tpm2bPrivate) Ref() *C.TPM2B_PRIVATE {
	if x == nil {
		return nil
	}
	return x.ref87ab6dda
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Tpm2bPrivate) Free() {
	if x != nil && x.allocs87ab6dda != nil {
		x.allocs87ab6dda.(*cgoAllocMap).Free()
		x.ref87ab6dda = nil
	}
}

// NewTpm2bPrivateRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpm2bPrivateRef(ref unsafe.Pointer) *Tpm2bPrivate {
	if ref == nil {
		return nil
	}
	obj := new(Tpm2bPrivate)
	obj.ref87ab6dda = (*C.TPM2B_PRIVATE)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Tpm2bPrivate) PassRef() (*C.TPM2B_PRIVATE, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref87ab6dda != nil {
		return x.ref87ab6dda, nil
	}
	mem87ab6dda := allocTpm2bPrivateMemory(1)
	ref87ab6dda := (*C.TPM2B_PRIVATE)(mem87ab6dda)
	allocs87ab6dda := new(cgoAllocMap)
	allocs87ab6dda.Add(mem87ab6dda)

	var csize_allocs *cgoAllocMap
	ref87ab6dda.size, csize_allocs = (C.UINT16)(x.Size), cgoAllocsUnknown
	allocs87ab6dda.Borrow(csize_allocs)

	var cbuffer_allocs *cgoAllocMap
	ref87ab6dda.buffer, cbuffer_allocs = *(*[1550]C.BYTE)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocs87ab6dda.Borrow(cbuffer_allocs)

	x.ref87ab6dda = ref87ab6dda
	x.allocs87ab6dda = allocs87ab6dda
	return ref87ab6dda, allocs87ab6dda

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Tpm2bPrivate) PassValue() (C.TPM2B_PRIVATE, *cgoAllocMap) {
	if x.ref87ab6dda != nil {
		return *x.ref87ab6dda, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Tpm2bPrivate) Deref() {
	if x.ref87ab6dda == nil {
		return
	}
	x.Size = (Uint16)(x.ref87ab6dda.size)
	x.Buffer = *(*[1550]Byte)(unsafe.Pointer(&x.ref87ab6dda.buffer))
}

// allocTpmsIdObjectMemory allocates memory for type C.TPMS_ID_OBJECT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsIdObjectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsIdObjectValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsIdObjectValue = unsafe.Sizeof([1]C.TPMS_ID_OBJECT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsIdObject) Ref() *C.TPMS_ID_OBJECT {
	if x == nil {
		return nil
	}
	return x.ref2f5f712
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsIdObject) Free() {
	if x != nil && x.allocs2f5f712 != nil {
		x.allocs2f5f712.(*cgoAllocMap).Free()
		x.ref2f5f712 = nil
	}
}

// NewTpmsIdObjectRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsIdObjectRef(ref unsafe.Pointer) *TpmsIdObject {
	if ref == nil {
		return nil
	}
	obj := new(TpmsIdObject)
	obj.ref2f5f712 = (*C.TPMS_ID_OBJECT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsIdObject) PassRef() (*C.TPMS_ID_OBJECT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2f5f712 != nil {
		return x.ref2f5f712, nil
	}
	mem2f5f712 := allocTpmsIdObjectMemory(1)
	ref2f5f712 := (*C.TPMS_ID_OBJECT)(mem2f5f712)
	allocs2f5f712 := new(cgoAllocMap)
	allocs2f5f712.Add(mem2f5f712)

	var cintegrityHMAC_allocs *cgoAllocMap
	ref2f5f712.integrityHMAC, cintegrityHMAC_allocs = x.Integrityhmac.PassValue()
	allocs2f5f712.Borrow(cintegrityHMAC_allocs)

	var cencIdentity_allocs *cgoAllocMap
	ref2f5f712.encIdentity, cencIdentity_allocs = x.Encidentity.PassValue()
	allocs2f5f712.Borrow(cencIdentity_allocs)

	x.ref2f5f712 = ref2f5f712
	x.allocs2f5f712 = allocs2f5f712
	return ref2f5f712, allocs2f5f712

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsIdObject) PassValue() (C.TPMS_ID_OBJECT, *cgoAllocMap) {
	if x.ref2f5f712 != nil {
		return *x.ref2f5f712, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsIdObject) Deref() {
	if x.ref2f5f712 == nil {
		return
	}
	x.Integrityhmac = *NewTpm2bDigestRef(unsafe.Pointer(&x.ref2f5f712.integrityHMAC))
	x.Encidentity = *NewTpm2bDigestRef(unsafe.Pointer(&x.ref2f5f712.encIdentity))
}

// allocTpm2bIdObjectMemory allocates memory for type C.TPM2B_ID_OBJECT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bIdObjectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bIdObjectValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bIdObjectValue = unsafe.Sizeof([1]C.TPM2B_ID_OBJECT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Tpm2bIdObject) Ref() *C.TPM2B_ID_OBJECT {
	if x == nil {
		return nil
	}
	return x.refd3594052
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Tpm2bIdObject) Free() {
	if x != nil && x.allocsd3594052 != nil {
		x.allocsd3594052.(*cgoAllocMap).Free()
		x.refd3594052 = nil
	}
}

// NewTpm2bIdObjectRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpm2bIdObjectRef(ref unsafe.Pointer) *Tpm2bIdObject {
	if ref == nil {
		return nil
	}
	obj := new(Tpm2bIdObject)
	obj.refd3594052 = (*C.TPM2B_ID_OBJECT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Tpm2bIdObject) PassRef() (*C.TPM2B_ID_OBJECT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd3594052 != nil {
		return x.refd3594052, nil
	}
	memd3594052 := allocTpm2bIdObjectMemory(1)
	refd3594052 := (*C.TPM2B_ID_OBJECT)(memd3594052)
	allocsd3594052 := new(cgoAllocMap)
	allocsd3594052.Add(memd3594052)

	var csize_allocs *cgoAllocMap
	refd3594052.size, csize_allocs = (C.UINT16)(x.Size), cgoAllocsUnknown
	allocsd3594052.Borrow(csize_allocs)

	var ccredential_allocs *cgoAllocMap
	refd3594052.credential, ccredential_allocs = *(*[132]C.BYTE)(unsafe.Pointer(&x.Credential)), cgoAllocsUnknown
	allocsd3594052.Borrow(ccredential_allocs)

	x.refd3594052 = refd3594052
	x.allocsd3594052 = allocsd3594052
	return refd3594052, allocsd3594052

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Tpm2bIdObject) PassValue() (C.TPM2B_ID_OBJECT, *cgoAllocMap) {
	if x.refd3594052 != nil {
		return *x.refd3594052, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Tpm2bIdObject) Deref() {
	if x.refd3594052 == nil {
		return
	}
	x.Size = (Uint16)(x.refd3594052.size)
	x.Credential = *(*[132]Byte)(unsafe.Pointer(&x.refd3594052.credential))
}

// allocTpmsNvPinCounterParametersMemory allocates memory for type C.TPMS_NV_PIN_COUNTER_PARAMETERS in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsNvPinCounterParametersMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsNvPinCounterParametersValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsNvPinCounterParametersValue = unsafe.Sizeof([1]C.TPMS_NV_PIN_COUNTER_PARAMETERS{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsNvPinCounterParameters) Ref() *C.TPMS_NV_PIN_COUNTER_PARAMETERS {
	if x == nil {
		return nil
	}
	return x.refcce8e2e8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsNvPinCounterParameters) Free() {
	if x != nil && x.allocscce8e2e8 != nil {
		x.allocscce8e2e8.(*cgoAllocMap).Free()
		x.refcce8e2e8 = nil
	}
}

// NewTpmsNvPinCounterParametersRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsNvPinCounterParametersRef(ref unsafe.Pointer) *TpmsNvPinCounterParameters {
	if ref == nil {
		return nil
	}
	obj := new(TpmsNvPinCounterParameters)
	obj.refcce8e2e8 = (*C.TPMS_NV_PIN_COUNTER_PARAMETERS)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsNvPinCounterParameters) PassRef() (*C.TPMS_NV_PIN_COUNTER_PARAMETERS, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcce8e2e8 != nil {
		return x.refcce8e2e8, nil
	}
	memcce8e2e8 := allocTpmsNvPinCounterParametersMemory(1)
	refcce8e2e8 := (*C.TPMS_NV_PIN_COUNTER_PARAMETERS)(memcce8e2e8)
	allocscce8e2e8 := new(cgoAllocMap)
	allocscce8e2e8.Add(memcce8e2e8)

	var cpinCount_allocs *cgoAllocMap
	refcce8e2e8.pinCount, cpinCount_allocs = (C.UINT32)(x.Pincount), cgoAllocsUnknown
	allocscce8e2e8.Borrow(cpinCount_allocs)

	var cpinLimit_allocs *cgoAllocMap
	refcce8e2e8.pinLimit, cpinLimit_allocs = (C.UINT32)(x.Pinlimit), cgoAllocsUnknown
	allocscce8e2e8.Borrow(cpinLimit_allocs)

	x.refcce8e2e8 = refcce8e2e8
	x.allocscce8e2e8 = allocscce8e2e8
	return refcce8e2e8, allocscce8e2e8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsNvPinCounterParameters) PassValue() (C.TPMS_NV_PIN_COUNTER_PARAMETERS, *cgoAllocMap) {
	if x.refcce8e2e8 != nil {
		return *x.refcce8e2e8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsNvPinCounterParameters) Deref() {
	if x.refcce8e2e8 == nil {
		return
	}
	x.Pincount = (Uint32)(x.refcce8e2e8.pinCount)
	x.Pinlimit = (Uint32)(x.refcce8e2e8.pinLimit)
}

// allocTpmsNvPublicMemory allocates memory for type C.TPMS_NV_PUBLIC in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsNvPublicMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsNvPublicValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsNvPublicValue = unsafe.Sizeof([1]C.TPMS_NV_PUBLIC{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsNvPublic) Ref() *C.TPMS_NV_PUBLIC {
	if x == nil {
		return nil
	}
	return x.refcb13297c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsNvPublic) Free() {
	if x != nil && x.allocscb13297c != nil {
		x.allocscb13297c.(*cgoAllocMap).Free()
		x.refcb13297c = nil
	}
}

// NewTpmsNvPublicRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsNvPublicRef(ref unsafe.Pointer) *TpmsNvPublic {
	if ref == nil {
		return nil
	}
	obj := new(TpmsNvPublic)
	obj.refcb13297c = (*C.TPMS_NV_PUBLIC)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsNvPublic) PassRef() (*C.TPMS_NV_PUBLIC, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcb13297c != nil {
		return x.refcb13297c, nil
	}
	memcb13297c := allocTpmsNvPublicMemory(1)
	refcb13297c := (*C.TPMS_NV_PUBLIC)(memcb13297c)
	allocscb13297c := new(cgoAllocMap)
	allocscb13297c.Add(memcb13297c)

	var cnvIndex_allocs *cgoAllocMap
	refcb13297c.nvIndex, cnvIndex_allocs = (C.TPMI_RH_NV_INDEX)(x.Nvindex), cgoAllocsUnknown
	allocscb13297c.Borrow(cnvIndex_allocs)

	var cnameAlg_allocs *cgoAllocMap
	refcb13297c.nameAlg, cnameAlg_allocs = (C.TPMI_ALG_HASH)(x.Namealg), cgoAllocsUnknown
	allocscb13297c.Borrow(cnameAlg_allocs)

	var cattributes_allocs *cgoAllocMap
	refcb13297c.attributes, cattributes_allocs = (C.TPMA_NV)(x.Attributes), cgoAllocsUnknown
	allocscb13297c.Borrow(cattributes_allocs)

	var cauthPolicy_allocs *cgoAllocMap
	refcb13297c.authPolicy, cauthPolicy_allocs = x.Authpolicy.PassValue()
	allocscb13297c.Borrow(cauthPolicy_allocs)

	var cdataSize_allocs *cgoAllocMap
	refcb13297c.dataSize, cdataSize_allocs = (C.UINT16)(x.Datasize), cgoAllocsUnknown
	allocscb13297c.Borrow(cdataSize_allocs)

	x.refcb13297c = refcb13297c
	x.allocscb13297c = allocscb13297c
	return refcb13297c, allocscb13297c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsNvPublic) PassValue() (C.TPMS_NV_PUBLIC, *cgoAllocMap) {
	if x.refcb13297c != nil {
		return *x.refcb13297c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsNvPublic) Deref() {
	if x.refcb13297c == nil {
		return
	}
	x.Nvindex = (TpmiRhNvIndex)(x.refcb13297c.nvIndex)
	x.Namealg = (TpmiAlgHash)(x.refcb13297c.nameAlg)
	x.Attributes = (TpmaNv)(x.refcb13297c.attributes)
	x.Authpolicy = *NewTpm2bDigestRef(unsafe.Pointer(&x.refcb13297c.authPolicy))
	x.Datasize = (Uint16)(x.refcb13297c.dataSize)
}

// allocTpm2bNvPublicMemory allocates memory for type C.TPM2B_NV_PUBLIC in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bNvPublicMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bNvPublicValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bNvPublicValue = unsafe.Sizeof([1]C.TPM2B_NV_PUBLIC{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Tpm2bNvPublic) Ref() *C.TPM2B_NV_PUBLIC {
	if x == nil {
		return nil
	}
	return x.ref1abf9e3c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Tpm2bNvPublic) Free() {
	if x != nil && x.allocs1abf9e3c != nil {
		x.allocs1abf9e3c.(*cgoAllocMap).Free()
		x.ref1abf9e3c = nil
	}
}

// NewTpm2bNvPublicRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpm2bNvPublicRef(ref unsafe.Pointer) *Tpm2bNvPublic {
	if ref == nil {
		return nil
	}
	obj := new(Tpm2bNvPublic)
	obj.ref1abf9e3c = (*C.TPM2B_NV_PUBLIC)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Tpm2bNvPublic) PassRef() (*C.TPM2B_NV_PUBLIC, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1abf9e3c != nil {
		return x.ref1abf9e3c, nil
	}
	mem1abf9e3c := allocTpm2bNvPublicMemory(1)
	ref1abf9e3c := (*C.TPM2B_NV_PUBLIC)(mem1abf9e3c)
	allocs1abf9e3c := new(cgoAllocMap)
	allocs1abf9e3c.Add(mem1abf9e3c)

	var csize_allocs *cgoAllocMap
	ref1abf9e3c.size, csize_allocs = (C.UINT16)(x.Size), cgoAllocsUnknown
	allocs1abf9e3c.Borrow(csize_allocs)

	var cnvPublic_allocs *cgoAllocMap
	ref1abf9e3c.nvPublic, cnvPublic_allocs = x.Nvpublic.PassValue()
	allocs1abf9e3c.Borrow(cnvPublic_allocs)

	x.ref1abf9e3c = ref1abf9e3c
	x.allocs1abf9e3c = allocs1abf9e3c
	return ref1abf9e3c, allocs1abf9e3c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Tpm2bNvPublic) PassValue() (C.TPM2B_NV_PUBLIC, *cgoAllocMap) {
	if x.ref1abf9e3c != nil {
		return *x.ref1abf9e3c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Tpm2bNvPublic) Deref() {
	if x.ref1abf9e3c == nil {
		return
	}
	x.Size = (Uint16)(x.ref1abf9e3c.size)
	x.Nvpublic = *NewTpmsNvPublicRef(unsafe.Pointer(&x.ref1abf9e3c.nvPublic))
}

// allocTpm2bContextSensitiveMemory allocates memory for type C.TPM2B_CONTEXT_SENSITIVE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bContextSensitiveMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bContextSensitiveValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bContextSensitiveValue = unsafe.Sizeof([1]C.TPM2B_CONTEXT_SENSITIVE{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Tpm2bContextSensitive) Ref() *C.TPM2B_CONTEXT_SENSITIVE {
	if x == nil {
		return nil
	}
	return x.refbf0234fb
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Tpm2bContextSensitive) Free() {
	if x != nil && x.allocsbf0234fb != nil {
		x.allocsbf0234fb.(*cgoAllocMap).Free()
		x.refbf0234fb = nil
	}
}

// NewTpm2bContextSensitiveRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpm2bContextSensitiveRef(ref unsafe.Pointer) *Tpm2bContextSensitive {
	if ref == nil {
		return nil
	}
	obj := new(Tpm2bContextSensitive)
	obj.refbf0234fb = (*C.TPM2B_CONTEXT_SENSITIVE)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Tpm2bContextSensitive) PassRef() (*C.TPM2B_CONTEXT_SENSITIVE, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbf0234fb != nil {
		return x.refbf0234fb, nil
	}
	membf0234fb := allocTpm2bContextSensitiveMemory(1)
	refbf0234fb := (*C.TPM2B_CONTEXT_SENSITIVE)(membf0234fb)
	allocsbf0234fb := new(cgoAllocMap)
	allocsbf0234fb.Add(membf0234fb)

	var csize_allocs *cgoAllocMap
	refbf0234fb.size, csize_allocs = (C.UINT16)(x.Size), cgoAllocsUnknown
	allocsbf0234fb.Borrow(csize_allocs)

	var cbuffer_allocs *cgoAllocMap
	refbf0234fb.buffer, cbuffer_allocs = *(*[5120]C.BYTE)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocsbf0234fb.Borrow(cbuffer_allocs)

	x.refbf0234fb = refbf0234fb
	x.allocsbf0234fb = allocsbf0234fb
	return refbf0234fb, allocsbf0234fb

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Tpm2bContextSensitive) PassValue() (C.TPM2B_CONTEXT_SENSITIVE, *cgoAllocMap) {
	if x.refbf0234fb != nil {
		return *x.refbf0234fb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Tpm2bContextSensitive) Deref() {
	if x.refbf0234fb == nil {
		return
	}
	x.Size = (Uint16)(x.refbf0234fb.size)
	x.Buffer = *(*[5120]Byte)(unsafe.Pointer(&x.refbf0234fb.buffer))
}

// allocTpmsContextDataMemory allocates memory for type C.TPMS_CONTEXT_DATA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsContextDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsContextDataValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsContextDataValue = unsafe.Sizeof([1]C.TPMS_CONTEXT_DATA{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsContextData) Ref() *C.TPMS_CONTEXT_DATA {
	if x == nil {
		return nil
	}
	return x.ref3075f0c5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsContextData) Free() {
	if x != nil && x.allocs3075f0c5 != nil {
		x.allocs3075f0c5.(*cgoAllocMap).Free()
		x.ref3075f0c5 = nil
	}
}

// NewTpmsContextDataRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsContextDataRef(ref unsafe.Pointer) *TpmsContextData {
	if ref == nil {
		return nil
	}
	obj := new(TpmsContextData)
	obj.ref3075f0c5 = (*C.TPMS_CONTEXT_DATA)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsContextData) PassRef() (*C.TPMS_CONTEXT_DATA, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3075f0c5 != nil {
		return x.ref3075f0c5, nil
	}
	mem3075f0c5 := allocTpmsContextDataMemory(1)
	ref3075f0c5 := (*C.TPMS_CONTEXT_DATA)(mem3075f0c5)
	allocs3075f0c5 := new(cgoAllocMap)
	allocs3075f0c5.Add(mem3075f0c5)

	var cintegrity_allocs *cgoAllocMap
	ref3075f0c5.integrity, cintegrity_allocs = x.Integrity.PassValue()
	allocs3075f0c5.Borrow(cintegrity_allocs)

	var cencrypted_allocs *cgoAllocMap
	ref3075f0c5.encrypted, cencrypted_allocs = x.Encrypted.PassValue()
	allocs3075f0c5.Borrow(cencrypted_allocs)

	x.ref3075f0c5 = ref3075f0c5
	x.allocs3075f0c5 = allocs3075f0c5
	return ref3075f0c5, allocs3075f0c5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsContextData) PassValue() (C.TPMS_CONTEXT_DATA, *cgoAllocMap) {
	if x.ref3075f0c5 != nil {
		return *x.ref3075f0c5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsContextData) Deref() {
	if x.ref3075f0c5 == nil {
		return
	}
	x.Integrity = *NewTpm2bDigestRef(unsafe.Pointer(&x.ref3075f0c5.integrity))
	x.Encrypted = *NewTpm2bContextSensitiveRef(unsafe.Pointer(&x.ref3075f0c5.encrypted))
}

// allocTpm2bContextDataMemory allocates memory for type C.TPM2B_CONTEXT_DATA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bContextDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bContextDataValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bContextDataValue = unsafe.Sizeof([1]C.TPM2B_CONTEXT_DATA{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Tpm2bContextData) Ref() *C.TPM2B_CONTEXT_DATA {
	if x == nil {
		return nil
	}
	return x.ref340baa68
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Tpm2bContextData) Free() {
	if x != nil && x.allocs340baa68 != nil {
		x.allocs340baa68.(*cgoAllocMap).Free()
		x.ref340baa68 = nil
	}
}

// NewTpm2bContextDataRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpm2bContextDataRef(ref unsafe.Pointer) *Tpm2bContextData {
	if ref == nil {
		return nil
	}
	obj := new(Tpm2bContextData)
	obj.ref340baa68 = (*C.TPM2B_CONTEXT_DATA)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Tpm2bContextData) PassRef() (*C.TPM2B_CONTEXT_DATA, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref340baa68 != nil {
		return x.ref340baa68, nil
	}
	mem340baa68 := allocTpm2bContextDataMemory(1)
	ref340baa68 := (*C.TPM2B_CONTEXT_DATA)(mem340baa68)
	allocs340baa68 := new(cgoAllocMap)
	allocs340baa68.Add(mem340baa68)

	var csize_allocs *cgoAllocMap
	ref340baa68.size, csize_allocs = (C.UINT16)(x.Size), cgoAllocsUnknown
	allocs340baa68.Borrow(csize_allocs)

	var cbuffer_allocs *cgoAllocMap
	ref340baa68.buffer, cbuffer_allocs = *(*[5188]C.BYTE)(unsafe.Pointer(&x.Buffer)), cgoAllocsUnknown
	allocs340baa68.Borrow(cbuffer_allocs)

	x.ref340baa68 = ref340baa68
	x.allocs340baa68 = allocs340baa68
	return ref340baa68, allocs340baa68

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Tpm2bContextData) PassValue() (C.TPM2B_CONTEXT_DATA, *cgoAllocMap) {
	if x.ref340baa68 != nil {
		return *x.ref340baa68, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Tpm2bContextData) Deref() {
	if x.ref340baa68 == nil {
		return
	}
	x.Size = (Uint16)(x.ref340baa68.size)
	x.Buffer = *(*[5188]Byte)(unsafe.Pointer(&x.ref340baa68.buffer))
}

// allocTpmsContextMemory allocates memory for type C.TPMS_CONTEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsContextValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsContextValue = unsafe.Sizeof([1]C.TPMS_CONTEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsContext) Ref() *C.TPMS_CONTEXT {
	if x == nil {
		return nil
	}
	return x.refd0ffceeb
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsContext) Free() {
	if x != nil && x.allocsd0ffceeb != nil {
		x.allocsd0ffceeb.(*cgoAllocMap).Free()
		x.refd0ffceeb = nil
	}
}

// NewTpmsContextRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsContextRef(ref unsafe.Pointer) *TpmsContext {
	if ref == nil {
		return nil
	}
	obj := new(TpmsContext)
	obj.refd0ffceeb = (*C.TPMS_CONTEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsContext) PassRef() (*C.TPMS_CONTEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd0ffceeb != nil {
		return x.refd0ffceeb, nil
	}
	memd0ffceeb := allocTpmsContextMemory(1)
	refd0ffceeb := (*C.TPMS_CONTEXT)(memd0ffceeb)
	allocsd0ffceeb := new(cgoAllocMap)
	allocsd0ffceeb.Add(memd0ffceeb)

	var csequence_allocs *cgoAllocMap
	refd0ffceeb.sequence, csequence_allocs = (C.UINT64)(x.Sequence), cgoAllocsUnknown
	allocsd0ffceeb.Borrow(csequence_allocs)

	var csavedHandle_allocs *cgoAllocMap
	refd0ffceeb.savedHandle, csavedHandle_allocs = (C.TPMI_DH_CONTEXT)(x.Savedhandle), cgoAllocsUnknown
	allocsd0ffceeb.Borrow(csavedHandle_allocs)

	var chierarchy_allocs *cgoAllocMap
	refd0ffceeb.hierarchy, chierarchy_allocs = (C.TPMI_RH_HIERARCHY)(x.Hierarchy), cgoAllocsUnknown
	allocsd0ffceeb.Borrow(chierarchy_allocs)

	var ccontextBlob_allocs *cgoAllocMap
	refd0ffceeb.contextBlob, ccontextBlob_allocs = x.Contextblob.PassValue()
	allocsd0ffceeb.Borrow(ccontextBlob_allocs)

	x.refd0ffceeb = refd0ffceeb
	x.allocsd0ffceeb = allocsd0ffceeb
	return refd0ffceeb, allocsd0ffceeb

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsContext) PassValue() (C.TPMS_CONTEXT, *cgoAllocMap) {
	if x.refd0ffceeb != nil {
		return *x.refd0ffceeb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsContext) Deref() {
	if x.refd0ffceeb == nil {
		return
	}
	x.Sequence = (Uint64)(x.refd0ffceeb.sequence)
	x.Savedhandle = (TpmiDhContext)(x.refd0ffceeb.savedHandle)
	x.Hierarchy = (TpmiRhHierarchy)(x.refd0ffceeb.hierarchy)
	x.Contextblob = *NewTpm2bContextDataRef(unsafe.Pointer(&x.refd0ffceeb.contextBlob))
}

// allocTpmsCreationDataMemory allocates memory for type C.TPMS_CREATION_DATA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsCreationDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsCreationDataValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsCreationDataValue = unsafe.Sizeof([1]C.TPMS_CREATION_DATA{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsCreationData) Ref() *C.TPMS_CREATION_DATA {
	if x == nil {
		return nil
	}
	return x.refe3b9531d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsCreationData) Free() {
	if x != nil && x.allocse3b9531d != nil {
		x.allocse3b9531d.(*cgoAllocMap).Free()
		x.refe3b9531d = nil
	}
}

// NewTpmsCreationDataRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsCreationDataRef(ref unsafe.Pointer) *TpmsCreationData {
	if ref == nil {
		return nil
	}
	obj := new(TpmsCreationData)
	obj.refe3b9531d = (*C.TPMS_CREATION_DATA)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsCreationData) PassRef() (*C.TPMS_CREATION_DATA, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe3b9531d != nil {
		return x.refe3b9531d, nil
	}
	meme3b9531d := allocTpmsCreationDataMemory(1)
	refe3b9531d := (*C.TPMS_CREATION_DATA)(meme3b9531d)
	allocse3b9531d := new(cgoAllocMap)
	allocse3b9531d.Add(meme3b9531d)

	var cpcrSelect_allocs *cgoAllocMap
	refe3b9531d.pcrSelect, cpcrSelect_allocs = x.Pcrselect.PassValue()
	allocse3b9531d.Borrow(cpcrSelect_allocs)

	var cpcrDigest_allocs *cgoAllocMap
	refe3b9531d.pcrDigest, cpcrDigest_allocs = x.Pcrdigest.PassValue()
	allocse3b9531d.Borrow(cpcrDigest_allocs)

	var clocality_allocs *cgoAllocMap
	refe3b9531d.locality, clocality_allocs = (C.TPMA_LOCALITY)(x.Locality), cgoAllocsUnknown
	allocse3b9531d.Borrow(clocality_allocs)

	var cparentNameAlg_allocs *cgoAllocMap
	refe3b9531d.parentNameAlg, cparentNameAlg_allocs = (C.TPM2_ALG_ID)(x.Parentnamealg), cgoAllocsUnknown
	allocse3b9531d.Borrow(cparentNameAlg_allocs)

	var cparentName_allocs *cgoAllocMap
	refe3b9531d.parentName, cparentName_allocs = x.Parentname.PassValue()
	allocse3b9531d.Borrow(cparentName_allocs)

	var cparentQualifiedName_allocs *cgoAllocMap
	refe3b9531d.parentQualifiedName, cparentQualifiedName_allocs = x.Parentqualifiedname.PassValue()
	allocse3b9531d.Borrow(cparentQualifiedName_allocs)

	var coutsideInfo_allocs *cgoAllocMap
	refe3b9531d.outsideInfo, coutsideInfo_allocs = x.Outsideinfo.PassValue()
	allocse3b9531d.Borrow(coutsideInfo_allocs)

	x.refe3b9531d = refe3b9531d
	x.allocse3b9531d = allocse3b9531d
	return refe3b9531d, allocse3b9531d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsCreationData) PassValue() (C.TPMS_CREATION_DATA, *cgoAllocMap) {
	if x.refe3b9531d != nil {
		return *x.refe3b9531d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsCreationData) Deref() {
	if x.refe3b9531d == nil {
		return
	}
	x.Pcrselect = *NewTpmlPcrSelectionRef(unsafe.Pointer(&x.refe3b9531d.pcrSelect))
	x.Pcrdigest = *NewTpm2bDigestRef(unsafe.Pointer(&x.refe3b9531d.pcrDigest))
	x.Locality = (TpmaLocality)(x.refe3b9531d.locality)
	x.Parentnamealg = (Tpm2AlgId)(x.refe3b9531d.parentNameAlg)
	x.Parentname = *NewTpm2bNameRef(unsafe.Pointer(&x.refe3b9531d.parentName))
	x.Parentqualifiedname = *NewTpm2bNameRef(unsafe.Pointer(&x.refe3b9531d.parentQualifiedName))
	x.Outsideinfo = *NewTpm2bDataRef(unsafe.Pointer(&x.refe3b9531d.outsideInfo))
}

// allocTpm2bCreationDataMemory allocates memory for type C.TPM2B_CREATION_DATA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bCreationDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bCreationDataValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bCreationDataValue = unsafe.Sizeof([1]C.TPM2B_CREATION_DATA{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Tpm2bCreationData) Ref() *C.TPM2B_CREATION_DATA {
	if x == nil {
		return nil
	}
	return x.ref4bdaf212
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Tpm2bCreationData) Free() {
	if x != nil && x.allocs4bdaf212 != nil {
		x.allocs4bdaf212.(*cgoAllocMap).Free()
		x.ref4bdaf212 = nil
	}
}

// NewTpm2bCreationDataRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpm2bCreationDataRef(ref unsafe.Pointer) *Tpm2bCreationData {
	if ref == nil {
		return nil
	}
	obj := new(Tpm2bCreationData)
	obj.ref4bdaf212 = (*C.TPM2B_CREATION_DATA)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Tpm2bCreationData) PassRef() (*C.TPM2B_CREATION_DATA, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4bdaf212 != nil {
		return x.ref4bdaf212, nil
	}
	mem4bdaf212 := allocTpm2bCreationDataMemory(1)
	ref4bdaf212 := (*C.TPM2B_CREATION_DATA)(mem4bdaf212)
	allocs4bdaf212 := new(cgoAllocMap)
	allocs4bdaf212.Add(mem4bdaf212)

	var csize_allocs *cgoAllocMap
	ref4bdaf212.size, csize_allocs = (C.UINT16)(x.Size), cgoAllocsUnknown
	allocs4bdaf212.Borrow(csize_allocs)

	var ccreationData_allocs *cgoAllocMap
	ref4bdaf212.creationData, ccreationData_allocs = x.Creationdata.PassValue()
	allocs4bdaf212.Borrow(ccreationData_allocs)

	x.ref4bdaf212 = ref4bdaf212
	x.allocs4bdaf212 = allocs4bdaf212
	return ref4bdaf212, allocs4bdaf212

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Tpm2bCreationData) PassValue() (C.TPM2B_CREATION_DATA, *cgoAllocMap) {
	if x.ref4bdaf212 != nil {
		return *x.ref4bdaf212, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Tpm2bCreationData) Deref() {
	if x.ref4bdaf212 == nil {
		return
	}
	x.Size = (Uint16)(x.ref4bdaf212.size)
	x.Creationdata = *NewTpmsCreationDataRef(unsafe.Pointer(&x.ref4bdaf212.creationData))
}

// allocTpmsAcOutputMemory allocates memory for type C.TPMS_AC_OUTPUT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmsAcOutputMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmsAcOutputValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmsAcOutputValue = unsafe.Sizeof([1]C.TPMS_AC_OUTPUT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmsAcOutput) Ref() *C.TPMS_AC_OUTPUT {
	if x == nil {
		return nil
	}
	return x.refd79be361
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmsAcOutput) Free() {
	if x != nil && x.allocsd79be361 != nil {
		x.allocsd79be361.(*cgoAllocMap).Free()
		x.refd79be361 = nil
	}
}

// NewTpmsAcOutputRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmsAcOutputRef(ref unsafe.Pointer) *TpmsAcOutput {
	if ref == nil {
		return nil
	}
	obj := new(TpmsAcOutput)
	obj.refd79be361 = (*C.TPMS_AC_OUTPUT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmsAcOutput) PassRef() (*C.TPMS_AC_OUTPUT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd79be361 != nil {
		return x.refd79be361, nil
	}
	memd79be361 := allocTpmsAcOutputMemory(1)
	refd79be361 := (*C.TPMS_AC_OUTPUT)(memd79be361)
	allocsd79be361 := new(cgoAllocMap)
	allocsd79be361.Add(memd79be361)

	var ctag_allocs *cgoAllocMap
	refd79be361.tag, ctag_allocs = (C.TPM_AT)(x.Tag), cgoAllocsUnknown
	allocsd79be361.Borrow(ctag_allocs)

	var cdata_allocs *cgoAllocMap
	refd79be361.data, cdata_allocs = (C.UINT32)(x.Data), cgoAllocsUnknown
	allocsd79be361.Borrow(cdata_allocs)

	x.refd79be361 = refd79be361
	x.allocsd79be361 = allocsd79be361
	return refd79be361, allocsd79be361

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmsAcOutput) PassValue() (C.TPMS_AC_OUTPUT, *cgoAllocMap) {
	if x.refd79be361 != nil {
		return *x.refd79be361, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmsAcOutput) Deref() {
	if x.refd79be361 == nil {
		return
	}
	x.Tag = (TpmAt)(x.refd79be361.tag)
	x.Data = (Uint32)(x.refd79be361.data)
}

// allocTpmlAcCapabilitiesMemory allocates memory for type C.TPML_AC_CAPABILITIES in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmlAcCapabilitiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmlAcCapabilitiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmlAcCapabilitiesValue = unsafe.Sizeof([1]C.TPML_AC_CAPABILITIES{})

// allocA128TpmsAcOutputMemory allocates memory for type [128]C.TPMS_AC_OUTPUT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA128TpmsAcOutputMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA128TpmsAcOutputValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfA128TpmsAcOutputValue = unsafe.Sizeof([1][128]C.TPMS_AC_OUTPUT{})

// unpackA128TpmsAcOutput transforms a sliced Go data structure into plain C format.
func unpackA128TpmsAcOutput(x [128]TpmsAcOutput) (unpacked [128]C.TPMS_AC_OUTPUT, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := allocA128TpmsAcOutputMemory(1)
	allocs.Add(mem0)
	v0 := (*[128]C.TPMS_AC_OUTPUT)(mem0)
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	unpacked = *(*[128]C.TPMS_AC_OUTPUT)(mem0)
	return
}

// packA128TpmsAcOutput reads sliced Go data structure out from plain C format.
func packA128TpmsAcOutput(v *[128]TpmsAcOutput, ptr0 *[128]C.TPMS_AC_OUTPUT) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewTpmsAcOutputRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TpmlAcCapabilities) Ref() *C.TPML_AC_CAPABILITIES {
	if x == nil {
		return nil
	}
	return x.ref9e7983cc
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TpmlAcCapabilities) Free() {
	if x != nil && x.allocs9e7983cc != nil {
		x.allocs9e7983cc.(*cgoAllocMap).Free()
		x.ref9e7983cc = nil
	}
}

// NewTpmlAcCapabilitiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTpmlAcCapabilitiesRef(ref unsafe.Pointer) *TpmlAcCapabilities {
	if ref == nil {
		return nil
	}
	obj := new(TpmlAcCapabilities)
	obj.ref9e7983cc = (*C.TPML_AC_CAPABILITIES)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TpmlAcCapabilities) PassRef() (*C.TPML_AC_CAPABILITIES, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9e7983cc != nil {
		return x.ref9e7983cc, nil
	}
	mem9e7983cc := allocTpmlAcCapabilitiesMemory(1)
	ref9e7983cc := (*C.TPML_AC_CAPABILITIES)(mem9e7983cc)
	allocs9e7983cc := new(cgoAllocMap)
	allocs9e7983cc.Add(mem9e7983cc)

	var ccount_allocs *cgoAllocMap
	ref9e7983cc.count, ccount_allocs = (C.UINT32)(x.Count), cgoAllocsUnknown
	allocs9e7983cc.Borrow(ccount_allocs)

	var cacCapabilities_allocs *cgoAllocMap
	ref9e7983cc.acCapabilities, cacCapabilities_allocs = unpackA128TpmsAcOutput(x.Accapabilities)
	allocs9e7983cc.Borrow(cacCapabilities_allocs)

	x.ref9e7983cc = ref9e7983cc
	x.allocs9e7983cc = allocs9e7983cc
	return ref9e7983cc, allocs9e7983cc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TpmlAcCapabilities) PassValue() (C.TPML_AC_CAPABILITIES, *cgoAllocMap) {
	if x.ref9e7983cc != nil {
		return *x.ref9e7983cc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TpmlAcCapabilities) Deref() {
	if x.ref9e7983cc == nil {
		return
	}
	x.Count = (Uint32)(x.ref9e7983cc.count)
	packA128TpmsAcOutput(&x.Accapabilities, (*[128]C.TPMS_AC_OUTPUT)(unsafe.Pointer(&x.ref9e7983cc.acCapabilities)))
}

// Ref returns a reference to C object as it is.
func (x *Tss2SysContext) Ref() *C.TSS2_SYS_CONTEXT {
	if x == nil {
		return nil
	}
	return (*C.TSS2_SYS_CONTEXT)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tss2SysContext) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTss2SysContextRef converts the C object reference into a raw struct reference without wrapping.
func NewTss2SysContextRef(ref unsafe.Pointer) *Tss2SysContext {
	return (*Tss2SysContext)(ref)
}

// NewTss2SysContext allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTss2SysContext() *Tss2SysContext {
	return (*Tss2SysContext)(allocTss2SysContextMemory(1))
}

// allocTss2SysContextMemory allocates memory for type C.TSS2_SYS_CONTEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTss2SysContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTss2SysContextValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTss2SysContextValue = unsafe.Sizeof([1]C.TSS2_SYS_CONTEXT{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tss2SysContext) PassRef() *C.TSS2_SYS_CONTEXT {
	if x == nil {
		x = (*Tss2SysContext)(allocTss2SysContextMemory(1))
	}
	return (*C.TSS2_SYS_CONTEXT)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tss2lSysAuthCommand) Ref() *C.TSS2L_SYS_AUTH_COMMAND {
	if x == nil {
		return nil
	}
	return (*C.TSS2L_SYS_AUTH_COMMAND)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tss2lSysAuthCommand) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTss2lSysAuthCommandRef converts the C object reference into a raw struct reference without wrapping.
func NewTss2lSysAuthCommandRef(ref unsafe.Pointer) *Tss2lSysAuthCommand {
	return (*Tss2lSysAuthCommand)(ref)
}

// NewTss2lSysAuthCommand allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTss2lSysAuthCommand() *Tss2lSysAuthCommand {
	return (*Tss2lSysAuthCommand)(allocTss2lSysAuthCommandMemory(1))
}

// allocTss2lSysAuthCommandMemory allocates memory for type C.TSS2L_SYS_AUTH_COMMAND in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTss2lSysAuthCommandMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTss2lSysAuthCommandValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTss2lSysAuthCommandValue = unsafe.Sizeof([1]C.TSS2L_SYS_AUTH_COMMAND{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tss2lSysAuthCommand) PassRef() *C.TSS2L_SYS_AUTH_COMMAND {
	if x == nil {
		x = (*Tss2lSysAuthCommand)(allocTss2lSysAuthCommandMemory(1))
	}
	return (*C.TSS2L_SYS_AUTH_COMMAND)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Tss2lSysAuthResponse) Ref() *C.TSS2L_SYS_AUTH_RESPONSE {
	if x == nil {
		return nil
	}
	return (*C.TSS2L_SYS_AUTH_RESPONSE)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Tss2lSysAuthResponse) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTss2lSysAuthResponseRef converts the C object reference into a raw struct reference without wrapping.
func NewTss2lSysAuthResponseRef(ref unsafe.Pointer) *Tss2lSysAuthResponse {
	return (*Tss2lSysAuthResponse)(ref)
}

// NewTss2lSysAuthResponse allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTss2lSysAuthResponse() *Tss2lSysAuthResponse {
	return (*Tss2lSysAuthResponse)(allocTss2lSysAuthResponseMemory(1))
}

// allocTss2lSysAuthResponseMemory allocates memory for type C.TSS2L_SYS_AUTH_RESPONSE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTss2lSysAuthResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTss2lSysAuthResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTss2lSysAuthResponseValue = unsafe.Sizeof([1]C.TSS2L_SYS_AUTH_RESPONSE{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Tss2lSysAuthResponse) PassRef() *C.TSS2L_SYS_AUTH_RESPONSE {
	if x == nil {
		x = (*Tss2lSysAuthResponse)(allocTss2lSysAuthResponseMemory(1))
	}
	return (*C.TSS2L_SYS_AUTH_RESPONSE)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *DivT) Ref() *C.div_t {
	if x == nil {
		return nil
	}
	return (*C.div_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *DivT) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewDivTRef converts the C object reference into a raw struct reference without wrapping.
func NewDivTRef(ref unsafe.Pointer) *DivT {
	return (*DivT)(ref)
}

// NewDivT allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewDivT() *DivT {
	return (*DivT)(allocDivTMemory(1))
}

// allocDivTMemory allocates memory for type C.div_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDivTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDivTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDivTValue = unsafe.Sizeof([1]C.div_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *DivT) PassRef() *C.div_t {
	if x == nil {
		x = (*DivT)(allocDivTMemory(1))
	}
	return (*C.div_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *LdivT) Ref() *C.ldiv_t {
	if x == nil {
		return nil
	}
	return (*C.ldiv_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *LdivT) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewLdivTRef converts the C object reference into a raw struct reference without wrapping.
func NewLdivTRef(ref unsafe.Pointer) *LdivT {
	return (*LdivT)(ref)
}

// NewLdivT allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewLdivT() *LdivT {
	return (*LdivT)(allocLdivTMemory(1))
}

// allocLdivTMemory allocates memory for type C.ldiv_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocLdivTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfLdivTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfLdivTValue = unsafe.Sizeof([1]C.ldiv_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *LdivT) PassRef() *C.ldiv_t {
	if x == nil {
		x = (*LdivT)(allocLdivTMemory(1))
	}
	return (*C.ldiv_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *LldivT) Ref() *C.lldiv_t {
	if x == nil {
		return nil
	}
	return (*C.lldiv_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *LldivT) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewLldivTRef converts the C object reference into a raw struct reference without wrapping.
func NewLldivTRef(ref unsafe.Pointer) *LldivT {
	return (*LldivT)(ref)
}

// NewLldivT allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewLldivT() *LldivT {
	return (*LldivT)(allocLldivTMemory(1))
}

// allocLldivTMemory allocates memory for type C.lldiv_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocLldivTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfLldivTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfLldivTValue = unsafe.Sizeof([1]C.lldiv_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *LldivT) PassRef() *C.lldiv_t {
	if x == nil {
		x = (*LldivT)(allocLldivTMemory(1))
	}
	return (*C.lldiv_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FsidT) Ref() *C.__fsid_t {
	if x == nil {
		return nil
	}
	return (*C.__fsid_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FsidT) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFsidTRef converts the C object reference into a raw struct reference without wrapping.
func NewFsidTRef(ref unsafe.Pointer) *FsidT {
	return (*FsidT)(ref)
}

// NewFsidT allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFsidT() *FsidT {
	return (*FsidT)(alloc_FsidTMemory(1))
}

// alloc_FsidTMemory allocates memory for type C.__fsid_t in C.
// The caller is responsible for freeing the this memory via C.free.
func alloc_FsidTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOf_FsidTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOf_FsidTValue = unsafe.Sizeof([1]C.__fsid_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FsidT) PassRef() *C.__fsid_t {
	if x == nil {
		x = (*FsidT)(alloc_FsidTMemory(1))
	}
	return (*C.__fsid_t)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FdSet) Ref() *C.fd_set {
	if x == nil {
		return nil
	}
	return (*C.fd_set)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FdSet) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFdSetRef converts the C object reference into a raw struct reference without wrapping.
func NewFdSetRef(ref unsafe.Pointer) *FdSet {
	return (*FdSet)(ref)
}

// NewFdSet allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFdSet() *FdSet {
	return (*FdSet)(allocFdSetMemory(1))
}

// allocFdSetMemory allocates memory for type C.fd_set in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFdSetMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFdSetValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFdSetValue = unsafe.Sizeof([1]C.fd_set{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FdSet) PassRef() *C.fd_set {
	if x == nil {
		x = (*FdSet)(allocFdSetMemory(1))
	}
	return (*C.fd_set)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *SigsetT) Ref() *C.__sigset_t {
	if x == nil {
		return nil
	}
	return (*C.__sigset_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *SigsetT) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewSigsetTRef converts the C object reference into a raw struct reference without wrapping.
func NewSigsetTRef(ref unsafe.Pointer) *SigsetT {
	return (*SigsetT)(ref)
}

// NewSigsetT allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewSigsetT() *SigsetT {
	return (*SigsetT)(alloc_SigsetTMemory(1))
}

// alloc_SigsetTMemory allocates memory for type C.__sigset_t in C.
// The caller is responsible for freeing the this memory via C.free.
func alloc_SigsetTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOf_SigsetTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOf_SigsetTValue = unsafe.Sizeof([1]C.__sigset_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *SigsetT) PassRef() *C.__sigset_t {
	if x == nil {
		x = (*SigsetT)(alloc_SigsetTMemory(1))
	}
	return (*C.__sigset_t)(unsafe.Pointer(x))
}

// copyPCharBytes copies the data from Go slice as *C.char.
func copyPCharBytes(slice *sliceHeader) (*C.char, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfCharValue) * slice.Len,
		Cap:  int(sizeOfCharValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.char)(mem0), allocs
}

// allocCharMemory allocates memory for type C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCharValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCharValue = unsafe.Sizeof([1]C.char{})

func (x Tss2RcHandler) PassRef() (ref *C.TSS2_RC_HANDLER, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2RcHandlerC80E0A42Func == nil {
		tss2RcHandlerC80E0A42Func = x
	}
	return (*C.TSS2_RC_HANDLER)(C.TSS2_RC_HANDLER_c80e0a42), nil
}

func (x Tss2RcHandler) PassValue() (ref C.TSS2_RC_HANDLER, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if tss2RcHandlerC80E0A42Func == nil {
		tss2RcHandlerC80E0A42Func = x
	}
	return (C.TSS2_RC_HANDLER)(C.TSS2_RC_HANDLER_c80e0a42), nil
}

func NewTss2RcHandlerRef(ref unsafe.Pointer) *Tss2RcHandler {
	return (*Tss2RcHandler)(ref)
}

//export tss2RcHandlerC80E0A42
func tss2RcHandlerC80E0A42(crc C.TSS2_RC) *C.char {
	if tss2RcHandlerC80E0A42Func != nil {
		rcc80e0a42 := (Tss2Rc)(crc)
		retc80e0a42 := tss2RcHandlerC80E0A42Func(rcc80e0a42)
		ret, _ := copyPCharBytes((*sliceHeader)(unsafe.Pointer(&retc80e0a42)))
		return ret
	}
	panic("callback func has not been set (race?)")
}

var tss2RcHandlerC80E0A42Func Tss2RcHandler

// Ref returns a reference to C object as it is.
func (x *ImaxdivT) Ref() *C.imaxdiv_t {
	if x == nil {
		return nil
	}
	return (*C.imaxdiv_t)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *ImaxdivT) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewImaxdivTRef converts the C object reference into a raw struct reference without wrapping.
func NewImaxdivTRef(ref unsafe.Pointer) *ImaxdivT {
	return (*ImaxdivT)(ref)
}

// NewImaxdivT allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewImaxdivT() *ImaxdivT {
	return (*ImaxdivT)(allocImaxdivTMemory(1))
}

// allocImaxdivTMemory allocates memory for type C.imaxdiv_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImaxdivTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImaxdivTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfImaxdivTValue = unsafe.Sizeof([1]C.imaxdiv_t{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *ImaxdivT) PassRef() *C.imaxdiv_t {
	if x == nil {
		x = (*ImaxdivT)(allocImaxdivTMemory(1))
	}
	return (*C.imaxdiv_t)(unsafe.Pointer(x))
}

// allocPTss2TctiContextMemory allocates memory for type *C.TSS2_TCTI_CONTEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTss2TctiContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTss2TctiContextValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTss2TctiContextValue = unsafe.Sizeof([1]*C.TSS2_TCTI_CONTEXT{})

// unpackArgSSTss2TctiContext transforms a sliced Go data structure into plain C format.
func unpackArgSSTss2TctiContext(x [][]Tss2TctiContext) (unpacked **C.TSS2_TCTI_CONTEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTss2TctiContextMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TSS2_TCTI_CONTEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.TSS2_TCTI_CONTEXT)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TSS2_TCTI_CONTEXT)(h.Data)
	return
}

// packSSTss2TctiContext reads sliced Go data structure out from plain C format.
func packSSTss2TctiContext(v [][]Tss2TctiContext, ptr0 **C.TSS2_TCTI_CONTEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TSS2_TCTI_CONTEXT)(unsafe.Pointer(ptr0)))[i0]
		hxf0d18b7 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf0d18b7.Data = unsafe.Pointer(ptr1)
		hxf0d18b7.Cap = 0x7fffffff
		// hxf0d18b7.Len = ?
	}
}

// copyPTss2TctiPollHandleBytes copies the data from Go slice as *C.TSS2_TCTI_POLL_HANDLE.
func copyPTss2TctiPollHandleBytes(slice *sliceHeader) (*C.TSS2_TCTI_POLL_HANDLE, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTss2TctiPollHandleValue) * slice.Len,
		Cap:  int(sizeOfTss2TctiPollHandleValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TSS2_TCTI_POLL_HANDLE)(mem0), allocs
}

// allocTss2TctiPollHandleMemory allocates memory for type C.TSS2_TCTI_POLL_HANDLE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTss2TctiPollHandleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTss2TctiPollHandleValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTss2TctiPollHandleValue = unsafe.Sizeof([1]C.TSS2_TCTI_POLL_HANDLE{})

// copyPSizeTBytes copies the data from Go slice as *C.size_t.
func copyPSizeTBytes(slice *sliceHeader) (*C.size_t, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfSizeTValue) * slice.Len,
		Cap:  int(sizeOfSizeTValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.size_t)(mem0), allocs
}

// allocSizeTMemory allocates memory for type C.size_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSizeTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSizeTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSizeTValue = unsafe.Sizeof([1]C.size_t{})

// allocPUint8TMemory allocates memory for type *C.uint8_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPUint8TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPUint8TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPUint8TValue = unsafe.Sizeof([1]*C.uint8_t{})

// unpackArgSSUint8T transforms a sliced Go data structure into plain C format.
func unpackArgSSUint8T(x [][]Uint8T) (unpacked **C.uint8_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPUint8TMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.uint8_t)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.uint8_t)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.uint8_t)(h.Data)
	return
}

// packSSUint8T reads sliced Go data structure out from plain C format.
func packSSUint8T(v [][]Uint8T, ptr0 **C.uint8_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.uint8_t)(unsafe.Pointer(ptr0)))[i0]
		hxf2fab0d := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf2fab0d.Data = unsafe.Pointer(ptr1)
		hxf2fab0d.Cap = 0x7fffffff
		// hxf2fab0d.Len = ?
	}
}

// copyPUint8TBytes copies the data from Go slice as *C.uint8_t.
func copyPUint8TBytes(slice *sliceHeader) (*C.uint8_t, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfUint8TValue) * slice.Len,
		Cap:  int(sizeOfUint8TValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.uint8_t)(mem0), allocs
}

// allocUint8TMemory allocates memory for type C.uint8_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUint8TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUint8TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUint8TValue = unsafe.Sizeof([1]C.uint8_t{})

// copyPEsysTrBytes copies the data from Go slice as *C.ESYS_TR.
func copyPEsysTrBytes(slice *sliceHeader) (*C.ESYS_TR, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfEsysTrValue) * slice.Len,
		Cap:  int(sizeOfEsysTrValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.ESYS_TR)(mem0), allocs
}

// allocEsysTrMemory allocates memory for type C.ESYS_TR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocEsysTrMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfEsysTrValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfEsysTrValue = unsafe.Sizeof([1]C.ESYS_TR{})

// allocTpm2bAuthMemory allocates memory for type C.TPM2B_AUTH in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bAuthMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bAuthValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bAuthValue = unsafe.Sizeof([1]C.TPM2B_AUTH{})

// unpackArgSTpm2bAuth transforms a sliced Go data structure into plain C format.
func unpackArgSTpm2bAuth(x []Tpm2bAuth) (unpacked *C.TPM2B_AUTH, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpm2bAuthMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPM2B_AUTH)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPM2B_AUTH)(h.Data)
	return
}

// packSTpm2bAuth reads sliced Go data structure out from plain C format.
func packSTpm2bAuth(v []Tpm2bAuth, ptr0 *C.TPM2B_AUTH) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpm2bAuthValue]C.TPM2B_AUTH)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpm2bAuthRef(unsafe.Pointer(&ptr1))
	}
}

// allocPTpm2bNameMemory allocates memory for type *C.TPM2B_NAME in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpm2bNameMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpm2bNameValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpm2bNameValue = unsafe.Sizeof([1]*C.TPM2B_NAME{})

// unpackArgSSTpm2bName transforms a sliced Go data structure into plain C format.
func unpackArgSSTpm2bName(x [][]Tpm2bName) (unpacked **C.TPM2B_NAME, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpm2bNameMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPM2B_NAME)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpm2bNameMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPM2B_NAME)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPM2B_NAME)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPM2B_NAME)(h.Data)
	return
}

// packSSTpm2bName reads sliced Go data structure out from plain C format.
func packSSTpm2bName(v [][]Tpm2bName, ptr0 **C.TPM2B_NAME) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPM2B_NAME)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfTpm2bNameValue]C.TPM2B_NAME)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewTpm2bNameRef(unsafe.Pointer(&ptr2))
		}
	}
}

// copyPTpmaSessionBytes copies the data from Go slice as *C.TPMA_SESSION.
func copyPTpmaSessionBytes(slice *sliceHeader) (*C.TPMA_SESSION, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmaSessionValue) * slice.Len,
		Cap:  int(sizeOfTpmaSessionValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMA_SESSION)(mem0), allocs
}

// allocTpmaSessionMemory allocates memory for type C.TPMA_SESSION in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmaSessionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmaSessionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmaSessionValue = unsafe.Sizeof([1]C.TPMA_SESSION{})

// allocPTpm2bNonceMemory allocates memory for type *C.TPM2B_NONCE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpm2bNonceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpm2bNonceValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpm2bNonceValue = unsafe.Sizeof([1]*C.TPM2B_NONCE{})

// allocTpm2bNonceMemory allocates memory for type C.TPM2B_NONCE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bNonceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bNonceValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bNonceValue = unsafe.Sizeof([1]C.TPM2B_NONCE{})

// unpackArgSSTpm2bNonce transforms a sliced Go data structure into plain C format.
func unpackArgSSTpm2bNonce(x [][]Tpm2bNonce) (unpacked **C.TPM2B_NONCE, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpm2bNonceMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPM2B_NONCE)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpm2bNonceMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPM2B_NONCE)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPM2B_NONCE)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPM2B_NONCE)(h.Data)
	return
}

// packSSTpm2bNonce reads sliced Go data structure out from plain C format.
func packSSTpm2bNonce(v [][]Tpm2bNonce, ptr0 **C.TPM2B_NONCE) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPM2B_NONCE)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfTpm2bNonceValue]C.TPM2B_NONCE)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewTpm2bNonceRef(unsafe.Pointer(&ptr2))
		}
	}
}

// unpackArgSTpmlAlg transforms a sliced Go data structure into plain C format.
func unpackArgSTpmlAlg(x []TpmlAlg) (unpacked *C.TPML_ALG, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmlAlgMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPML_ALG)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPML_ALG)(h.Data)
	return
}

// packSTpmlAlg reads sliced Go data structure out from plain C format.
func packSTpmlAlg(v []TpmlAlg, ptr0 *C.TPML_ALG) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmlAlgValue]C.TPML_ALG)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmlAlgRef(unsafe.Pointer(&ptr1))
	}
}

// allocPTpmlAlgMemory allocates memory for type *C.TPML_ALG in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpmlAlgMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpmlAlgValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpmlAlgValue = unsafe.Sizeof([1]*C.TPML_ALG{})

// unpackArgSSTpmlAlg transforms a sliced Go data structure into plain C format.
func unpackArgSSTpmlAlg(x [][]TpmlAlg) (unpacked **C.TPML_ALG, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpmlAlgMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPML_ALG)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpmlAlgMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPML_ALG)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPML_ALG)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPML_ALG)(h.Data)
	return
}

// packSSTpmlAlg reads sliced Go data structure out from plain C format.
func packSSTpmlAlg(v [][]TpmlAlg, ptr0 **C.TPML_ALG) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPML_ALG)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfTpmlAlgValue]C.TPML_ALG)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewTpmlAlgRef(unsafe.Pointer(&ptr2))
		}
	}
}

// allocPTpm2bMaxBufferMemory allocates memory for type *C.TPM2B_MAX_BUFFER in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpm2bMaxBufferMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpm2bMaxBufferValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpm2bMaxBufferValue = unsafe.Sizeof([1]*C.TPM2B_MAX_BUFFER{})

// unpackArgSSTpm2bMaxBuffer transforms a sliced Go data structure into plain C format.
func unpackArgSSTpm2bMaxBuffer(x [][]Tpm2bMaxBuffer) (unpacked **C.TPM2B_MAX_BUFFER, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpm2bMaxBufferMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPM2B_MAX_BUFFER)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpm2bMaxBufferMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPM2B_MAX_BUFFER)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPM2B_MAX_BUFFER)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPM2B_MAX_BUFFER)(h.Data)
	return
}

// packSSTpm2bMaxBuffer reads sliced Go data structure out from plain C format.
func packSSTpm2bMaxBuffer(v [][]Tpm2bMaxBuffer, ptr0 **C.TPM2B_MAX_BUFFER) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPM2B_MAX_BUFFER)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfTpm2bMaxBufferValue]C.TPM2B_MAX_BUFFER)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewTpm2bMaxBufferRef(unsafe.Pointer(&ptr2))
		}
	}
}

// copyPTpm2RcBytes copies the data from Go slice as *C.TPM2_RC.
func copyPTpm2RcBytes(slice *sliceHeader) (*C.TPM2_RC, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2RcValue) * slice.Len,
		Cap:  int(sizeOfTpm2RcValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2_RC)(mem0), allocs
}

// allocTpm2RcMemory allocates memory for type C.TPM2_RC in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2RcMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2RcValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2RcValue = unsafe.Sizeof([1]C.TPM2_RC{})

// unpackArgSTpm2bNonce transforms a sliced Go data structure into plain C format.
func unpackArgSTpm2bNonce(x []Tpm2bNonce) (unpacked *C.TPM2B_NONCE, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpm2bNonceMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPM2B_NONCE)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPM2B_NONCE)(h.Data)
	return
}

// packSTpm2bNonce reads sliced Go data structure out from plain C format.
func packSTpm2bNonce(v []Tpm2bNonce, ptr0 *C.TPM2B_NONCE) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpm2bNonceValue]C.TPM2B_NONCE)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpm2bNonceRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmtSymDef transforms a sliced Go data structure into plain C format.
func unpackArgSTpmtSymDef(x []TpmtSymDef) (unpacked *C.TPMT_SYM_DEF, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmtSymDefMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMT_SYM_DEF)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMT_SYM_DEF)(h.Data)
	return
}

// packSTpmtSymDef reads sliced Go data structure out from plain C format.
func packSTpmtSymDef(v []TpmtSymDef, ptr0 *C.TPMT_SYM_DEF) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmtSymDefValue]C.TPMT_SYM_DEF)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmtSymDefRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpm2bSensitiveCreate transforms a sliced Go data structure into plain C format.
func unpackArgSTpm2bSensitiveCreate(x []Tpm2bSensitiveCreate) (unpacked *C.TPM2B_SENSITIVE_CREATE, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpm2bSensitiveCreateMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPM2B_SENSITIVE_CREATE)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPM2B_SENSITIVE_CREATE)(h.Data)
	return
}

// packSTpm2bSensitiveCreate reads sliced Go data structure out from plain C format.
func packSTpm2bSensitiveCreate(v []Tpm2bSensitiveCreate, ptr0 *C.TPM2B_SENSITIVE_CREATE) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpm2bSensitiveCreateValue]C.TPM2B_SENSITIVE_CREATE)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpm2bSensitiveCreateRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpm2bPublic transforms a sliced Go data structure into plain C format.
func unpackArgSTpm2bPublic(x []Tpm2bPublic) (unpacked *C.TPM2B_PUBLIC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpm2bPublicMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPM2B_PUBLIC)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPM2B_PUBLIC)(h.Data)
	return
}

// packSTpm2bPublic reads sliced Go data structure out from plain C format.
func packSTpm2bPublic(v []Tpm2bPublic, ptr0 *C.TPM2B_PUBLIC) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpm2bPublicValue]C.TPM2B_PUBLIC)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpm2bPublicRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpm2bData transforms a sliced Go data structure into plain C format.
func unpackArgSTpm2bData(x []Tpm2bData) (unpacked *C.TPM2B_DATA, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpm2bDataMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPM2B_DATA)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPM2B_DATA)(h.Data)
	return
}

// packSTpm2bData reads sliced Go data structure out from plain C format.
func packSTpm2bData(v []Tpm2bData, ptr0 *C.TPM2B_DATA) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpm2bDataValue]C.TPM2B_DATA)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpm2bDataRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmlPcrSelection transforms a sliced Go data structure into plain C format.
func unpackArgSTpmlPcrSelection(x []TpmlPcrSelection) (unpacked *C.TPML_PCR_SELECTION, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmlPcrSelectionMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPML_PCR_SELECTION)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPML_PCR_SELECTION)(h.Data)
	return
}

// packSTpmlPcrSelection reads sliced Go data structure out from plain C format.
func packSTpmlPcrSelection(v []TpmlPcrSelection, ptr0 *C.TPML_PCR_SELECTION) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmlPcrSelectionValue]C.TPML_PCR_SELECTION)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmlPcrSelectionRef(unsafe.Pointer(&ptr1))
	}
}

// allocPTpm2bPrivateMemory allocates memory for type *C.TPM2B_PRIVATE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpm2bPrivateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpm2bPrivateValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpm2bPrivateValue = unsafe.Sizeof([1]*C.TPM2B_PRIVATE{})

// unpackArgSSTpm2bPrivate transforms a sliced Go data structure into plain C format.
func unpackArgSSTpm2bPrivate(x [][]Tpm2bPrivate) (unpacked **C.TPM2B_PRIVATE, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpm2bPrivateMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPM2B_PRIVATE)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpm2bPrivateMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPM2B_PRIVATE)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPM2B_PRIVATE)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPM2B_PRIVATE)(h.Data)
	return
}

// packSSTpm2bPrivate reads sliced Go data structure out from plain C format.
func packSSTpm2bPrivate(v [][]Tpm2bPrivate, ptr0 **C.TPM2B_PRIVATE) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPM2B_PRIVATE)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfTpm2bPrivateValue]C.TPM2B_PRIVATE)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewTpm2bPrivateRef(unsafe.Pointer(&ptr2))
		}
	}
}

// allocPTpm2bPublicMemory allocates memory for type *C.TPM2B_PUBLIC in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpm2bPublicMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpm2bPublicValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpm2bPublicValue = unsafe.Sizeof([1]*C.TPM2B_PUBLIC{})

// unpackArgSSTpm2bPublic transforms a sliced Go data structure into plain C format.
func unpackArgSSTpm2bPublic(x [][]Tpm2bPublic) (unpacked **C.TPM2B_PUBLIC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpm2bPublicMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPM2B_PUBLIC)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpm2bPublicMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPM2B_PUBLIC)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPM2B_PUBLIC)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPM2B_PUBLIC)(h.Data)
	return
}

// packSSTpm2bPublic reads sliced Go data structure out from plain C format.
func packSSTpm2bPublic(v [][]Tpm2bPublic, ptr0 **C.TPM2B_PUBLIC) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPM2B_PUBLIC)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfTpm2bPublicValue]C.TPM2B_PUBLIC)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewTpm2bPublicRef(unsafe.Pointer(&ptr2))
		}
	}
}

// allocPTpm2bCreationDataMemory allocates memory for type *C.TPM2B_CREATION_DATA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpm2bCreationDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpm2bCreationDataValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpm2bCreationDataValue = unsafe.Sizeof([1]*C.TPM2B_CREATION_DATA{})

// unpackArgSSTpm2bCreationData transforms a sliced Go data structure into plain C format.
func unpackArgSSTpm2bCreationData(x [][]Tpm2bCreationData) (unpacked **C.TPM2B_CREATION_DATA, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpm2bCreationDataMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPM2B_CREATION_DATA)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpm2bCreationDataMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPM2B_CREATION_DATA)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPM2B_CREATION_DATA)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPM2B_CREATION_DATA)(h.Data)
	return
}

// packSSTpm2bCreationData reads sliced Go data structure out from plain C format.
func packSSTpm2bCreationData(v [][]Tpm2bCreationData, ptr0 **C.TPM2B_CREATION_DATA) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPM2B_CREATION_DATA)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfTpm2bCreationDataValue]C.TPM2B_CREATION_DATA)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewTpm2bCreationDataRef(unsafe.Pointer(&ptr2))
		}
	}
}

// allocPTpm2bDigestMemory allocates memory for type *C.TPM2B_DIGEST in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpm2bDigestMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpm2bDigestValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpm2bDigestValue = unsafe.Sizeof([1]*C.TPM2B_DIGEST{})

// unpackArgSSTpm2bDigest transforms a sliced Go data structure into plain C format.
func unpackArgSSTpm2bDigest(x [][]Tpm2bDigest) (unpacked **C.TPM2B_DIGEST, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpm2bDigestMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPM2B_DIGEST)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpm2bDigestMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPM2B_DIGEST)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPM2B_DIGEST)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPM2B_DIGEST)(h.Data)
	return
}

// packSSTpm2bDigest reads sliced Go data structure out from plain C format.
func packSSTpm2bDigest(v [][]Tpm2bDigest, ptr0 **C.TPM2B_DIGEST) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPM2B_DIGEST)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfTpm2bDigestValue]C.TPM2B_DIGEST)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewTpm2bDigestRef(unsafe.Pointer(&ptr2))
		}
	}
}

// allocPTpmtTkCreationMemory allocates memory for type *C.TPMT_TK_CREATION in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpmtTkCreationMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpmtTkCreationValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpmtTkCreationValue = unsafe.Sizeof([1]*C.TPMT_TK_CREATION{})

// unpackArgSSTpmtTkCreation transforms a sliced Go data structure into plain C format.
func unpackArgSSTpmtTkCreation(x [][]TpmtTkCreation) (unpacked **C.TPMT_TK_CREATION, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpmtTkCreationMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPMT_TK_CREATION)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpmtTkCreationMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPMT_TK_CREATION)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPMT_TK_CREATION)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPMT_TK_CREATION)(h.Data)
	return
}

// packSSTpmtTkCreation reads sliced Go data structure out from plain C format.
func packSSTpmtTkCreation(v [][]TpmtTkCreation, ptr0 **C.TPMT_TK_CREATION) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPMT_TK_CREATION)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfTpmtTkCreationValue]C.TPMT_TK_CREATION)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewTpmtTkCreationRef(unsafe.Pointer(&ptr2))
		}
	}
}

// unpackArgSTpm2bPrivate transforms a sliced Go data structure into plain C format.
func unpackArgSTpm2bPrivate(x []Tpm2bPrivate) (unpacked *C.TPM2B_PRIVATE, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpm2bPrivateMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPM2B_PRIVATE)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPM2B_PRIVATE)(h.Data)
	return
}

// packSTpm2bPrivate reads sliced Go data structure out from plain C format.
func packSTpm2bPrivate(v []Tpm2bPrivate, ptr0 *C.TPM2B_PRIVATE) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpm2bPrivateValue]C.TPM2B_PRIVATE)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpm2bPrivateRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpm2bSensitive transforms a sliced Go data structure into plain C format.
func unpackArgSTpm2bSensitive(x []Tpm2bSensitive) (unpacked *C.TPM2B_SENSITIVE, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpm2bSensitiveMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPM2B_SENSITIVE)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPM2B_SENSITIVE)(h.Data)
	return
}

// packSTpm2bSensitive reads sliced Go data structure out from plain C format.
func packSTpm2bSensitive(v []Tpm2bSensitive, ptr0 *C.TPM2B_SENSITIVE) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpm2bSensitiveValue]C.TPM2B_SENSITIVE)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpm2bSensitiveRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpm2bIdObject transforms a sliced Go data structure into plain C format.
func unpackArgSTpm2bIdObject(x []Tpm2bIdObject) (unpacked *C.TPM2B_ID_OBJECT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpm2bIdObjectMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPM2B_ID_OBJECT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPM2B_ID_OBJECT)(h.Data)
	return
}

// packSTpm2bIdObject reads sliced Go data structure out from plain C format.
func packSTpm2bIdObject(v []Tpm2bIdObject, ptr0 *C.TPM2B_ID_OBJECT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpm2bIdObjectValue]C.TPM2B_ID_OBJECT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpm2bIdObjectRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpm2bEncryptedSecret transforms a sliced Go data structure into plain C format.
func unpackArgSTpm2bEncryptedSecret(x []Tpm2bEncryptedSecret) (unpacked *C.TPM2B_ENCRYPTED_SECRET, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpm2bEncryptedSecretMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPM2B_ENCRYPTED_SECRET)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPM2B_ENCRYPTED_SECRET)(h.Data)
	return
}

// packSTpm2bEncryptedSecret reads sliced Go data structure out from plain C format.
func packSTpm2bEncryptedSecret(v []Tpm2bEncryptedSecret, ptr0 *C.TPM2B_ENCRYPTED_SECRET) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpm2bEncryptedSecretValue]C.TPM2B_ENCRYPTED_SECRET)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpm2bEncryptedSecretRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpm2bDigest transforms a sliced Go data structure into plain C format.
func unpackArgSTpm2bDigest(x []Tpm2bDigest) (unpacked *C.TPM2B_DIGEST, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpm2bDigestMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPM2B_DIGEST)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPM2B_DIGEST)(h.Data)
	return
}

// packSTpm2bDigest reads sliced Go data structure out from plain C format.
func packSTpm2bDigest(v []Tpm2bDigest, ptr0 *C.TPM2B_DIGEST) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpm2bDigestValue]C.TPM2B_DIGEST)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpm2bDigestRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpm2bName transforms a sliced Go data structure into plain C format.
func unpackArgSTpm2bName(x []Tpm2bName) (unpacked *C.TPM2B_NAME, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpm2bNameMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPM2B_NAME)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPM2B_NAME)(h.Data)
	return
}

// packSTpm2bName reads sliced Go data structure out from plain C format.
func packSTpm2bName(v []Tpm2bName, ptr0 *C.TPM2B_NAME) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpm2bNameValue]C.TPM2B_NAME)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpm2bNameRef(unsafe.Pointer(&ptr1))
	}
}

// allocPTpm2bIdObjectMemory allocates memory for type *C.TPM2B_ID_OBJECT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpm2bIdObjectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpm2bIdObjectValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpm2bIdObjectValue = unsafe.Sizeof([1]*C.TPM2B_ID_OBJECT{})

// unpackArgSSTpm2bIdObject transforms a sliced Go data structure into plain C format.
func unpackArgSSTpm2bIdObject(x [][]Tpm2bIdObject) (unpacked **C.TPM2B_ID_OBJECT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpm2bIdObjectMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPM2B_ID_OBJECT)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpm2bIdObjectMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPM2B_ID_OBJECT)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPM2B_ID_OBJECT)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPM2B_ID_OBJECT)(h.Data)
	return
}

// packSSTpm2bIdObject reads sliced Go data structure out from plain C format.
func packSSTpm2bIdObject(v [][]Tpm2bIdObject, ptr0 **C.TPM2B_ID_OBJECT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPM2B_ID_OBJECT)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfTpm2bIdObjectValue]C.TPM2B_ID_OBJECT)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewTpm2bIdObjectRef(unsafe.Pointer(&ptr2))
		}
	}
}

// allocPTpm2bEncryptedSecretMemory allocates memory for type *C.TPM2B_ENCRYPTED_SECRET in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpm2bEncryptedSecretMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpm2bEncryptedSecretValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpm2bEncryptedSecretValue = unsafe.Sizeof([1]*C.TPM2B_ENCRYPTED_SECRET{})

// unpackArgSSTpm2bEncryptedSecret transforms a sliced Go data structure into plain C format.
func unpackArgSSTpm2bEncryptedSecret(x [][]Tpm2bEncryptedSecret) (unpacked **C.TPM2B_ENCRYPTED_SECRET, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpm2bEncryptedSecretMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPM2B_ENCRYPTED_SECRET)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpm2bEncryptedSecretMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPM2B_ENCRYPTED_SECRET)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPM2B_ENCRYPTED_SECRET)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPM2B_ENCRYPTED_SECRET)(h.Data)
	return
}

// packSSTpm2bEncryptedSecret reads sliced Go data structure out from plain C format.
func packSSTpm2bEncryptedSecret(v [][]Tpm2bEncryptedSecret, ptr0 **C.TPM2B_ENCRYPTED_SECRET) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPM2B_ENCRYPTED_SECRET)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfTpm2bEncryptedSecretValue]C.TPM2B_ENCRYPTED_SECRET)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewTpm2bEncryptedSecretRef(unsafe.Pointer(&ptr2))
		}
	}
}

// allocPTpm2bSensitiveDataMemory allocates memory for type *C.TPM2B_SENSITIVE_DATA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpm2bSensitiveDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpm2bSensitiveDataValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpm2bSensitiveDataValue = unsafe.Sizeof([1]*C.TPM2B_SENSITIVE_DATA{})

// unpackArgSSTpm2bSensitiveData transforms a sliced Go data structure into plain C format.
func unpackArgSSTpm2bSensitiveData(x [][]Tpm2bSensitiveData) (unpacked **C.TPM2B_SENSITIVE_DATA, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpm2bSensitiveDataMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPM2B_SENSITIVE_DATA)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpm2bSensitiveDataMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPM2B_SENSITIVE_DATA)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPM2B_SENSITIVE_DATA)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPM2B_SENSITIVE_DATA)(h.Data)
	return
}

// packSSTpm2bSensitiveData reads sliced Go data structure out from plain C format.
func packSSTpm2bSensitiveData(v [][]Tpm2bSensitiveData, ptr0 **C.TPM2B_SENSITIVE_DATA) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPM2B_SENSITIVE_DATA)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfTpm2bSensitiveDataValue]C.TPM2B_SENSITIVE_DATA)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewTpm2bSensitiveDataRef(unsafe.Pointer(&ptr2))
		}
	}
}

// unpackArgSTpm2bTemplate transforms a sliced Go data structure into plain C format.
func unpackArgSTpm2bTemplate(x []Tpm2bTemplate) (unpacked *C.TPM2B_TEMPLATE, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpm2bTemplateMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPM2B_TEMPLATE)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPM2B_TEMPLATE)(h.Data)
	return
}

// packSTpm2bTemplate reads sliced Go data structure out from plain C format.
func packSTpm2bTemplate(v []Tpm2bTemplate, ptr0 *C.TPM2B_TEMPLATE) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpm2bTemplateValue]C.TPM2B_TEMPLATE)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpm2bTemplateRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmtSymDefObject transforms a sliced Go data structure into plain C format.
func unpackArgSTpmtSymDefObject(x []TpmtSymDefObject) (unpacked *C.TPMT_SYM_DEF_OBJECT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmtSymDefObjectMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMT_SYM_DEF_OBJECT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMT_SYM_DEF_OBJECT)(h.Data)
	return
}

// packSTpmtSymDefObject reads sliced Go data structure out from plain C format.
func packSTpmtSymDefObject(v []TpmtSymDefObject, ptr0 *C.TPMT_SYM_DEF_OBJECT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmtSymDefObjectValue]C.TPMT_SYM_DEF_OBJECT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmtSymDefObjectRef(unsafe.Pointer(&ptr1))
	}
}

// allocPTpm2bDataMemory allocates memory for type *C.TPM2B_DATA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpm2bDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpm2bDataValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpm2bDataValue = unsafe.Sizeof([1]*C.TPM2B_DATA{})

// unpackArgSSTpm2bData transforms a sliced Go data structure into plain C format.
func unpackArgSSTpm2bData(x [][]Tpm2bData) (unpacked **C.TPM2B_DATA, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpm2bDataMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPM2B_DATA)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpm2bDataMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPM2B_DATA)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPM2B_DATA)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPM2B_DATA)(h.Data)
	return
}

// packSSTpm2bData reads sliced Go data structure out from plain C format.
func packSSTpm2bData(v [][]Tpm2bData, ptr0 **C.TPM2B_DATA) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPM2B_DATA)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfTpm2bDataValue]C.TPM2B_DATA)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewTpm2bDataRef(unsafe.Pointer(&ptr2))
		}
	}
}

// unpackArgSTpm2bPublicKeyRsa transforms a sliced Go data structure into plain C format.
func unpackArgSTpm2bPublicKeyRsa(x []Tpm2bPublicKeyRsa) (unpacked *C.TPM2B_PUBLIC_KEY_RSA, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpm2bPublicKeyRsaMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPM2B_PUBLIC_KEY_RSA)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPM2B_PUBLIC_KEY_RSA)(h.Data)
	return
}

// packSTpm2bPublicKeyRsa reads sliced Go data structure out from plain C format.
func packSTpm2bPublicKeyRsa(v []Tpm2bPublicKeyRsa, ptr0 *C.TPM2B_PUBLIC_KEY_RSA) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpm2bPublicKeyRsaValue]C.TPM2B_PUBLIC_KEY_RSA)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpm2bPublicKeyRsaRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmtRsaDecrypt transforms a sliced Go data structure into plain C format.
func unpackArgSTpmtRsaDecrypt(x []TpmtRsaDecrypt) (unpacked *C.TPMT_RSA_DECRYPT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmtRsaDecryptMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMT_RSA_DECRYPT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMT_RSA_DECRYPT)(h.Data)
	return
}

// packSTpmtRsaDecrypt reads sliced Go data structure out from plain C format.
func packSTpmtRsaDecrypt(v []TpmtRsaDecrypt, ptr0 *C.TPMT_RSA_DECRYPT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmtRsaDecryptValue]C.TPMT_RSA_DECRYPT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmtRsaDecryptRef(unsafe.Pointer(&ptr1))
	}
}

// allocPTpm2bPublicKeyRsaMemory allocates memory for type *C.TPM2B_PUBLIC_KEY_RSA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpm2bPublicKeyRsaMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpm2bPublicKeyRsaValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpm2bPublicKeyRsaValue = unsafe.Sizeof([1]*C.TPM2B_PUBLIC_KEY_RSA{})

// unpackArgSSTpm2bPublicKeyRsa transforms a sliced Go data structure into plain C format.
func unpackArgSSTpm2bPublicKeyRsa(x [][]Tpm2bPublicKeyRsa) (unpacked **C.TPM2B_PUBLIC_KEY_RSA, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpm2bPublicKeyRsaMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPM2B_PUBLIC_KEY_RSA)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpm2bPublicKeyRsaMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPM2B_PUBLIC_KEY_RSA)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPM2B_PUBLIC_KEY_RSA)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPM2B_PUBLIC_KEY_RSA)(h.Data)
	return
}

// packSSTpm2bPublicKeyRsa reads sliced Go data structure out from plain C format.
func packSSTpm2bPublicKeyRsa(v [][]Tpm2bPublicKeyRsa, ptr0 **C.TPM2B_PUBLIC_KEY_RSA) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPM2B_PUBLIC_KEY_RSA)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfTpm2bPublicKeyRsaValue]C.TPM2B_PUBLIC_KEY_RSA)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewTpm2bPublicKeyRsaRef(unsafe.Pointer(&ptr2))
		}
	}
}

// allocPTpm2bEccPointMemory allocates memory for type *C.TPM2B_ECC_POINT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpm2bEccPointMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpm2bEccPointValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpm2bEccPointValue = unsafe.Sizeof([1]*C.TPM2B_ECC_POINT{})

// unpackArgSSTpm2bEccPoint transforms a sliced Go data structure into plain C format.
func unpackArgSSTpm2bEccPoint(x [][]Tpm2bEccPoint) (unpacked **C.TPM2B_ECC_POINT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpm2bEccPointMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPM2B_ECC_POINT)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpm2bEccPointMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPM2B_ECC_POINT)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPM2B_ECC_POINT)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPM2B_ECC_POINT)(h.Data)
	return
}

// packSSTpm2bEccPoint reads sliced Go data structure out from plain C format.
func packSSTpm2bEccPoint(v [][]Tpm2bEccPoint, ptr0 **C.TPM2B_ECC_POINT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPM2B_ECC_POINT)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfTpm2bEccPointValue]C.TPM2B_ECC_POINT)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewTpm2bEccPointRef(unsafe.Pointer(&ptr2))
		}
	}
}

// unpackArgSTpm2bEccPoint transforms a sliced Go data structure into plain C format.
func unpackArgSTpm2bEccPoint(x []Tpm2bEccPoint) (unpacked *C.TPM2B_ECC_POINT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpm2bEccPointMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPM2B_ECC_POINT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPM2B_ECC_POINT)(h.Data)
	return
}

// packSTpm2bEccPoint reads sliced Go data structure out from plain C format.
func packSTpm2bEccPoint(v []Tpm2bEccPoint, ptr0 *C.TPM2B_ECC_POINT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpm2bEccPointValue]C.TPM2B_ECC_POINT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpm2bEccPointRef(unsafe.Pointer(&ptr1))
	}
}

// allocPTpmsAlgorithmDetailEccMemory allocates memory for type *C.TPMS_ALGORITHM_DETAIL_ECC in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpmsAlgorithmDetailEccMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpmsAlgorithmDetailEccValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpmsAlgorithmDetailEccValue = unsafe.Sizeof([1]*C.TPMS_ALGORITHM_DETAIL_ECC{})

// unpackArgSSTpmsAlgorithmDetailEcc transforms a sliced Go data structure into plain C format.
func unpackArgSSTpmsAlgorithmDetailEcc(x [][]TpmsAlgorithmDetailEcc) (unpacked **C.TPMS_ALGORITHM_DETAIL_ECC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpmsAlgorithmDetailEccMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPMS_ALGORITHM_DETAIL_ECC)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpmsAlgorithmDetailEccMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPMS_ALGORITHM_DETAIL_ECC)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPMS_ALGORITHM_DETAIL_ECC)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPMS_ALGORITHM_DETAIL_ECC)(h.Data)
	return
}

// packSSTpmsAlgorithmDetailEcc reads sliced Go data structure out from plain C format.
func packSSTpmsAlgorithmDetailEcc(v [][]TpmsAlgorithmDetailEcc, ptr0 **C.TPMS_ALGORITHM_DETAIL_ECC) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPMS_ALGORITHM_DETAIL_ECC)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfTpmsAlgorithmDetailEccValue]C.TPMS_ALGORITHM_DETAIL_ECC)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewTpmsAlgorithmDetailEccRef(unsafe.Pointer(&ptr2))
		}
	}
}

// unpackArgSTpm2bIv transforms a sliced Go data structure into plain C format.
func unpackArgSTpm2bIv(x []Tpm2bIv) (unpacked *C.TPM2B_IV, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpm2bIvMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPM2B_IV)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPM2B_IV)(h.Data)
	return
}

// packSTpm2bIv reads sliced Go data structure out from plain C format.
func packSTpm2bIv(v []Tpm2bIv, ptr0 *C.TPM2B_IV) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpm2bIvValue]C.TPM2B_IV)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpm2bIvRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpm2bMaxBuffer transforms a sliced Go data structure into plain C format.
func unpackArgSTpm2bMaxBuffer(x []Tpm2bMaxBuffer) (unpacked *C.TPM2B_MAX_BUFFER, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpm2bMaxBufferMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPM2B_MAX_BUFFER)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPM2B_MAX_BUFFER)(h.Data)
	return
}

// packSTpm2bMaxBuffer reads sliced Go data structure out from plain C format.
func packSTpm2bMaxBuffer(v []Tpm2bMaxBuffer, ptr0 *C.TPM2B_MAX_BUFFER) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpm2bMaxBufferValue]C.TPM2B_MAX_BUFFER)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpm2bMaxBufferRef(unsafe.Pointer(&ptr1))
	}
}

// allocPTpm2bIvMemory allocates memory for type *C.TPM2B_IV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpm2bIvMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpm2bIvValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpm2bIvValue = unsafe.Sizeof([1]*C.TPM2B_IV{})

// unpackArgSSTpm2bIv transforms a sliced Go data structure into plain C format.
func unpackArgSSTpm2bIv(x [][]Tpm2bIv) (unpacked **C.TPM2B_IV, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpm2bIvMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPM2B_IV)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpm2bIvMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPM2B_IV)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPM2B_IV)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPM2B_IV)(h.Data)
	return
}

// packSSTpm2bIv reads sliced Go data structure out from plain C format.
func packSSTpm2bIv(v [][]Tpm2bIv, ptr0 **C.TPM2B_IV) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPM2B_IV)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfTpm2bIvValue]C.TPM2B_IV)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewTpm2bIvRef(unsafe.Pointer(&ptr2))
		}
	}
}

// allocPTpmtTkHashcheckMemory allocates memory for type *C.TPMT_TK_HASHCHECK in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpmtTkHashcheckMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpmtTkHashcheckValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpmtTkHashcheckValue = unsafe.Sizeof([1]*C.TPMT_TK_HASHCHECK{})

// unpackArgSSTpmtTkHashcheck transforms a sliced Go data structure into plain C format.
func unpackArgSSTpmtTkHashcheck(x [][]TpmtTkHashcheck) (unpacked **C.TPMT_TK_HASHCHECK, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpmtTkHashcheckMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPMT_TK_HASHCHECK)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpmtTkHashcheckMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPMT_TK_HASHCHECK)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPMT_TK_HASHCHECK)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPMT_TK_HASHCHECK)(h.Data)
	return
}

// packSSTpmtTkHashcheck reads sliced Go data structure out from plain C format.
func packSSTpmtTkHashcheck(v [][]TpmtTkHashcheck, ptr0 **C.TPMT_TK_HASHCHECK) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPMT_TK_HASHCHECK)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfTpmtTkHashcheckValue]C.TPMT_TK_HASHCHECK)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewTpmtTkHashcheckRef(unsafe.Pointer(&ptr2))
		}
	}
}

// unpackArgSTpm2bSensitiveData transforms a sliced Go data structure into plain C format.
func unpackArgSTpm2bSensitiveData(x []Tpm2bSensitiveData) (unpacked *C.TPM2B_SENSITIVE_DATA, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpm2bSensitiveDataMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPM2B_SENSITIVE_DATA)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPM2B_SENSITIVE_DATA)(h.Data)
	return
}

// packSTpm2bSensitiveData reads sliced Go data structure out from plain C format.
func packSTpm2bSensitiveData(v []Tpm2bSensitiveData, ptr0 *C.TPM2B_SENSITIVE_DATA) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpm2bSensitiveDataValue]C.TPM2B_SENSITIVE_DATA)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpm2bSensitiveDataRef(unsafe.Pointer(&ptr1))
	}
}

// allocPTpmlDigestValuesMemory allocates memory for type *C.TPML_DIGEST_VALUES in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpmlDigestValuesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpmlDigestValuesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpmlDigestValuesValue = unsafe.Sizeof([1]*C.TPML_DIGEST_VALUES{})

// unpackArgSSTpmlDigestValues transforms a sliced Go data structure into plain C format.
func unpackArgSSTpmlDigestValues(x [][]TpmlDigestValues) (unpacked **C.TPML_DIGEST_VALUES, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpmlDigestValuesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPML_DIGEST_VALUES)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpmlDigestValuesMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPML_DIGEST_VALUES)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPML_DIGEST_VALUES)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPML_DIGEST_VALUES)(h.Data)
	return
}

// packSSTpmlDigestValues reads sliced Go data structure out from plain C format.
func packSSTpmlDigestValues(v [][]TpmlDigestValues, ptr0 **C.TPML_DIGEST_VALUES) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPML_DIGEST_VALUES)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfTpmlDigestValuesValue]C.TPML_DIGEST_VALUES)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewTpmlDigestValuesRef(unsafe.Pointer(&ptr2))
		}
	}
}

// unpackArgSTpmtSigScheme transforms a sliced Go data structure into plain C format.
func unpackArgSTpmtSigScheme(x []TpmtSigScheme) (unpacked *C.TPMT_SIG_SCHEME, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmtSigSchemeMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMT_SIG_SCHEME)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMT_SIG_SCHEME)(h.Data)
	return
}

// packSTpmtSigScheme reads sliced Go data structure out from plain C format.
func packSTpmtSigScheme(v []TpmtSigScheme, ptr0 *C.TPMT_SIG_SCHEME) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmtSigSchemeValue]C.TPMT_SIG_SCHEME)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmtSigSchemeRef(unsafe.Pointer(&ptr1))
	}
}

// allocPTpm2bAttestMemory allocates memory for type *C.TPM2B_ATTEST in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpm2bAttestMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpm2bAttestValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpm2bAttestValue = unsafe.Sizeof([1]*C.TPM2B_ATTEST{})

// unpackArgSSTpm2bAttest transforms a sliced Go data structure into plain C format.
func unpackArgSSTpm2bAttest(x [][]Tpm2bAttest) (unpacked **C.TPM2B_ATTEST, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpm2bAttestMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPM2B_ATTEST)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpm2bAttestMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPM2B_ATTEST)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPM2B_ATTEST)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPM2B_ATTEST)(h.Data)
	return
}

// packSSTpm2bAttest reads sliced Go data structure out from plain C format.
func packSSTpm2bAttest(v [][]Tpm2bAttest, ptr0 **C.TPM2B_ATTEST) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPM2B_ATTEST)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfTpm2bAttestValue]C.TPM2B_ATTEST)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewTpm2bAttestRef(unsafe.Pointer(&ptr2))
		}
	}
}

// allocPTpmtSignatureMemory allocates memory for type *C.TPMT_SIGNATURE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpmtSignatureMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpmtSignatureValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpmtSignatureValue = unsafe.Sizeof([1]*C.TPMT_SIGNATURE{})

// unpackArgSSTpmtSignature transforms a sliced Go data structure into plain C format.
func unpackArgSSTpmtSignature(x [][]TpmtSignature) (unpacked **C.TPMT_SIGNATURE, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpmtSignatureMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPMT_SIGNATURE)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpmtSignatureMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPMT_SIGNATURE)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPMT_SIGNATURE)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPMT_SIGNATURE)(h.Data)
	return
}

// packSSTpmtSignature reads sliced Go data structure out from plain C format.
func packSSTpmtSignature(v [][]TpmtSignature, ptr0 **C.TPMT_SIGNATURE) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPMT_SIGNATURE)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfTpmtSignatureValue]C.TPMT_SIGNATURE)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewTpmtSignatureRef(unsafe.Pointer(&ptr2))
		}
	}
}

// unpackArgSTpmtTkCreation transforms a sliced Go data structure into plain C format.
func unpackArgSTpmtTkCreation(x []TpmtTkCreation) (unpacked *C.TPMT_TK_CREATION, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmtTkCreationMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMT_TK_CREATION)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMT_TK_CREATION)(h.Data)
	return
}

// packSTpmtTkCreation reads sliced Go data structure out from plain C format.
func packSTpmtTkCreation(v []TpmtTkCreation, ptr0 *C.TPMT_TK_CREATION) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmtTkCreationValue]C.TPMT_TK_CREATION)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmtTkCreationRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpm2bEccParameter transforms a sliced Go data structure into plain C format.
func unpackArgSTpm2bEccParameter(x []Tpm2bEccParameter) (unpacked *C.TPM2B_ECC_PARAMETER, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpm2bEccParameterMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPM2B_ECC_PARAMETER)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPM2B_ECC_PARAMETER)(h.Data)
	return
}

// packSTpm2bEccParameter reads sliced Go data structure out from plain C format.
func packSTpm2bEccParameter(v []Tpm2bEccParameter, ptr0 *C.TPM2B_ECC_PARAMETER) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpm2bEccParameterValue]C.TPM2B_ECC_PARAMETER)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpm2bEccParameterRef(unsafe.Pointer(&ptr1))
	}
}

// copyPUint16Bytes copies the data from Go slice as *C.UINT16.
func copyPUint16Bytes(slice *sliceHeader) (*C.UINT16, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfUint16Value) * slice.Len,
		Cap:  int(sizeOfUint16Value) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.UINT16)(mem0), allocs
}

// allocUint16Memory allocates memory for type C.UINT16 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUint16Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUint16Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUint16Value = unsafe.Sizeof([1]C.UINT16{})

// unpackArgSTpmtSignature transforms a sliced Go data structure into plain C format.
func unpackArgSTpmtSignature(x []TpmtSignature) (unpacked *C.TPMT_SIGNATURE, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmtSignatureMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMT_SIGNATURE)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMT_SIGNATURE)(h.Data)
	return
}

// packSTpmtSignature reads sliced Go data structure out from plain C format.
func packSTpmtSignature(v []TpmtSignature, ptr0 *C.TPMT_SIGNATURE) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmtSignatureValue]C.TPMT_SIGNATURE)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmtSignatureRef(unsafe.Pointer(&ptr1))
	}
}

// allocPTpmtTkVerifiedMemory allocates memory for type *C.TPMT_TK_VERIFIED in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpmtTkVerifiedMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpmtTkVerifiedValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpmtTkVerifiedValue = unsafe.Sizeof([1]*C.TPMT_TK_VERIFIED{})

// unpackArgSSTpmtTkVerified transforms a sliced Go data structure into plain C format.
func unpackArgSSTpmtTkVerified(x [][]TpmtTkVerified) (unpacked **C.TPMT_TK_VERIFIED, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpmtTkVerifiedMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPMT_TK_VERIFIED)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpmtTkVerifiedMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPMT_TK_VERIFIED)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPMT_TK_VERIFIED)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPMT_TK_VERIFIED)(h.Data)
	return
}

// packSSTpmtTkVerified reads sliced Go data structure out from plain C format.
func packSSTpmtTkVerified(v [][]TpmtTkVerified, ptr0 **C.TPMT_TK_VERIFIED) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPMT_TK_VERIFIED)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfTpmtTkVerifiedValue]C.TPMT_TK_VERIFIED)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewTpmtTkVerifiedRef(unsafe.Pointer(&ptr2))
		}
	}
}

// unpackArgSTpmtTkHashcheck transforms a sliced Go data structure into plain C format.
func unpackArgSTpmtTkHashcheck(x []TpmtTkHashcheck) (unpacked *C.TPMT_TK_HASHCHECK, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmtTkHashcheckMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMT_TK_HASHCHECK)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMT_TK_HASHCHECK)(h.Data)
	return
}

// packSTpmtTkHashcheck reads sliced Go data structure out from plain C format.
func packSTpmtTkHashcheck(v []TpmtTkHashcheck, ptr0 *C.TPMT_TK_HASHCHECK) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmtTkHashcheckValue]C.TPMT_TK_HASHCHECK)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmtTkHashcheckRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmlCc transforms a sliced Go data structure into plain C format.
func unpackArgSTpmlCc(x []TpmlCc) (unpacked *C.TPML_CC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmlCcMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPML_CC)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPML_CC)(h.Data)
	return
}

// packSTpmlCc reads sliced Go data structure out from plain C format.
func packSTpmlCc(v []TpmlCc, ptr0 *C.TPML_CC) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmlCcValue]C.TPML_CC)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmlCcRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmlDigestValues transforms a sliced Go data structure into plain C format.
func unpackArgSTpmlDigestValues(x []TpmlDigestValues) (unpacked *C.TPML_DIGEST_VALUES, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmlDigestValuesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPML_DIGEST_VALUES)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPML_DIGEST_VALUES)(h.Data)
	return
}

// packSTpmlDigestValues reads sliced Go data structure out from plain C format.
func packSTpmlDigestValues(v []TpmlDigestValues, ptr0 *C.TPML_DIGEST_VALUES) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmlDigestValuesValue]C.TPML_DIGEST_VALUES)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmlDigestValuesRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpm2bEvent transforms a sliced Go data structure into plain C format.
func unpackArgSTpm2bEvent(x []Tpm2bEvent) (unpacked *C.TPM2B_EVENT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpm2bEventMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPM2B_EVENT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPM2B_EVENT)(h.Data)
	return
}

// packSTpm2bEvent reads sliced Go data structure out from plain C format.
func packSTpm2bEvent(v []Tpm2bEvent, ptr0 *C.TPM2B_EVENT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpm2bEventValue]C.TPM2B_EVENT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpm2bEventRef(unsafe.Pointer(&ptr1))
	}
}

// copyPUint32Bytes copies the data from Go slice as *C.UINT32.
func copyPUint32Bytes(slice *sliceHeader) (*C.UINT32, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfUint32Value) * slice.Len,
		Cap:  int(sizeOfUint32Value) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.UINT32)(mem0), allocs
}

// allocUint32Memory allocates memory for type C.UINT32 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUint32Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUint32Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUint32Value = unsafe.Sizeof([1]C.UINT32{})

// allocPTpmlPcrSelectionMemory allocates memory for type *C.TPML_PCR_SELECTION in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpmlPcrSelectionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpmlPcrSelectionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpmlPcrSelectionValue = unsafe.Sizeof([1]*C.TPML_PCR_SELECTION{})

// unpackArgSSTpmlPcrSelection transforms a sliced Go data structure into plain C format.
func unpackArgSSTpmlPcrSelection(x [][]TpmlPcrSelection) (unpacked **C.TPML_PCR_SELECTION, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpmlPcrSelectionMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPML_PCR_SELECTION)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpmlPcrSelectionMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPML_PCR_SELECTION)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPML_PCR_SELECTION)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPML_PCR_SELECTION)(h.Data)
	return
}

// packSSTpmlPcrSelection reads sliced Go data structure out from plain C format.
func packSSTpmlPcrSelection(v [][]TpmlPcrSelection, ptr0 **C.TPML_PCR_SELECTION) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPML_PCR_SELECTION)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfTpmlPcrSelectionValue]C.TPML_PCR_SELECTION)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewTpmlPcrSelectionRef(unsafe.Pointer(&ptr2))
		}
	}
}

// allocPTpmlDigestMemory allocates memory for type *C.TPML_DIGEST in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpmlDigestMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpmlDigestValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpmlDigestValue = unsafe.Sizeof([1]*C.TPML_DIGEST{})

// unpackArgSSTpmlDigest transforms a sliced Go data structure into plain C format.
func unpackArgSSTpmlDigest(x [][]TpmlDigest) (unpacked **C.TPML_DIGEST, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpmlDigestMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPML_DIGEST)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpmlDigestMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPML_DIGEST)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPML_DIGEST)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPML_DIGEST)(h.Data)
	return
}

// packSSTpmlDigest reads sliced Go data structure out from plain C format.
func packSSTpmlDigest(v [][]TpmlDigest, ptr0 **C.TPML_DIGEST) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPML_DIGEST)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfTpmlDigestValue]C.TPML_DIGEST)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewTpmlDigestRef(unsafe.Pointer(&ptr2))
		}
	}
}

// copyPTpmiYesNoBytes copies the data from Go slice as *C.TPMI_YES_NO.
func copyPTpmiYesNoBytes(slice *sliceHeader) (*C.TPMI_YES_NO, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmiYesNoValue) * slice.Len,
		Cap:  int(sizeOfTpmiYesNoValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMI_YES_NO)(mem0), allocs
}

// allocTpmiYesNoMemory allocates memory for type C.TPMI_YES_NO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmiYesNoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmiYesNoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmiYesNoValue = unsafe.Sizeof([1]C.TPMI_YES_NO{})

// allocPTpm2bTimeoutMemory allocates memory for type *C.TPM2B_TIMEOUT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpm2bTimeoutMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpm2bTimeoutValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpm2bTimeoutValue = unsafe.Sizeof([1]*C.TPM2B_TIMEOUT{})

// allocTpm2bTimeoutMemory allocates memory for type C.TPM2B_TIMEOUT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bTimeoutMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bTimeoutValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bTimeoutValue = unsafe.Sizeof([1]C.TPM2B_TIMEOUT{})

// unpackArgSSTpm2bTimeout transforms a sliced Go data structure into plain C format.
func unpackArgSSTpm2bTimeout(x [][]Tpm2bTimeout) (unpacked **C.TPM2B_TIMEOUT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpm2bTimeoutMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPM2B_TIMEOUT)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpm2bTimeoutMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPM2B_TIMEOUT)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPM2B_TIMEOUT)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPM2B_TIMEOUT)(h.Data)
	return
}

// packSSTpm2bTimeout reads sliced Go data structure out from plain C format.
func packSSTpm2bTimeout(v [][]Tpm2bTimeout, ptr0 **C.TPM2B_TIMEOUT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPM2B_TIMEOUT)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfTpm2bTimeoutValue]C.TPM2B_TIMEOUT)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewTpm2bTimeoutRef(unsafe.Pointer(&ptr2))
		}
	}
}

// allocPTpmtTkAuthMemory allocates memory for type *C.TPMT_TK_AUTH in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpmtTkAuthMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpmtTkAuthValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpmtTkAuthValue = unsafe.Sizeof([1]*C.TPMT_TK_AUTH{})

// unpackArgSSTpmtTkAuth transforms a sliced Go data structure into plain C format.
func unpackArgSSTpmtTkAuth(x [][]TpmtTkAuth) (unpacked **C.TPMT_TK_AUTH, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpmtTkAuthMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPMT_TK_AUTH)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpmtTkAuthMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPMT_TK_AUTH)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPMT_TK_AUTH)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPMT_TK_AUTH)(h.Data)
	return
}

// packSSTpmtTkAuth reads sliced Go data structure out from plain C format.
func packSSTpmtTkAuth(v [][]TpmtTkAuth, ptr0 **C.TPMT_TK_AUTH) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPMT_TK_AUTH)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfTpmtTkAuthValue]C.TPMT_TK_AUTH)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewTpmtTkAuthRef(unsafe.Pointer(&ptr2))
		}
	}
}

// unpackArgSTpm2bTimeout transforms a sliced Go data structure into plain C format.
func unpackArgSTpm2bTimeout(x []Tpm2bTimeout) (unpacked *C.TPM2B_TIMEOUT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpm2bTimeoutMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPM2B_TIMEOUT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPM2B_TIMEOUT)(h.Data)
	return
}

// packSTpm2bTimeout reads sliced Go data structure out from plain C format.
func packSTpm2bTimeout(v []Tpm2bTimeout, ptr0 *C.TPM2B_TIMEOUT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpm2bTimeoutValue]C.TPM2B_TIMEOUT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpm2bTimeoutRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmtTkAuth transforms a sliced Go data structure into plain C format.
func unpackArgSTpmtTkAuth(x []TpmtTkAuth) (unpacked *C.TPMT_TK_AUTH, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmtTkAuthMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMT_TK_AUTH)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMT_TK_AUTH)(h.Data)
	return
}

// packSTpmtTkAuth reads sliced Go data structure out from plain C format.
func packSTpmtTkAuth(v []TpmtTkAuth, ptr0 *C.TPMT_TK_AUTH) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmtTkAuthValue]C.TPMT_TK_AUTH)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmtTkAuthRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmlDigest transforms a sliced Go data structure into plain C format.
func unpackArgSTpmlDigest(x []TpmlDigest) (unpacked *C.TPML_DIGEST, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmlDigestMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPML_DIGEST)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPML_DIGEST)(h.Data)
	return
}

// packSTpmlDigest reads sliced Go data structure out from plain C format.
func packSTpmlDigest(v []TpmlDigest, ptr0 *C.TPML_DIGEST) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmlDigestValue]C.TPML_DIGEST)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmlDigestRef(unsafe.Pointer(&ptr1))
	}
}

// allocTpm2bOperandMemory allocates memory for type C.TPM2B_OPERAND in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2bOperandMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2bOperandValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2bOperandValue = unsafe.Sizeof([1]C.TPM2B_OPERAND{})

// unpackArgSTpm2bOperand transforms a sliced Go data structure into plain C format.
func unpackArgSTpm2bOperand(x []Tpm2bOperand) (unpacked *C.TPM2B_OPERAND, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpm2bOperandMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPM2B_OPERAND)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPM2B_OPERAND)(h.Data)
	return
}

// packSTpm2bOperand reads sliced Go data structure out from plain C format.
func packSTpm2bOperand(v []Tpm2bOperand, ptr0 *C.TPM2B_OPERAND) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpm2bOperandValue]C.TPM2B_OPERAND)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpm2bOperandRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmtTkVerified transforms a sliced Go data structure into plain C format.
func unpackArgSTpmtTkVerified(x []TpmtTkVerified) (unpacked *C.TPMT_TK_VERIFIED, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmtTkVerifiedMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMT_TK_VERIFIED)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMT_TK_VERIFIED)(h.Data)
	return
}

// packSTpmtTkVerified reads sliced Go data structure out from plain C format.
func packSTpmtTkVerified(v []TpmtTkVerified, ptr0 *C.TPMT_TK_VERIFIED) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmtTkVerifiedValue]C.TPMT_TK_VERIFIED)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmtTkVerifiedRef(unsafe.Pointer(&ptr1))
	}
}

// allocPTpmtHaMemory allocates memory for type *C.TPMT_HA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpmtHaMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpmtHaValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpmtHaValue = unsafe.Sizeof([1]*C.TPMT_HA{})

// unpackArgSSTpmtHa transforms a sliced Go data structure into plain C format.
func unpackArgSSTpmtHa(x [][]TpmtHa) (unpacked **C.TPMT_HA, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpmtHaMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPMT_HA)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpmtHaMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPMT_HA)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPMT_HA)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPMT_HA)(h.Data)
	return
}

// packSSTpmtHa reads sliced Go data structure out from plain C format.
func packSSTpmtHa(v [][]TpmtHa, ptr0 **C.TPMT_HA) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPMT_HA)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfTpmtHaValue]C.TPMT_HA)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewTpmtHaRef(unsafe.Pointer(&ptr2))
		}
	}
}

// allocPTpmsContextMemory allocates memory for type *C.TPMS_CONTEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpmsContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpmsContextValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpmsContextValue = unsafe.Sizeof([1]*C.TPMS_CONTEXT{})

// unpackArgSSTpmsContext transforms a sliced Go data structure into plain C format.
func unpackArgSSTpmsContext(x [][]TpmsContext) (unpacked **C.TPMS_CONTEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpmsContextMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPMS_CONTEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpmsContextMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPMS_CONTEXT)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPMS_CONTEXT)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPMS_CONTEXT)(h.Data)
	return
}

// packSSTpmsContext reads sliced Go data structure out from plain C format.
func packSSTpmsContext(v [][]TpmsContext, ptr0 **C.TPMS_CONTEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPMS_CONTEXT)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfTpmsContextValue]C.TPMS_CONTEXT)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewTpmsContextRef(unsafe.Pointer(&ptr2))
		}
	}
}

// unpackArgSTpmsContext transforms a sliced Go data structure into plain C format.
func unpackArgSTpmsContext(x []TpmsContext) (unpacked *C.TPMS_CONTEXT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmsContextMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMS_CONTEXT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMS_CONTEXT)(h.Data)
	return
}

// packSTpmsContext reads sliced Go data structure out from plain C format.
func packSTpmsContext(v []TpmsContext, ptr0 *C.TPMS_CONTEXT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmsContextValue]C.TPMS_CONTEXT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmsContextRef(unsafe.Pointer(&ptr1))
	}
}

// allocPTpmsTimeInfoMemory allocates memory for type *C.TPMS_TIME_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpmsTimeInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpmsTimeInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpmsTimeInfoValue = unsafe.Sizeof([1]*C.TPMS_TIME_INFO{})

// unpackArgSSTpmsTimeInfo transforms a sliced Go data structure into plain C format.
func unpackArgSSTpmsTimeInfo(x [][]TpmsTimeInfo) (unpacked **C.TPMS_TIME_INFO, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpmsTimeInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPMS_TIME_INFO)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpmsTimeInfoMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPMS_TIME_INFO)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPMS_TIME_INFO)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPMS_TIME_INFO)(h.Data)
	return
}

// packSSTpmsTimeInfo reads sliced Go data structure out from plain C format.
func packSSTpmsTimeInfo(v [][]TpmsTimeInfo, ptr0 **C.TPMS_TIME_INFO) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPMS_TIME_INFO)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfTpmsTimeInfoValue]C.TPMS_TIME_INFO)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewTpmsTimeInfoRef(unsafe.Pointer(&ptr2))
		}
	}
}

// allocPTpmsCapabilityDataMemory allocates memory for type *C.TPMS_CAPABILITY_DATA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpmsCapabilityDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpmsCapabilityDataValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpmsCapabilityDataValue = unsafe.Sizeof([1]*C.TPMS_CAPABILITY_DATA{})

// unpackArgSSTpmsCapabilityData transforms a sliced Go data structure into plain C format.
func unpackArgSSTpmsCapabilityData(x [][]TpmsCapabilityData) (unpacked **C.TPMS_CAPABILITY_DATA, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpmsCapabilityDataMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPMS_CAPABILITY_DATA)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpmsCapabilityDataMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPMS_CAPABILITY_DATA)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPMS_CAPABILITY_DATA)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPMS_CAPABILITY_DATA)(h.Data)
	return
}

// packSSTpmsCapabilityData reads sliced Go data structure out from plain C format.
func packSSTpmsCapabilityData(v [][]TpmsCapabilityData, ptr0 **C.TPMS_CAPABILITY_DATA) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPMS_CAPABILITY_DATA)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfTpmsCapabilityDataValue]C.TPMS_CAPABILITY_DATA)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewTpmsCapabilityDataRef(unsafe.Pointer(&ptr2))
		}
	}
}

// unpackArgSTpmtPublicParms transforms a sliced Go data structure into plain C format.
func unpackArgSTpmtPublicParms(x []TpmtPublicParms) (unpacked *C.TPMT_PUBLIC_PARMS, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmtPublicParmsMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMT_PUBLIC_PARMS)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMT_PUBLIC_PARMS)(h.Data)
	return
}

// packSTpmtPublicParms reads sliced Go data structure out from plain C format.
func packSTpmtPublicParms(v []TpmtPublicParms, ptr0 *C.TPMT_PUBLIC_PARMS) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmtPublicParmsValue]C.TPMT_PUBLIC_PARMS)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmtPublicParmsRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpm2bNvPublic transforms a sliced Go data structure into plain C format.
func unpackArgSTpm2bNvPublic(x []Tpm2bNvPublic) (unpacked *C.TPM2B_NV_PUBLIC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpm2bNvPublicMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPM2B_NV_PUBLIC)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPM2B_NV_PUBLIC)(h.Data)
	return
}

// packSTpm2bNvPublic reads sliced Go data structure out from plain C format.
func packSTpm2bNvPublic(v []Tpm2bNvPublic, ptr0 *C.TPM2B_NV_PUBLIC) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpm2bNvPublicValue]C.TPM2B_NV_PUBLIC)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpm2bNvPublicRef(unsafe.Pointer(&ptr1))
	}
}

// allocPTpm2bNvPublicMemory allocates memory for type *C.TPM2B_NV_PUBLIC in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpm2bNvPublicMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpm2bNvPublicValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpm2bNvPublicValue = unsafe.Sizeof([1]*C.TPM2B_NV_PUBLIC{})

// unpackArgSSTpm2bNvPublic transforms a sliced Go data structure into plain C format.
func unpackArgSSTpm2bNvPublic(x [][]Tpm2bNvPublic) (unpacked **C.TPM2B_NV_PUBLIC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpm2bNvPublicMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPM2B_NV_PUBLIC)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpm2bNvPublicMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPM2B_NV_PUBLIC)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPM2B_NV_PUBLIC)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPM2B_NV_PUBLIC)(h.Data)
	return
}

// packSSTpm2bNvPublic reads sliced Go data structure out from plain C format.
func packSSTpm2bNvPublic(v [][]Tpm2bNvPublic, ptr0 **C.TPM2B_NV_PUBLIC) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPM2B_NV_PUBLIC)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfTpm2bNvPublicValue]C.TPM2B_NV_PUBLIC)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewTpm2bNvPublicRef(unsafe.Pointer(&ptr2))
		}
	}
}

// unpackArgSTpm2bMaxNvBuffer transforms a sliced Go data structure into plain C format.
func unpackArgSTpm2bMaxNvBuffer(x []Tpm2bMaxNvBuffer) (unpacked *C.TPM2B_MAX_NV_BUFFER, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpm2bMaxNvBufferMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPM2B_MAX_NV_BUFFER)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPM2B_MAX_NV_BUFFER)(h.Data)
	return
}

// packSTpm2bMaxNvBuffer reads sliced Go data structure out from plain C format.
func packSTpm2bMaxNvBuffer(v []Tpm2bMaxNvBuffer, ptr0 *C.TPM2B_MAX_NV_BUFFER) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpm2bMaxNvBufferValue]C.TPM2B_MAX_NV_BUFFER)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpm2bMaxNvBufferRef(unsafe.Pointer(&ptr1))
	}
}

// allocPTpm2bMaxNvBufferMemory allocates memory for type *C.TPM2B_MAX_NV_BUFFER in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTpm2bMaxNvBufferMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTpm2bMaxNvBufferValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPTpm2bMaxNvBufferValue = unsafe.Sizeof([1]*C.TPM2B_MAX_NV_BUFFER{})

// unpackArgSSTpm2bMaxNvBuffer transforms a sliced Go data structure into plain C format.
func unpackArgSSTpm2bMaxNvBuffer(x [][]Tpm2bMaxNvBuffer) (unpacked **C.TPM2B_MAX_NV_BUFFER, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPTpm2bMaxNvBufferMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.TPM2B_MAX_NV_BUFFER)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTpm2bMaxNvBufferMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.TPM2B_MAX_NV_BUFFER)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.TPM2B_MAX_NV_BUFFER)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.TPM2B_MAX_NV_BUFFER)(h.Data)
	return
}

// packSSTpm2bMaxNvBuffer reads sliced Go data structure out from plain C format.
func packSSTpm2bMaxNvBuffer(v [][]Tpm2bMaxNvBuffer, ptr0 **C.TPM2B_MAX_NV_BUFFER) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.TPM2B_MAX_NV_BUFFER)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfTpm2bMaxNvBufferValue]C.TPM2B_MAX_NV_BUFFER)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewTpm2bMaxNvBufferRef(unsafe.Pointer(&ptr2))
		}
	}
}

// copyPTss2lSysAuthCommandBytes copies the data from Go slice as *C.TSS2L_SYS_AUTH_COMMAND.
func copyPTss2lSysAuthCommandBytes(slice *sliceHeader) (*C.TSS2L_SYS_AUTH_COMMAND, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTss2lSysAuthCommandValue) * slice.Len,
		Cap:  int(sizeOfTss2lSysAuthCommandValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TSS2L_SYS_AUTH_COMMAND)(mem0), allocs
}

// copyPUint8Bytes copies the data from Go slice as *C.UINT8.
func copyPUint8Bytes(slice *sliceHeader) (*C.UINT8, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfUint8Value) * slice.Len,
		Cap:  int(sizeOfUint8Value) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.UINT8)(mem0), allocs
}

// allocUint8Memory allocates memory for type C.UINT8 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUint8Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUint8Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUint8Value = unsafe.Sizeof([1]C.UINT8{})

// copyPTss2lSysAuthResponseBytes copies the data from Go slice as *C.TSS2L_SYS_AUTH_RESPONSE.
func copyPTss2lSysAuthResponseBytes(slice *sliceHeader) (*C.TSS2L_SYS_AUTH_RESPONSE, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTss2lSysAuthResponseValue) * slice.Len,
		Cap:  int(sizeOfTss2lSysAuthResponseValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TSS2L_SYS_AUTH_RESPONSE)(mem0), allocs
}

// copyPTpmiShAuthSessionBytes copies the data from Go slice as *C.TPMI_SH_AUTH_SESSION.
func copyPTpmiShAuthSessionBytes(slice *sliceHeader) (*C.TPMI_SH_AUTH_SESSION, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmiShAuthSessionValue) * slice.Len,
		Cap:  int(sizeOfTpmiShAuthSessionValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMI_SH_AUTH_SESSION)(mem0), allocs
}

// allocTpmiShAuthSessionMemory allocates memory for type C.TPMI_SH_AUTH_SESSION in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmiShAuthSessionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmiShAuthSessionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmiShAuthSessionValue = unsafe.Sizeof([1]C.TPMI_SH_AUTH_SESSION{})

// unpackArgSTpm2bCreationData transforms a sliced Go data structure into plain C format.
func unpackArgSTpm2bCreationData(x []Tpm2bCreationData) (unpacked *C.TPM2B_CREATION_DATA, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpm2bCreationDataMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPM2B_CREATION_DATA)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPM2B_CREATION_DATA)(h.Data)
	return
}

// packSTpm2bCreationData reads sliced Go data structure out from plain C format.
func packSTpm2bCreationData(v []Tpm2bCreationData, ptr0 *C.TPM2B_CREATION_DATA) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpm2bCreationDataValue]C.TPM2B_CREATION_DATA)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpm2bCreationDataRef(unsafe.Pointer(&ptr1))
	}
}

// copyPTpm2HandleBytes copies the data from Go slice as *C.TPM2_HANDLE.
func copyPTpm2HandleBytes(slice *sliceHeader) (*C.TPM2_HANDLE, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2HandleValue) * slice.Len,
		Cap:  int(sizeOfTpm2HandleValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2_HANDLE)(mem0), allocs
}

// allocTpm2HandleMemory allocates memory for type C.TPM2_HANDLE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2HandleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2HandleValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2HandleValue = unsafe.Sizeof([1]C.TPM2_HANDLE{})

// unpackArgSTpmsAlgorithmDetailEcc transforms a sliced Go data structure into plain C format.
func unpackArgSTpmsAlgorithmDetailEcc(x []TpmsAlgorithmDetailEcc) (unpacked *C.TPMS_ALGORITHM_DETAIL_ECC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmsAlgorithmDetailEccMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMS_ALGORITHM_DETAIL_ECC)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMS_ALGORITHM_DETAIL_ECC)(h.Data)
	return
}

// packSTpmsAlgorithmDetailEcc reads sliced Go data structure out from plain C format.
func packSTpmsAlgorithmDetailEcc(v []TpmsAlgorithmDetailEcc, ptr0 *C.TPMS_ALGORITHM_DETAIL_ECC) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmsAlgorithmDetailEccValue]C.TPMS_ALGORITHM_DETAIL_ECC)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmsAlgorithmDetailEccRef(unsafe.Pointer(&ptr1))
	}
}

// copyPTpmiDhObjectBytes copies the data from Go slice as *C.TPMI_DH_OBJECT.
func copyPTpmiDhObjectBytes(slice *sliceHeader) (*C.TPMI_DH_OBJECT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmiDhObjectValue) * slice.Len,
		Cap:  int(sizeOfTpmiDhObjectValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMI_DH_OBJECT)(mem0), allocs
}

// allocTpmiDhObjectMemory allocates memory for type C.TPMI_DH_OBJECT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmiDhObjectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmiDhObjectValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmiDhObjectValue = unsafe.Sizeof([1]C.TPMI_DH_OBJECT{})

// unpackArgSTpm2bAttest transforms a sliced Go data structure into plain C format.
func unpackArgSTpm2bAttest(x []Tpm2bAttest) (unpacked *C.TPM2B_ATTEST, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpm2bAttestMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPM2B_ATTEST)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPM2B_ATTEST)(h.Data)
	return
}

// packSTpm2bAttest reads sliced Go data structure out from plain C format.
func packSTpm2bAttest(v []Tpm2bAttest, ptr0 *C.TPM2B_ATTEST) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpm2bAttestValue]C.TPM2B_ATTEST)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpm2bAttestRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmtHa transforms a sliced Go data structure into plain C format.
func unpackArgSTpmtHa(x []TpmtHa) (unpacked *C.TPMT_HA, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmtHaMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMT_HA)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMT_HA)(h.Data)
	return
}

// packSTpmtHa reads sliced Go data structure out from plain C format.
func packSTpmtHa(v []TpmtHa, ptr0 *C.TPMT_HA) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmtHaValue]C.TPMT_HA)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmtHaRef(unsafe.Pointer(&ptr1))
	}
}

// copyPTpmiDhContextBytes copies the data from Go slice as *C.TPMI_DH_CONTEXT.
func copyPTpmiDhContextBytes(slice *sliceHeader) (*C.TPMI_DH_CONTEXT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmiDhContextValue) * slice.Len,
		Cap:  int(sizeOfTpmiDhContextValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMI_DH_CONTEXT)(mem0), allocs
}

// allocTpmiDhContextMemory allocates memory for type C.TPMI_DH_CONTEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmiDhContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmiDhContextValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmiDhContextValue = unsafe.Sizeof([1]C.TPMI_DH_CONTEXT{})

// unpackArgSTpmsTimeInfo transforms a sliced Go data structure into plain C format.
func unpackArgSTpmsTimeInfo(x []TpmsTimeInfo) (unpacked *C.TPMS_TIME_INFO, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmsTimeInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMS_TIME_INFO)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMS_TIME_INFO)(h.Data)
	return
}

// packSTpmsTimeInfo reads sliced Go data structure out from plain C format.
func packSTpmsTimeInfo(v []TpmsTimeInfo, ptr0 *C.TPMS_TIME_INFO) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmsTimeInfoValue]C.TPMS_TIME_INFO)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmsTimeInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmsCapabilityData transforms a sliced Go data structure into plain C format.
func unpackArgSTpmsCapabilityData(x []TpmsCapabilityData) (unpacked *C.TPMS_CAPABILITY_DATA, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmsCapabilityDataMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMS_CAPABILITY_DATA)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMS_CAPABILITY_DATA)(h.Data)
	return
}

// packSTpmsCapabilityData reads sliced Go data structure out from plain C format.
func packSTpmsCapabilityData(v []TpmsCapabilityData, ptr0 *C.TPMS_CAPABILITY_DATA) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmsCapabilityDataValue]C.TPMS_CAPABILITY_DATA)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmsCapabilityDataRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmlAcCapabilities transforms a sliced Go data structure into plain C format.
func unpackArgSTpmlAcCapabilities(x []TpmlAcCapabilities) (unpacked *C.TPML_AC_CAPABILITIES, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmlAcCapabilitiesMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPML_AC_CAPABILITIES)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPML_AC_CAPABILITIES)(h.Data)
	return
}

// packSTpmlAcCapabilities reads sliced Go data structure out from plain C format.
func packSTpmlAcCapabilities(v []TpmlAcCapabilities, ptr0 *C.TPML_AC_CAPABILITIES) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmlAcCapabilitiesValue]C.TPML_AC_CAPABILITIES)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmlAcCapabilitiesRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmsAcOutput transforms a sliced Go data structure into plain C format.
func unpackArgSTpmsAcOutput(x []TpmsAcOutput) (unpacked *C.TPMS_AC_OUTPUT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmsAcOutputMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMS_AC_OUTPUT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMS_AC_OUTPUT)(h.Data)
	return
}

// packSTpmsAcOutput reads sliced Go data structure out from plain C format.
func packSTpmsAcOutput(v []TpmsAcOutput, ptr0 *C.TPMS_AC_OUTPUT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmsAcOutputValue]C.TPMS_AC_OUTPUT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmsAcOutputRef(unsafe.Pointer(&ptr1))
	}
}

// copyPByteBytes copies the data from Go slice as *C.BYTE.
func copyPByteBytes(slice *sliceHeader) (*C.BYTE, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfByteValue) * slice.Len,
		Cap:  int(sizeOfByteValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.BYTE)(mem0), allocs
}

// allocByteMemory allocates memory for type C.BYTE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocByteMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfByteValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfByteValue = unsafe.Sizeof([1]C.BYTE{})

// copyPInt8Bytes copies the data from Go slice as *C.INT8.
func copyPInt8Bytes(slice *sliceHeader) (*C.INT8, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfInt8Value) * slice.Len,
		Cap:  int(sizeOfInt8Value) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.INT8)(mem0), allocs
}

// allocInt8Memory allocates memory for type C.INT8 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocInt8Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfInt8Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfInt8Value = unsafe.Sizeof([1]C.INT8{})

// copyPInt16Bytes copies the data from Go slice as *C.INT16.
func copyPInt16Bytes(slice *sliceHeader) (*C.INT16, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfInt16Value) * slice.Len,
		Cap:  int(sizeOfInt16Value) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.INT16)(mem0), allocs
}

// allocInt16Memory allocates memory for type C.INT16 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocInt16Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfInt16Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfInt16Value = unsafe.Sizeof([1]C.INT16{})

// copyPInt32Bytes copies the data from Go slice as *C.INT32.
func copyPInt32Bytes(slice *sliceHeader) (*C.INT32, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfInt32Value) * slice.Len,
		Cap:  int(sizeOfInt32Value) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.INT32)(mem0), allocs
}

// allocInt32Memory allocates memory for type C.INT32 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocInt32Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfInt32Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfInt32Value = unsafe.Sizeof([1]C.INT32{})

// copyPInt64Bytes copies the data from Go slice as *C.INT64.
func copyPInt64Bytes(slice *sliceHeader) (*C.INT64, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfInt64Value) * slice.Len,
		Cap:  int(sizeOfInt64Value) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.INT64)(mem0), allocs
}

// allocInt64Memory allocates memory for type C.INT64 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocInt64Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfInt64Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfInt64Value = unsafe.Sizeof([1]C.INT64{})

// copyPUint64Bytes copies the data from Go slice as *C.UINT64.
func copyPUint64Bytes(slice *sliceHeader) (*C.UINT64, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfUint64Value) * slice.Len,
		Cap:  int(sizeOfUint64Value) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.UINT64)(mem0), allocs
}

// allocUint64Memory allocates memory for type C.UINT64 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUint64Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUint64Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUint64Value = unsafe.Sizeof([1]C.UINT64{})

// copyPTpm2CcBytes copies the data from Go slice as *C.TPM2_CC.
func copyPTpm2CcBytes(slice *sliceHeader) (*C.TPM2_CC, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2CcValue) * slice.Len,
		Cap:  int(sizeOfTpm2CcValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2_CC)(mem0), allocs
}

// allocTpm2CcMemory allocates memory for type C.TPM2_CC in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2CcMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2CcValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2CcValue = unsafe.Sizeof([1]C.TPM2_CC{})

// copyPTpm2StBytes copies the data from Go slice as *C.TPM2_ST.
func copyPTpm2StBytes(slice *sliceHeader) (*C.TPM2_ST, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2StValue) * slice.Len,
		Cap:  int(sizeOfTpm2StValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2_ST)(mem0), allocs
}

// allocTpm2StMemory allocates memory for type C.TPM2_ST in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2StMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2StValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2StValue = unsafe.Sizeof([1]C.TPM2_ST{})

// copyPTpmaAlgorithmBytes copies the data from Go slice as *C.TPMA_ALGORITHM.
func copyPTpmaAlgorithmBytes(slice *sliceHeader) (*C.TPMA_ALGORITHM, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmaAlgorithmValue) * slice.Len,
		Cap:  int(sizeOfTpmaAlgorithmValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMA_ALGORITHM)(mem0), allocs
}

// allocTpmaAlgorithmMemory allocates memory for type C.TPMA_ALGORITHM in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmaAlgorithmMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmaAlgorithmValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmaAlgorithmValue = unsafe.Sizeof([1]C.TPMA_ALGORITHM{})

// copyPTpmaCcBytes copies the data from Go slice as *C.TPMA_CC.
func copyPTpmaCcBytes(slice *sliceHeader) (*C.TPMA_CC, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmaCcValue) * slice.Len,
		Cap:  int(sizeOfTpmaCcValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMA_CC)(mem0), allocs
}

// allocTpmaCcMemory allocates memory for type C.TPMA_CC in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmaCcMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmaCcValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmaCcValue = unsafe.Sizeof([1]C.TPMA_CC{})

// copyPTpmaLocalityBytes copies the data from Go slice as *C.TPMA_LOCALITY.
func copyPTpmaLocalityBytes(slice *sliceHeader) (*C.TPMA_LOCALITY, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmaLocalityValue) * slice.Len,
		Cap:  int(sizeOfTpmaLocalityValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMA_LOCALITY)(mem0), allocs
}

// allocTpmaLocalityMemory allocates memory for type C.TPMA_LOCALITY in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmaLocalityMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmaLocalityValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmaLocalityValue = unsafe.Sizeof([1]C.TPMA_LOCALITY{})

// copyPTpmaNvBytes copies the data from Go slice as *C.TPMA_NV.
func copyPTpmaNvBytes(slice *sliceHeader) (*C.TPMA_NV, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmaNvValue) * slice.Len,
		Cap:  int(sizeOfTpmaNvValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMA_NV)(mem0), allocs
}

// allocTpmaNvMemory allocates memory for type C.TPMA_NV in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmaNvMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmaNvValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmaNvValue = unsafe.Sizeof([1]C.TPMA_NV{})

// copyPTpmaObjectBytes copies the data from Go slice as *C.TPMA_OBJECT.
func copyPTpmaObjectBytes(slice *sliceHeader) (*C.TPMA_OBJECT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmaObjectValue) * slice.Len,
		Cap:  int(sizeOfTpmaObjectValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMA_OBJECT)(mem0), allocs
}

// allocTpmaObjectMemory allocates memory for type C.TPMA_OBJECT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmaObjectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmaObjectValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmaObjectValue = unsafe.Sizeof([1]C.TPMA_OBJECT{})

// copyPTpmaPermanentBytes copies the data from Go slice as *C.TPMA_PERMANENT.
func copyPTpmaPermanentBytes(slice *sliceHeader) (*C.TPMA_PERMANENT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmaPermanentValue) * slice.Len,
		Cap:  int(sizeOfTpmaPermanentValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMA_PERMANENT)(mem0), allocs
}

// allocTpmaPermanentMemory allocates memory for type C.TPMA_PERMANENT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmaPermanentMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmaPermanentValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmaPermanentValue = unsafe.Sizeof([1]C.TPMA_PERMANENT{})

// copyPTpmaStartupClearBytes copies the data from Go slice as *C.TPMA_STARTUP_CLEAR.
func copyPTpmaStartupClearBytes(slice *sliceHeader) (*C.TPMA_STARTUP_CLEAR, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmaStartupClearValue) * slice.Len,
		Cap:  int(sizeOfTpmaStartupClearValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMA_STARTUP_CLEAR)(mem0), allocs
}

// allocTpmaStartupClearMemory allocates memory for type C.TPMA_STARTUP_CLEAR in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmaStartupClearMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmaStartupClearValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmaStartupClearValue = unsafe.Sizeof([1]C.TPMA_STARTUP_CLEAR{})

// unpackArgSTpm2bPrivateKeyRsa transforms a sliced Go data structure into plain C format.
func unpackArgSTpm2bPrivateKeyRsa(x []Tpm2bPrivateKeyRsa) (unpacked *C.TPM2B_PRIVATE_KEY_RSA, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpm2bPrivateKeyRsaMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPM2B_PRIVATE_KEY_RSA)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPM2B_PRIVATE_KEY_RSA)(h.Data)
	return
}

// packSTpm2bPrivateKeyRsa reads sliced Go data structure out from plain C format.
func packSTpm2bPrivateKeyRsa(v []Tpm2bPrivateKeyRsa, ptr0 *C.TPM2B_PRIVATE_KEY_RSA) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpm2bPrivateKeyRsaValue]C.TPM2B_PRIVATE_KEY_RSA)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpm2bPrivateKeyRsaRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpm2bContextSensitive transforms a sliced Go data structure into plain C format.
func unpackArgSTpm2bContextSensitive(x []Tpm2bContextSensitive) (unpacked *C.TPM2B_CONTEXT_SENSITIVE, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpm2bContextSensitiveMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPM2B_CONTEXT_SENSITIVE)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPM2B_CONTEXT_SENSITIVE)(h.Data)
	return
}

// packSTpm2bContextSensitive reads sliced Go data structure out from plain C format.
func packSTpm2bContextSensitive(v []Tpm2bContextSensitive, ptr0 *C.TPM2B_CONTEXT_SENSITIVE) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpm2bContextSensitiveValue]C.TPM2B_CONTEXT_SENSITIVE)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpm2bContextSensitiveRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpm2bContextData transforms a sliced Go data structure into plain C format.
func unpackArgSTpm2bContextData(x []Tpm2bContextData) (unpacked *C.TPM2B_CONTEXT_DATA, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpm2bContextDataMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPM2B_CONTEXT_DATA)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPM2B_CONTEXT_DATA)(h.Data)
	return
}

// packSTpm2bContextData reads sliced Go data structure out from plain C format.
func packSTpm2bContextData(v []Tpm2bContextData, ptr0 *C.TPM2B_CONTEXT_DATA) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpm2bContextDataValue]C.TPM2B_CONTEXT_DATA)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpm2bContextDataRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpm2bSymKey transforms a sliced Go data structure into plain C format.
func unpackArgSTpm2bSymKey(x []Tpm2bSymKey) (unpacked *C.TPM2B_SYM_KEY, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpm2bSymKeyMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPM2B_SYM_KEY)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPM2B_SYM_KEY)(h.Data)
	return
}

// packSTpm2bSymKey reads sliced Go data structure out from plain C format.
func packSTpm2bSymKey(v []Tpm2bSymKey, ptr0 *C.TPM2B_SYM_KEY) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpm2bSymKeyValue]C.TPM2B_SYM_KEY)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpm2bSymKeyRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmsEccPoint transforms a sliced Go data structure into plain C format.
func unpackArgSTpmsEccPoint(x []TpmsEccPoint) (unpacked *C.TPMS_ECC_POINT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmsEccPointMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMS_ECC_POINT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMS_ECC_POINT)(h.Data)
	return
}

// packSTpmsEccPoint reads sliced Go data structure out from plain C format.
func packSTpmsEccPoint(v []TpmsEccPoint, ptr0 *C.TPMS_ECC_POINT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmsEccPointValue]C.TPMS_ECC_POINT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmsEccPointRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmsNvPublic transforms a sliced Go data structure into plain C format.
func unpackArgSTpmsNvPublic(x []TpmsNvPublic) (unpacked *C.TPMS_NV_PUBLIC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmsNvPublicMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMS_NV_PUBLIC)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMS_NV_PUBLIC)(h.Data)
	return
}

// packSTpmsNvPublic reads sliced Go data structure out from plain C format.
func packSTpmsNvPublic(v []TpmsNvPublic, ptr0 *C.TPMS_NV_PUBLIC) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmsNvPublicValue]C.TPMS_NV_PUBLIC)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmsNvPublicRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmsAlgProperty transforms a sliced Go data structure into plain C format.
func unpackArgSTpmsAlgProperty(x []TpmsAlgProperty) (unpacked *C.TPMS_ALG_PROPERTY, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmsAlgPropertyMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMS_ALG_PROPERTY)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMS_ALG_PROPERTY)(h.Data)
	return
}

// packSTpmsAlgProperty reads sliced Go data structure out from plain C format.
func packSTpmsAlgProperty(v []TpmsAlgProperty, ptr0 *C.TPMS_ALG_PROPERTY) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmsAlgPropertyValue]C.TPMS_ALG_PROPERTY)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmsAlgPropertyRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmsAlgorithmDescription transforms a sliced Go data structure into plain C format.
func unpackArgSTpmsAlgorithmDescription(x []TpmsAlgorithmDescription) (unpacked *C.TPMS_ALGORITHM_DESCRIPTION, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmsAlgorithmDescriptionMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMS_ALGORITHM_DESCRIPTION)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMS_ALGORITHM_DESCRIPTION)(h.Data)
	return
}

// packSTpmsAlgorithmDescription reads sliced Go data structure out from plain C format.
func packSTpmsAlgorithmDescription(v []TpmsAlgorithmDescription, ptr0 *C.TPMS_ALGORITHM_DESCRIPTION) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmsAlgorithmDescriptionValue]C.TPMS_ALGORITHM_DESCRIPTION)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmsAlgorithmDescriptionRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmsTaggedProperty transforms a sliced Go data structure into plain C format.
func unpackArgSTpmsTaggedProperty(x []TpmsTaggedProperty) (unpacked *C.TPMS_TAGGED_PROPERTY, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmsTaggedPropertyMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMS_TAGGED_PROPERTY)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMS_TAGGED_PROPERTY)(h.Data)
	return
}

// packSTpmsTaggedProperty reads sliced Go data structure out from plain C format.
func packSTpmsTaggedProperty(v []TpmsTaggedProperty, ptr0 *C.TPMS_TAGGED_PROPERTY) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmsTaggedPropertyValue]C.TPMS_TAGGED_PROPERTY)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmsTaggedPropertyRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmsTaggedPolicy transforms a sliced Go data structure into plain C format.
func unpackArgSTpmsTaggedPolicy(x []TpmsTaggedPolicy) (unpacked *C.TPMS_TAGGED_POLICY, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmsTaggedPolicyMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMS_TAGGED_POLICY)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMS_TAGGED_POLICY)(h.Data)
	return
}

// packSTpmsTaggedPolicy reads sliced Go data structure out from plain C format.
func packSTpmsTaggedPolicy(v []TpmsTaggedPolicy, ptr0 *C.TPMS_TAGGED_POLICY) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmsTaggedPolicyValue]C.TPMS_TAGGED_POLICY)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmsTaggedPolicyRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmsClockInfo transforms a sliced Go data structure into plain C format.
func unpackArgSTpmsClockInfo(x []TpmsClockInfo) (unpacked *C.TPMS_CLOCK_INFO, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmsClockInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMS_CLOCK_INFO)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMS_CLOCK_INFO)(h.Data)
	return
}

// packSTpmsClockInfo reads sliced Go data structure out from plain C format.
func packSTpmsClockInfo(v []TpmsClockInfo, ptr0 *C.TPMS_CLOCK_INFO) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmsClockInfoValue]C.TPMS_CLOCK_INFO)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmsClockInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmsTimeAttestInfo transforms a sliced Go data structure into plain C format.
func unpackArgSTpmsTimeAttestInfo(x []TpmsTimeAttestInfo) (unpacked *C.TPMS_TIME_ATTEST_INFO, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmsTimeAttestInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMS_TIME_ATTEST_INFO)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMS_TIME_ATTEST_INFO)(h.Data)
	return
}

// packSTpmsTimeAttestInfo reads sliced Go data structure out from plain C format.
func packSTpmsTimeAttestInfo(v []TpmsTimeAttestInfo, ptr0 *C.TPMS_TIME_ATTEST_INFO) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmsTimeAttestInfoValue]C.TPMS_TIME_ATTEST_INFO)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmsTimeAttestInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmsCertifyInfo transforms a sliced Go data structure into plain C format.
func unpackArgSTpmsCertifyInfo(x []TpmsCertifyInfo) (unpacked *C.TPMS_CERTIFY_INFO, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmsCertifyInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMS_CERTIFY_INFO)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMS_CERTIFY_INFO)(h.Data)
	return
}

// packSTpmsCertifyInfo reads sliced Go data structure out from plain C format.
func packSTpmsCertifyInfo(v []TpmsCertifyInfo, ptr0 *C.TPMS_CERTIFY_INFO) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmsCertifyInfoValue]C.TPMS_CERTIFY_INFO)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmsCertifyInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmsCommandAuditInfo transforms a sliced Go data structure into plain C format.
func unpackArgSTpmsCommandAuditInfo(x []TpmsCommandAuditInfo) (unpacked *C.TPMS_COMMAND_AUDIT_INFO, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmsCommandAuditInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMS_COMMAND_AUDIT_INFO)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMS_COMMAND_AUDIT_INFO)(h.Data)
	return
}

// packSTpmsCommandAuditInfo reads sliced Go data structure out from plain C format.
func packSTpmsCommandAuditInfo(v []TpmsCommandAuditInfo, ptr0 *C.TPMS_COMMAND_AUDIT_INFO) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmsCommandAuditInfoValue]C.TPMS_COMMAND_AUDIT_INFO)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmsCommandAuditInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmsSessionAuditInfo transforms a sliced Go data structure into plain C format.
func unpackArgSTpmsSessionAuditInfo(x []TpmsSessionAuditInfo) (unpacked *C.TPMS_SESSION_AUDIT_INFO, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmsSessionAuditInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMS_SESSION_AUDIT_INFO)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMS_SESSION_AUDIT_INFO)(h.Data)
	return
}

// packSTpmsSessionAuditInfo reads sliced Go data structure out from plain C format.
func packSTpmsSessionAuditInfo(v []TpmsSessionAuditInfo, ptr0 *C.TPMS_SESSION_AUDIT_INFO) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmsSessionAuditInfoValue]C.TPMS_SESSION_AUDIT_INFO)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmsSessionAuditInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmsCreationInfo transforms a sliced Go data structure into plain C format.
func unpackArgSTpmsCreationInfo(x []TpmsCreationInfo) (unpacked *C.TPMS_CREATION_INFO, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmsCreationInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMS_CREATION_INFO)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMS_CREATION_INFO)(h.Data)
	return
}

// packSTpmsCreationInfo reads sliced Go data structure out from plain C format.
func packSTpmsCreationInfo(v []TpmsCreationInfo, ptr0 *C.TPMS_CREATION_INFO) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmsCreationInfoValue]C.TPMS_CREATION_INFO)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmsCreationInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmsNvCertifyInfo transforms a sliced Go data structure into plain C format.
func unpackArgSTpmsNvCertifyInfo(x []TpmsNvCertifyInfo) (unpacked *C.TPMS_NV_CERTIFY_INFO, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmsNvCertifyInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMS_NV_CERTIFY_INFO)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMS_NV_CERTIFY_INFO)(h.Data)
	return
}

// packSTpmsNvCertifyInfo reads sliced Go data structure out from plain C format.
func packSTpmsNvCertifyInfo(v []TpmsNvCertifyInfo, ptr0 *C.TPMS_NV_CERTIFY_INFO) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmsNvCertifyInfoValue]C.TPMS_NV_CERTIFY_INFO)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmsNvCertifyInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmsAuthCommand transforms a sliced Go data structure into plain C format.
func unpackArgSTpmsAuthCommand(x []TpmsAuthCommand) (unpacked *C.TPMS_AUTH_COMMAND, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmsAuthCommandMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMS_AUTH_COMMAND)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMS_AUTH_COMMAND)(h.Data)
	return
}

// packSTpmsAuthCommand reads sliced Go data structure out from plain C format.
func packSTpmsAuthCommand(v []TpmsAuthCommand, ptr0 *C.TPMS_AUTH_COMMAND) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmsAuthCommandValue]C.TPMS_AUTH_COMMAND)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmsAuthCommandRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmsAuthResponse transforms a sliced Go data structure into plain C format.
func unpackArgSTpmsAuthResponse(x []TpmsAuthResponse) (unpacked *C.TPMS_AUTH_RESPONSE, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmsAuthResponseMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMS_AUTH_RESPONSE)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMS_AUTH_RESPONSE)(h.Data)
	return
}

// packSTpmsAuthResponse reads sliced Go data structure out from plain C format.
func packSTpmsAuthResponse(v []TpmsAuthResponse, ptr0 *C.TPMS_AUTH_RESPONSE) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmsAuthResponseValue]C.TPMS_AUTH_RESPONSE)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmsAuthResponseRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmsSensitiveCreate transforms a sliced Go data structure into plain C format.
func unpackArgSTpmsSensitiveCreate(x []TpmsSensitiveCreate) (unpacked *C.TPMS_SENSITIVE_CREATE, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmsSensitiveCreateMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMS_SENSITIVE_CREATE)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMS_SENSITIVE_CREATE)(h.Data)
	return
}

// packSTpmsSensitiveCreate reads sliced Go data structure out from plain C format.
func packSTpmsSensitiveCreate(v []TpmsSensitiveCreate, ptr0 *C.TPMS_SENSITIVE_CREATE) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmsSensitiveCreateValue]C.TPMS_SENSITIVE_CREATE)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmsSensitiveCreateRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmsSchemeHash transforms a sliced Go data structure into plain C format.
func unpackArgSTpmsSchemeHash(x []TpmsSchemeHash) (unpacked *C.TPMS_SCHEME_HASH, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmsSchemeHashMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMS_SCHEME_HASH)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMS_SCHEME_HASH)(h.Data)
	return
}

// packSTpmsSchemeHash reads sliced Go data structure out from plain C format.
func packSTpmsSchemeHash(v []TpmsSchemeHash, ptr0 *C.TPMS_SCHEME_HASH) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmsSchemeHashValue]C.TPMS_SCHEME_HASH)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmsSchemeHashRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmsSchemeEcdaa transforms a sliced Go data structure into plain C format.
func unpackArgSTpmsSchemeEcdaa(x []TpmsSchemeEcdaa) (unpacked *C.TPMS_SCHEME_ECDAA, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmsSchemeEcdaaMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMS_SCHEME_ECDAA)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMS_SCHEME_ECDAA)(h.Data)
	return
}

// packSTpmsSchemeEcdaa reads sliced Go data structure out from plain C format.
func packSTpmsSchemeEcdaa(v []TpmsSchemeEcdaa, ptr0 *C.TPMS_SCHEME_ECDAA) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmsSchemeEcdaaValue]C.TPMS_SCHEME_ECDAA)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmsSchemeEcdaaRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmsSchemeXor transforms a sliced Go data structure into plain C format.
func unpackArgSTpmsSchemeXor(x []TpmsSchemeXor) (unpacked *C.TPMS_SCHEME_XOR, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmsSchemeXorMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMS_SCHEME_XOR)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMS_SCHEME_XOR)(h.Data)
	return
}

// packSTpmsSchemeXor reads sliced Go data structure out from plain C format.
func packSTpmsSchemeXor(v []TpmsSchemeXor, ptr0 *C.TPMS_SCHEME_XOR) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmsSchemeXorValue]C.TPMS_SCHEME_XOR)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmsSchemeXorRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmsSignatureRsa transforms a sliced Go data structure into plain C format.
func unpackArgSTpmsSignatureRsa(x []TpmsSignatureRsa) (unpacked *C.TPMS_SIGNATURE_RSA, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmsSignatureRsaMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMS_SIGNATURE_RSA)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMS_SIGNATURE_RSA)(h.Data)
	return
}

// packSTpmsSignatureRsa reads sliced Go data structure out from plain C format.
func packSTpmsSignatureRsa(v []TpmsSignatureRsa, ptr0 *C.TPMS_SIGNATURE_RSA) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmsSignatureRsaValue]C.TPMS_SIGNATURE_RSA)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmsSignatureRsaRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmsSignatureEcc transforms a sliced Go data structure into plain C format.
func unpackArgSTpmsSignatureEcc(x []TpmsSignatureEcc) (unpacked *C.TPMS_SIGNATURE_ECC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmsSignatureEccMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMS_SIGNATURE_ECC)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMS_SIGNATURE_ECC)(h.Data)
	return
}

// packSTpmsSignatureEcc reads sliced Go data structure out from plain C format.
func packSTpmsSignatureEcc(v []TpmsSignatureEcc, ptr0 *C.TPMS_SIGNATURE_ECC) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmsSignatureEccValue]C.TPMS_SIGNATURE_ECC)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmsSignatureEccRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmsNvPinCounterParameters transforms a sliced Go data structure into plain C format.
func unpackArgSTpmsNvPinCounterParameters(x []TpmsNvPinCounterParameters) (unpacked *C.TPMS_NV_PIN_COUNTER_PARAMETERS, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmsNvPinCounterParametersMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMS_NV_PIN_COUNTER_PARAMETERS)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMS_NV_PIN_COUNTER_PARAMETERS)(h.Data)
	return
}

// packSTpmsNvPinCounterParameters reads sliced Go data structure out from plain C format.
func packSTpmsNvPinCounterParameters(v []TpmsNvPinCounterParameters, ptr0 *C.TPMS_NV_PIN_COUNTER_PARAMETERS) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmsNvPinCounterParametersValue]C.TPMS_NV_PIN_COUNTER_PARAMETERS)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmsNvPinCounterParametersRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmsContextData transforms a sliced Go data structure into plain C format.
func unpackArgSTpmsContextData(x []TpmsContextData) (unpacked *C.TPMS_CONTEXT_DATA, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmsContextDataMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMS_CONTEXT_DATA)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMS_CONTEXT_DATA)(h.Data)
	return
}

// packSTpmsContextData reads sliced Go data structure out from plain C format.
func packSTpmsContextData(v []TpmsContextData, ptr0 *C.TPMS_CONTEXT_DATA) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmsContextDataValue]C.TPMS_CONTEXT_DATA)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmsContextDataRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmsPcrSelect transforms a sliced Go data structure into plain C format.
func unpackArgSTpmsPcrSelect(x []TpmsPcrSelect) (unpacked *C.TPMS_PCR_SELECT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmsPcrSelectMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMS_PCR_SELECT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMS_PCR_SELECT)(h.Data)
	return
}

// packSTpmsPcrSelect reads sliced Go data structure out from plain C format.
func packSTpmsPcrSelect(v []TpmsPcrSelect, ptr0 *C.TPMS_PCR_SELECT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmsPcrSelectValue]C.TPMS_PCR_SELECT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmsPcrSelectRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmsPcrSelection transforms a sliced Go data structure into plain C format.
func unpackArgSTpmsPcrSelection(x []TpmsPcrSelection) (unpacked *C.TPMS_PCR_SELECTION, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmsPcrSelectionMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMS_PCR_SELECTION)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMS_PCR_SELECTION)(h.Data)
	return
}

// packSTpmsPcrSelection reads sliced Go data structure out from plain C format.
func packSTpmsPcrSelection(v []TpmsPcrSelection, ptr0 *C.TPMS_PCR_SELECTION) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmsPcrSelectionValue]C.TPMS_PCR_SELECTION)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmsPcrSelectionRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmsTaggedPcrSelect transforms a sliced Go data structure into plain C format.
func unpackArgSTpmsTaggedPcrSelect(x []TpmsTaggedPcrSelect) (unpacked *C.TPMS_TAGGED_PCR_SELECT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmsTaggedPcrSelectMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMS_TAGGED_PCR_SELECT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMS_TAGGED_PCR_SELECT)(h.Data)
	return
}

// packSTpmsTaggedPcrSelect reads sliced Go data structure out from plain C format.
func packSTpmsTaggedPcrSelect(v []TpmsTaggedPcrSelect, ptr0 *C.TPMS_TAGGED_PCR_SELECT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmsTaggedPcrSelectValue]C.TPMS_TAGGED_PCR_SELECT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmsTaggedPcrSelectRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmsQuoteInfo transforms a sliced Go data structure into plain C format.
func unpackArgSTpmsQuoteInfo(x []TpmsQuoteInfo) (unpacked *C.TPMS_QUOTE_INFO, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmsQuoteInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMS_QUOTE_INFO)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMS_QUOTE_INFO)(h.Data)
	return
}

// packSTpmsQuoteInfo reads sliced Go data structure out from plain C format.
func packSTpmsQuoteInfo(v []TpmsQuoteInfo, ptr0 *C.TPMS_QUOTE_INFO) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmsQuoteInfoValue]C.TPMS_QUOTE_INFO)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmsQuoteInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmsCreationData transforms a sliced Go data structure into plain C format.
func unpackArgSTpmsCreationData(x []TpmsCreationData) (unpacked *C.TPMS_CREATION_DATA, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmsCreationDataMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMS_CREATION_DATA)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMS_CREATION_DATA)(h.Data)
	return
}

// packSTpmsCreationData reads sliced Go data structure out from plain C format.
func packSTpmsCreationData(v []TpmsCreationData, ptr0 *C.TPMS_CREATION_DATA) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmsCreationDataValue]C.TPMS_CREATION_DATA)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmsCreationDataRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmsEccParms transforms a sliced Go data structure into plain C format.
func unpackArgSTpmsEccParms(x []TpmsEccParms) (unpacked *C.TPMS_ECC_PARMS, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmsEccParmsMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMS_ECC_PARMS)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMS_ECC_PARMS)(h.Data)
	return
}

// packSTpmsEccParms reads sliced Go data structure out from plain C format.
func packSTpmsEccParms(v []TpmsEccParms, ptr0 *C.TPMS_ECC_PARMS) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmsEccParmsValue]C.TPMS_ECC_PARMS)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmsEccParmsRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmsAttest transforms a sliced Go data structure into plain C format.
func unpackArgSTpmsAttest(x []TpmsAttest) (unpacked *C.TPMS_ATTEST, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmsAttestMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMS_ATTEST)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMS_ATTEST)(h.Data)
	return
}

// packSTpmsAttest reads sliced Go data structure out from plain C format.
func packSTpmsAttest(v []TpmsAttest, ptr0 *C.TPMS_ATTEST) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmsAttestValue]C.TPMS_ATTEST)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmsAttestRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmsKeyedhashParms transforms a sliced Go data structure into plain C format.
func unpackArgSTpmsKeyedhashParms(x []TpmsKeyedhashParms) (unpacked *C.TPMS_KEYEDHASH_PARMS, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmsKeyedhashParmsMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMS_KEYEDHASH_PARMS)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMS_KEYEDHASH_PARMS)(h.Data)
	return
}

// packSTpmsKeyedhashParms reads sliced Go data structure out from plain C format.
func packSTpmsKeyedhashParms(v []TpmsKeyedhashParms, ptr0 *C.TPMS_KEYEDHASH_PARMS) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmsKeyedhashParmsValue]C.TPMS_KEYEDHASH_PARMS)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmsKeyedhashParmsRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmsRsaParms transforms a sliced Go data structure into plain C format.
func unpackArgSTpmsRsaParms(x []TpmsRsaParms) (unpacked *C.TPMS_RSA_PARMS, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmsRsaParmsMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMS_RSA_PARMS)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMS_RSA_PARMS)(h.Data)
	return
}

// packSTpmsRsaParms reads sliced Go data structure out from plain C format.
func packSTpmsRsaParms(v []TpmsRsaParms, ptr0 *C.TPMS_RSA_PARMS) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmsRsaParmsValue]C.TPMS_RSA_PARMS)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmsRsaParmsRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmsSymcipherParms transforms a sliced Go data structure into plain C format.
func unpackArgSTpmsSymcipherParms(x []TpmsSymcipherParms) (unpacked *C.TPMS_SYMCIPHER_PARMS, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmsSymcipherParmsMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMS_SYMCIPHER_PARMS)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMS_SYMCIPHER_PARMS)(h.Data)
	return
}

// packSTpmsSymcipherParms reads sliced Go data structure out from plain C format.
func packSTpmsSymcipherParms(v []TpmsSymcipherParms, ptr0 *C.TPMS_SYMCIPHER_PARMS) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmsSymcipherParmsValue]C.TPMS_SYMCIPHER_PARMS)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmsSymcipherParmsRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmsIdObject transforms a sliced Go data structure into plain C format.
func unpackArgSTpmsIdObject(x []TpmsIdObject) (unpacked *C.TPMS_ID_OBJECT, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmsIdObjectMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMS_ID_OBJECT)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMS_ID_OBJECT)(h.Data)
	return
}

// packSTpmsIdObject reads sliced Go data structure out from plain C format.
func packSTpmsIdObject(v []TpmsIdObject, ptr0 *C.TPMS_ID_OBJECT) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmsIdObjectValue]C.TPMS_ID_OBJECT)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmsIdObjectRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmlCca transforms a sliced Go data structure into plain C format.
func unpackArgSTpmlCca(x []TpmlCca) (unpacked *C.TPML_CCA, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmlCcaMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPML_CCA)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPML_CCA)(h.Data)
	return
}

// packSTpmlCca reads sliced Go data structure out from plain C format.
func packSTpmlCca(v []TpmlCca, ptr0 *C.TPML_CCA) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmlCcaValue]C.TPML_CCA)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmlCcaRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmlHandle transforms a sliced Go data structure into plain C format.
func unpackArgSTpmlHandle(x []TpmlHandle) (unpacked *C.TPML_HANDLE, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmlHandleMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPML_HANDLE)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPML_HANDLE)(h.Data)
	return
}

// packSTpmlHandle reads sliced Go data structure out from plain C format.
func packSTpmlHandle(v []TpmlHandle, ptr0 *C.TPML_HANDLE) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmlHandleValue]C.TPML_HANDLE)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmlHandleRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmlAlgProperty transforms a sliced Go data structure into plain C format.
func unpackArgSTpmlAlgProperty(x []TpmlAlgProperty) (unpacked *C.TPML_ALG_PROPERTY, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmlAlgPropertyMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPML_ALG_PROPERTY)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPML_ALG_PROPERTY)(h.Data)
	return
}

// packSTpmlAlgProperty reads sliced Go data structure out from plain C format.
func packSTpmlAlgProperty(v []TpmlAlgProperty, ptr0 *C.TPML_ALG_PROPERTY) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmlAlgPropertyValue]C.TPML_ALG_PROPERTY)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmlAlgPropertyRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmlEccCurve transforms a sliced Go data structure into plain C format.
func unpackArgSTpmlEccCurve(x []TpmlEccCurve) (unpacked *C.TPML_ECC_CURVE, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmlEccCurveMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPML_ECC_CURVE)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPML_ECC_CURVE)(h.Data)
	return
}

// packSTpmlEccCurve reads sliced Go data structure out from plain C format.
func packSTpmlEccCurve(v []TpmlEccCurve, ptr0 *C.TPML_ECC_CURVE) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmlEccCurveValue]C.TPML_ECC_CURVE)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmlEccCurveRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmlTaggedPcrProperty transforms a sliced Go data structure into plain C format.
func unpackArgSTpmlTaggedPcrProperty(x []TpmlTaggedPcrProperty) (unpacked *C.TPML_TAGGED_PCR_PROPERTY, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmlTaggedPcrPropertyMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPML_TAGGED_PCR_PROPERTY)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPML_TAGGED_PCR_PROPERTY)(h.Data)
	return
}

// packSTpmlTaggedPcrProperty reads sliced Go data structure out from plain C format.
func packSTpmlTaggedPcrProperty(v []TpmlTaggedPcrProperty, ptr0 *C.TPML_TAGGED_PCR_PROPERTY) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmlTaggedPcrPropertyValue]C.TPML_TAGGED_PCR_PROPERTY)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmlTaggedPcrPropertyRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmlTaggedTpmProperty transforms a sliced Go data structure into plain C format.
func unpackArgSTpmlTaggedTpmProperty(x []TpmlTaggedTpmProperty) (unpacked *C.TPML_TAGGED_TPM_PROPERTY, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmlTaggedTpmPropertyMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPML_TAGGED_TPM_PROPERTY)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPML_TAGGED_TPM_PROPERTY)(h.Data)
	return
}

// packSTpmlTaggedTpmProperty reads sliced Go data structure out from plain C format.
func packSTpmlTaggedTpmProperty(v []TpmlTaggedTpmProperty, ptr0 *C.TPML_TAGGED_TPM_PROPERTY) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmlTaggedTpmPropertyValue]C.TPML_TAGGED_TPM_PROPERTY)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmlTaggedTpmPropertyRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmlIntelPttProperty transforms a sliced Go data structure into plain C format.
func unpackArgSTpmlIntelPttProperty(x []TpmlIntelPttProperty) (unpacked *C.TPML_INTEL_PTT_PROPERTY, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmlIntelPttPropertyMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPML_INTEL_PTT_PROPERTY)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPML_INTEL_PTT_PROPERTY)(h.Data)
	return
}

// packSTpmlIntelPttProperty reads sliced Go data structure out from plain C format.
func packSTpmlIntelPttProperty(v []TpmlIntelPttProperty, ptr0 *C.TPML_INTEL_PTT_PROPERTY) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmlIntelPttPropertyValue]C.TPML_INTEL_PTT_PROPERTY)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmlIntelPttPropertyRef(unsafe.Pointer(&ptr1))
	}
}

// copyPTpmuHaBytes copies the data from Go slice as *C.TPMU_HA.
func copyPTpmuHaBytes(slice *sliceHeader) (*C.TPMU_HA, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmuHaValue) * slice.Len,
		Cap:  int(sizeOfTpmuHaValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMU_HA)(mem0), allocs
}

// allocTpmuHaMemory allocates memory for type C.TPMU_HA in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmuHaMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmuHaValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmuHaValue = unsafe.Sizeof([1]C.TPMU_HA{})

// copyPTpmuCapabilitiesBytes copies the data from Go slice as *C.TPMU_CAPABILITIES.
func copyPTpmuCapabilitiesBytes(slice *sliceHeader) (*C.TPMU_CAPABILITIES, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmuCapabilitiesValue) * slice.Len,
		Cap:  int(sizeOfTpmuCapabilitiesValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMU_CAPABILITIES)(mem0), allocs
}

// allocTpmuCapabilitiesMemory allocates memory for type C.TPMU_CAPABILITIES in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmuCapabilitiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmuCapabilitiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmuCapabilitiesValue = unsafe.Sizeof([1]C.TPMU_CAPABILITIES{})

// copyPTpmuAttestBytes copies the data from Go slice as *C.TPMU_ATTEST.
func copyPTpmuAttestBytes(slice *sliceHeader) (*C.TPMU_ATTEST, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmuAttestValue) * slice.Len,
		Cap:  int(sizeOfTpmuAttestValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMU_ATTEST)(mem0), allocs
}

// allocTpmuAttestMemory allocates memory for type C.TPMU_ATTEST in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmuAttestMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmuAttestValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmuAttestValue = unsafe.Sizeof([1]C.TPMU_ATTEST{})

// copyPTpmuSymKeyBitsBytes copies the data from Go slice as *C.TPMU_SYM_KEY_BITS.
func copyPTpmuSymKeyBitsBytes(slice *sliceHeader) (*C.TPMU_SYM_KEY_BITS, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmuSymKeyBitsValue) * slice.Len,
		Cap:  int(sizeOfTpmuSymKeyBitsValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMU_SYM_KEY_BITS)(mem0), allocs
}

// allocTpmuSymKeyBitsMemory allocates memory for type C.TPMU_SYM_KEY_BITS in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmuSymKeyBitsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmuSymKeyBitsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmuSymKeyBitsValue = unsafe.Sizeof([1]C.TPMU_SYM_KEY_BITS{})

// copyPTpmuSymModeBytes copies the data from Go slice as *C.TPMU_SYM_MODE.
func copyPTpmuSymModeBytes(slice *sliceHeader) (*C.TPMU_SYM_MODE, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmuSymModeValue) * slice.Len,
		Cap:  int(sizeOfTpmuSymModeValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMU_SYM_MODE)(mem0), allocs
}

// allocTpmuSymModeMemory allocates memory for type C.TPMU_SYM_MODE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmuSymModeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmuSymModeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmuSymModeValue = unsafe.Sizeof([1]C.TPMU_SYM_MODE{})

// copyPTpmuSigSchemeBytes copies the data from Go slice as *C.TPMU_SIG_SCHEME.
func copyPTpmuSigSchemeBytes(slice *sliceHeader) (*C.TPMU_SIG_SCHEME, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmuSigSchemeValue) * slice.Len,
		Cap:  int(sizeOfTpmuSigSchemeValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMU_SIG_SCHEME)(mem0), allocs
}

// allocTpmuSigSchemeMemory allocates memory for type C.TPMU_SIG_SCHEME in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmuSigSchemeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmuSigSchemeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmuSigSchemeValue = unsafe.Sizeof([1]C.TPMU_SIG_SCHEME{})

// copyPTpmuKdfSchemeBytes copies the data from Go slice as *C.TPMU_KDF_SCHEME.
func copyPTpmuKdfSchemeBytes(slice *sliceHeader) (*C.TPMU_KDF_SCHEME, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmuKdfSchemeValue) * slice.Len,
		Cap:  int(sizeOfTpmuKdfSchemeValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMU_KDF_SCHEME)(mem0), allocs
}

// allocTpmuKdfSchemeMemory allocates memory for type C.TPMU_KDF_SCHEME in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmuKdfSchemeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmuKdfSchemeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmuKdfSchemeValue = unsafe.Sizeof([1]C.TPMU_KDF_SCHEME{})

// copyPTpmuAsymSchemeBytes copies the data from Go slice as *C.TPMU_ASYM_SCHEME.
func copyPTpmuAsymSchemeBytes(slice *sliceHeader) (*C.TPMU_ASYM_SCHEME, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmuAsymSchemeValue) * slice.Len,
		Cap:  int(sizeOfTpmuAsymSchemeValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMU_ASYM_SCHEME)(mem0), allocs
}

// allocTpmuAsymSchemeMemory allocates memory for type C.TPMU_ASYM_SCHEME in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmuAsymSchemeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmuAsymSchemeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmuAsymSchemeValue = unsafe.Sizeof([1]C.TPMU_ASYM_SCHEME{})

// copyPTpmuSchemeKeyedhashBytes copies the data from Go slice as *C.TPMU_SCHEME_KEYEDHASH.
func copyPTpmuSchemeKeyedhashBytes(slice *sliceHeader) (*C.TPMU_SCHEME_KEYEDHASH, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmuSchemeKeyedhashValue) * slice.Len,
		Cap:  int(sizeOfTpmuSchemeKeyedhashValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMU_SCHEME_KEYEDHASH)(mem0), allocs
}

// allocTpmuSchemeKeyedhashMemory allocates memory for type C.TPMU_SCHEME_KEYEDHASH in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmuSchemeKeyedhashMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmuSchemeKeyedhashValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmuSchemeKeyedhashValue = unsafe.Sizeof([1]C.TPMU_SCHEME_KEYEDHASH{})

// copyPTpmuSignatureBytes copies the data from Go slice as *C.TPMU_SIGNATURE.
func copyPTpmuSignatureBytes(slice *sliceHeader) (*C.TPMU_SIGNATURE, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmuSignatureValue) * slice.Len,
		Cap:  int(sizeOfTpmuSignatureValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMU_SIGNATURE)(mem0), allocs
}

// allocTpmuSignatureMemory allocates memory for type C.TPMU_SIGNATURE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmuSignatureMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmuSignatureValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmuSignatureValue = unsafe.Sizeof([1]C.TPMU_SIGNATURE{})

// copyPTpmuSensitiveCompositeBytes copies the data from Go slice as *C.TPMU_SENSITIVE_COMPOSITE.
func copyPTpmuSensitiveCompositeBytes(slice *sliceHeader) (*C.TPMU_SENSITIVE_COMPOSITE, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmuSensitiveCompositeValue) * slice.Len,
		Cap:  int(sizeOfTpmuSensitiveCompositeValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMU_SENSITIVE_COMPOSITE)(mem0), allocs
}

// allocTpmuSensitiveCompositeMemory allocates memory for type C.TPMU_SENSITIVE_COMPOSITE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmuSensitiveCompositeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmuSensitiveCompositeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmuSensitiveCompositeValue = unsafe.Sizeof([1]C.TPMU_SENSITIVE_COMPOSITE{})

// copyPTpmuPublicParmsBytes copies the data from Go slice as *C.TPMU_PUBLIC_PARMS.
func copyPTpmuPublicParmsBytes(slice *sliceHeader) (*C.TPMU_PUBLIC_PARMS, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmuPublicParmsValue) * slice.Len,
		Cap:  int(sizeOfTpmuPublicParmsValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMU_PUBLIC_PARMS)(mem0), allocs
}

// allocTpmuPublicParmsMemory allocates memory for type C.TPMU_PUBLIC_PARMS in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmuPublicParmsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmuPublicParmsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmuPublicParmsValue = unsafe.Sizeof([1]C.TPMU_PUBLIC_PARMS{})

// copyPTpmuPublicIdBytes copies the data from Go slice as *C.TPMU_PUBLIC_ID.
func copyPTpmuPublicIdBytes(slice *sliceHeader) (*C.TPMU_PUBLIC_ID, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmuPublicIdValue) * slice.Len,
		Cap:  int(sizeOfTpmuPublicIdValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMU_PUBLIC_ID)(mem0), allocs
}

// allocTpmuPublicIdMemory allocates memory for type C.TPMU_PUBLIC_ID in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmuPublicIdMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmuPublicIdValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmuPublicIdValue = unsafe.Sizeof([1]C.TPMU_PUBLIC_ID{})

// copyPTpmuNameBytes copies the data from Go slice as *C.TPMU_NAME.
func copyPTpmuNameBytes(slice *sliceHeader) (*C.TPMU_NAME, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmuNameValue) * slice.Len,
		Cap:  int(sizeOfTpmuNameValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMU_NAME)(mem0), allocs
}

// allocTpmuNameMemory allocates memory for type C.TPMU_NAME in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmuNameMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmuNameValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmuNameValue = unsafe.Sizeof([1]C.TPMU_NAME{})

// unpackArgSTpmtKeyedhashScheme transforms a sliced Go data structure into plain C format.
func unpackArgSTpmtKeyedhashScheme(x []TpmtKeyedhashScheme) (unpacked *C.TPMT_KEYEDHASH_SCHEME, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmtKeyedhashSchemeMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMT_KEYEDHASH_SCHEME)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMT_KEYEDHASH_SCHEME)(h.Data)
	return
}

// packSTpmtKeyedhashScheme reads sliced Go data structure out from plain C format.
func packSTpmtKeyedhashScheme(v []TpmtKeyedhashScheme, ptr0 *C.TPMT_KEYEDHASH_SCHEME) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmtKeyedhashSchemeValue]C.TPMT_KEYEDHASH_SCHEME)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmtKeyedhashSchemeRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmtKdfScheme transforms a sliced Go data structure into plain C format.
func unpackArgSTpmtKdfScheme(x []TpmtKdfScheme) (unpacked *C.TPMT_KDF_SCHEME, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmtKdfSchemeMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMT_KDF_SCHEME)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMT_KDF_SCHEME)(h.Data)
	return
}

// packSTpmtKdfScheme reads sliced Go data structure out from plain C format.
func packSTpmtKdfScheme(v []TpmtKdfScheme, ptr0 *C.TPMT_KDF_SCHEME) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmtKdfSchemeValue]C.TPMT_KDF_SCHEME)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmtKdfSchemeRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmtAsymScheme transforms a sliced Go data structure into plain C format.
func unpackArgSTpmtAsymScheme(x []TpmtAsymScheme) (unpacked *C.TPMT_ASYM_SCHEME, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmtAsymSchemeMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMT_ASYM_SCHEME)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMT_ASYM_SCHEME)(h.Data)
	return
}

// packSTpmtAsymScheme reads sliced Go data structure out from plain C format.
func packSTpmtAsymScheme(v []TpmtAsymScheme, ptr0 *C.TPMT_ASYM_SCHEME) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmtAsymSchemeValue]C.TPMT_ASYM_SCHEME)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmtAsymSchemeRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmtRsaScheme transforms a sliced Go data structure into plain C format.
func unpackArgSTpmtRsaScheme(x []TpmtRsaScheme) (unpacked *C.TPMT_RSA_SCHEME, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmtRsaSchemeMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMT_RSA_SCHEME)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMT_RSA_SCHEME)(h.Data)
	return
}

// packSTpmtRsaScheme reads sliced Go data structure out from plain C format.
func packSTpmtRsaScheme(v []TpmtRsaScheme, ptr0 *C.TPMT_RSA_SCHEME) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmtRsaSchemeValue]C.TPMT_RSA_SCHEME)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmtRsaSchemeRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmtEccScheme transforms a sliced Go data structure into plain C format.
func unpackArgSTpmtEccScheme(x []TpmtEccScheme) (unpacked *C.TPMT_ECC_SCHEME, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmtEccSchemeMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMT_ECC_SCHEME)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMT_ECC_SCHEME)(h.Data)
	return
}

// packSTpmtEccScheme reads sliced Go data structure out from plain C format.
func packSTpmtEccScheme(v []TpmtEccScheme, ptr0 *C.TPMT_ECC_SCHEME) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmtEccSchemeValue]C.TPMT_ECC_SCHEME)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmtEccSchemeRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmtSensitive transforms a sliced Go data structure into plain C format.
func unpackArgSTpmtSensitive(x []TpmtSensitive) (unpacked *C.TPMT_SENSITIVE, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmtSensitiveMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMT_SENSITIVE)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMT_SENSITIVE)(h.Data)
	return
}

// packSTpmtSensitive reads sliced Go data structure out from plain C format.
func packSTpmtSensitive(v []TpmtSensitive, ptr0 *C.TPMT_SENSITIVE) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmtSensitiveValue]C.TPMT_SENSITIVE)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmtSensitiveRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSTpmtPublic transforms a sliced Go data structure into plain C format.
func unpackArgSTpmtPublic(x []TpmtPublic) (unpacked *C.TPMT_PUBLIC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmtPublicMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMT_PUBLIC)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMT_PUBLIC)(h.Data)
	return
}

// packSTpmtPublic reads sliced Go data structure out from plain C format.
func packSTpmtPublic(v []TpmtPublic, ptr0 *C.TPMT_PUBLIC) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmtPublicValue]C.TPMT_PUBLIC)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmtPublicRef(unsafe.Pointer(&ptr1))
	}
}

// copyPTpmiAlgHashBytes copies the data from Go slice as *C.TPMI_ALG_HASH.
func copyPTpmiAlgHashBytes(slice *sliceHeader) (*C.TPMI_ALG_HASH, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpmiAlgHashValue) * slice.Len,
		Cap:  int(sizeOfTpmiAlgHashValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPMI_ALG_HASH)(mem0), allocs
}

// allocTpmiAlgHashMemory allocates memory for type C.TPMI_ALG_HASH in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpmiAlgHashMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpmiAlgHashValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpmiAlgHashValue = unsafe.Sizeof([1]C.TPMI_ALG_HASH{})

// copyPTpm2SeBytes copies the data from Go slice as *C.TPM2_SE.
func copyPTpm2SeBytes(slice *sliceHeader) (*C.TPM2_SE, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2SeValue) * slice.Len,
		Cap:  int(sizeOfTpm2SeValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2_SE)(mem0), allocs
}

// allocTpm2SeMemory allocates memory for type C.TPM2_SE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2SeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2SeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2SeValue = unsafe.Sizeof([1]C.TPM2_SE{})

// copyPTpm2NtBytes copies the data from Go slice as *C.TPM2_NT.
func copyPTpm2NtBytes(slice *sliceHeader) (*C.TPM2_NT, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfTpm2NtValue) * slice.Len,
		Cap:  int(sizeOfTpm2NtValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.TPM2_NT)(mem0), allocs
}

// allocTpm2NtMemory allocates memory for type C.TPM2_NT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTpm2NtMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTpm2NtValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfTpm2NtValue = unsafe.Sizeof([1]C.TPM2_NT{})

// unpackArgSTpmsEmpty transforms a sliced Go data structure into plain C format.
func unpackArgSTpmsEmpty(x []TpmsEmpty) (unpacked *C.TPMS_EMPTY, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocTpmsEmptyMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.TPMS_EMPTY)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.TPMS_EMPTY)(h.Data)
	return
}

// packSTpmsEmpty reads sliced Go data structure out from plain C format.
func packSTpmsEmpty(v []TpmsEmpty, ptr0 *C.TPMS_EMPTY) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfTpmsEmptyValue]C.TPMS_EMPTY)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewTpmsEmptyRef(unsafe.Pointer(&ptr1))
	}
}

// unpackPCharString copies the data from Go string as *C.char.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CString(str))
	allocs.Add(mem0)
	return (*C.char)(mem0), allocs
}
